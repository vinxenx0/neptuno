Veamos algunas cosas que faltan:

ahora mismo solo tenemos la pagina checkout/ pero sola no es funcional
falta crear: marketplace/ que muestre los productos y categorias para que el usuario compre

por otro lado no hemos profundizado en la logica de la compra y los articulos, repasemos:

los articulos tendrán una propiedad mas: si son gratis (disponibles para anonimos) o de pago (necesitas registrarte
y tener un medio de pago para el checkout)

cuando el usuario anonimo entre a la pagina de marketplace podra ver todos los articulos
pero no podra añadir al carrito los productos de pago, esos tendra el boton de añadir al carrito apagado

cuando el usuario anonimo va a su checkout, solo puede descargar o recoger los productos gratuitos ya que no tienen
forma de pago

el usuario registrado si tendrá el proceso de checkout completo: eligiendo modo de pago y con boton de pagar 


actualiza el init_db con los nuevos escenarios que te narrado de inicio para productos gratuitos
ademas de algun producto mas tanto gratuito como free

y luego veamos, algunos errores:

al inicializar la db por primera vez con el market place:

(.venv) [28-abr-25 00:30:21] > cd backend/
(.venv) [28-abr-25 00:30:54] > python3 ini_db.py 
/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/pydantic/_internal/_config.py:345: UserWarning: Valid config keys have changed in V2:
* 'orm_mode' has been renamed to 'from_attributes'
  warnings.warn(message, UserWarning)
Creando tablas en la base de datos...
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/ini_db.py", line 638, in <module>
    init_db()
  File "/home/vinxenxo/neptuno/neptuno/backend/ini_db.py", line 33, in init_db
    Base.metadata.create_all(bind=engine)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 5907, in create_all
    bind._run_ddl_visitor(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 3249, in _run_ddl_visitor
    conn._run_ddl_visitor(visitorcallable, element, **kwargs)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 2456, in _run_ddl_visitor
    visitorcallable(self.dialect, self, **kwargs).traverse_single(element)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/visitors.py", line 664, in traverse_single
    return meth(obj, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 956, in visit_metadata
    collection = sort_tables_and_constraints(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1388, in sort_tables_and_constraints
    dependent_on = fkc.referred_table
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 4782, in referred_table
    return self.elements[0].column.table
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 1145, in __get__
    obj.__dict__[self.__name__] = result = self.fget(obj)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 3191, in column
    return self._resolve_column()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 3214, in _resolve_column
    raise exc.NoReferencedTableError(
sqlalchemy.exc.NoReferencedTableError: Foreign key associated with column 'cart_items.user_id' could not find table 'users' with which to generate a foreign key to target column 'id'

2025-04-28 00:36:40,249 - NeptunO - CRITICAL - Error inesperado en GET http://127.0.0.1:8000/v1/marketplace/orders: (sqlite3.OperationalError) no such column: order_items.product_name
[SQL: SELECT order_items.order_id AS order_items_order_id, order_items.id AS order_items_id, order_items.product_id AS order_items_product_id, order_items.quantity AS order_items_quantity, order_items.price AS order_items_price, order_items.product_name AS order_items_product_name, order_items.is_digital AS order_items_is_digital, order_items.file_path AS order_items_file_path 
FROM order_items 
WHERE order_items.order_id IN (?, ?, ?, ?, ?)]
[parameters: (1, 2, 3, 4, 5)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)
INFO:     127.0.0.1:48780 - "GET /v1/marketplace/orders HTTP/1.1" 500 Internal Server Error

Por otro lado no te olvides de reflejar todos los cambios en el icono de navbar de la aplicación, tanto en desktop como en mobile, fijate en como estan trabajdos el resto de de iconos

// frontend/src/components/web/Navbar.tsx
// Barra de navegación principal con estado de usuario y notificaciones
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import { usePathname } from "next/navigation";
import fetchAPI from "@/lib/api";
import {
  Button,
  Avatar,
  IconButton,
  Menu,
  MenuItem,
  useTheme,
  styled,
  Box,
  Typography,
  Snackbar,
  Alert,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Tooltip,
  Badge,
} from "@mui/material";
import {
  MonetizationOn,
  Settings,
  ListAlt,
  People,
  Dashboard,
  Login,
  PersonAdd,
  Person,
  Home,
  Star,
  EmojiEvents,
  Leaderboard,
  School,
  Menu as MenuIcon,
  ContactMail,
  Close,
  Key,
  LocalActivity,
  Mail,
  Favorite,
} from "@mui/icons-material";
import Image from "next/image";
import ShoppingCartIcon from "@mui/icons-material/ShoppingCart";
import { CartItem } from "@/lib/types";

const MobileBottomNav = styled(Box)(({ theme }) => ({
  position: "fixed",
  bottom: 0,
  left: 0,
  right: 0,
  background: "rgba(255, 255, 255, 0.1)",
  backdropFilter: "blur(10px)",
  borderTop: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1),
  zIndex: 999,
  justifyContent: "space-around",
  alignItems: "center",
  display: "flex",
  [theme.breakpoints.up("md")]: {
    display: "none",
  },
}));

const GlassNavbar = styled("nav")(({ theme }) => ({
  background: "rgba(255, 255, 255, 0.1)",
  backdropFilter: "blur(10px)",
  borderBottom: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1, 2),
  position: "fixed",
  top: 0,
  left: 0,
  right: 0,
  zIndex: 1000,
}));

const NavContainer = styled(Box)(({ theme }) => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  maxWidth: "1200px",
  margin: "0 auto",
  [theme.breakpoints.down("md")]: {
    flexDirection: "row",
    alignItems: "center",
    gap: 1,
  },
}));

export default function Navbar() {
  const theme = useTheme();
  const pathname = usePathname();
  const {
    user,
    credits,
    gamification,
    coupons,
    setCredits,
    setGamification,
    logout,
  } = useAuth();
  const [settingsAnchorEl, setSettingsAnchorEl] = useState<null | HTMLElement>(
    null
  );
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [disableCredits, setDisableCredits] = useState(false);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const [enablePoints, setEnablePoints] = useState(true);
  const [enableCoupons, setEnableCoupons] = useState(true);
  const [enableBadges, setEnableBadges] = useState(true);
  const [enablePaymentMethods, setEnablePaymentMethods] = useState(true);
  const [anonUsername, setAnonUsername] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [newBadge, setNewBadge] = useState<string | null>(null);
  const [cartItemsCount, setCartItemsCount] = useState(0);

  useEffect(() => {
    const fetchCartCount = async () => {
      const { data } = await fetchAPI<CartItem[]>("/v1/marketplace/cart");
      setCartItemsCount(data?.length || 0);
    };
    fetchCartCount();
  }, []);

  useEffect(() => {
    const storedAnonUsername = localStorage.getItem("anonUsername");
    setAnonUsername(storedAnonUsername);
  }, []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const [
          disableCreditsRes,
          enableRegistrationRes,
          enablePointsRes,
          enableCouponsRes,
          enableBadgesRes,
          enablePaymentMethodsRes,
        ] = await Promise.all([
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_coupons"),
          fetchAPI("/v1/settings/enable_badges"),
          fetchAPI("/v1/settings/enable_payment_methods"),
        ]);
        setDisableCredits(
          disableCreditsRes.data === "true" || disableCreditsRes.data === true
        );
        setEnableRegistration(
          enableRegistrationRes.data === "true" ||
            enableRegistrationRes.data === true
        );
        setEnablePoints(
          enablePointsRes.data === "true" || enablePointsRes.data === true
        );
        setEnableCoupons(
          enableCouponsRes.data === "true" || enableCouponsRes.data === true
        );
        setEnableBadges(
          enableBadgesRes.data === "true" || enableBadgesRes.data === true
        );
        setEnablePaymentMethods(
          enablePaymentMethodsRes.data === "true" ||
            enablePaymentMethodsRes.data === true
        );
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
      }
    };
    fetchSettings();
  }, []);

  interface InfoData {
    credits: number;
  }

  useEffect(() => {
    if (!enablePoints && !enableBadges) return;

    const interval = setInterval(async () => {
      try {
        const { data: infoData } = await fetchAPI<InfoData>("/whoami");
        if (infoData) {
          setCredits(infoData.credits);
        }

        const { data: gamificationData } = await fetchAPI(
          "/v1/gamification/me"
        );
        if (gamificationData && Array.isArray(gamificationData)) {
          const totalPoints = enablePoints
            ? gamificationData.reduce((sum, g) => sum + g.points, 0)
            : 0;
          const badges = enableBadges
            ? gamificationData.map((g) => g.badge).filter((b) => b !== null)
            : [];

          const previousBadges = JSON.parse(
            localStorage.getItem("badges") || "[]"
          );
          const currentBadgeIds = badges.map((b) => b.id);
          const newBadges = currentBadgeIds.filter(
            (id) => !previousBadges.includes(id)
          );
          if (newBadges.length > 0 && enableBadges) {
            const badge = badges.find((b) => b.id === newBadges[0]);
            setNewBadge(badge?.name || "Nuevo badge");
            setSnackbarOpen(true);
            localStorage.setItem("badges", JSON.stringify(currentBadgeIds));
          }

          setGamification({ points: totalPoints, badges });
        }
      } catch (err) {
        console.error("Error al actualizar datos:", err);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [setCredits, setGamification, enablePoints, enableBadges]);

  const handleSettingsMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchorEl(event.currentTarget);
  };

  const handleSettingsMenuClose = () => {
    setSettingsAnchorEl(null);
  };

  const handleDrawerOpen = () => {
    setDrawerOpen(true);
  };

  const handleDrawerClose = () => {
    setDrawerOpen(false);
  };

  const availableCoupons = (coupons || []).filter(
    (coupon) =>
      coupon &&
      coupon.status === "active" &&
      (!coupon.expires_at || new Date(coupon.expires_at) > new Date())
  ).length;

  return (
    <>
      <GlassNavbar>
        <NavContainer>
          {/* Sección izquierda: Logo y menú hamburguesa */}
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            <IconButton
              onClick={handleDrawerOpen}
              sx={{ display: { xs: "block", md: "none" } }}
            >
              <MenuIcon />
            </IconButton>

            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <Link href="/" passHref>
                <Box
                  sx={{
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                    cursor: "pointer",
                  }}
                >
                  <Image
                    src="/logo.png"
                    alt="Logo Neptuno"
                    width={40}
                    height={40}
                    style={{ borderRadius: "50%" }}
                  />
                  <Typography
                    variant="h6"
                    component="span"
                    className="app-logo"
                    sx={{
                      fontWeight: "bold",
                      display: {
                        xs: "none",
                        md: "block",
                      },
                    }}
                  >
                    Neptuno
                  </Typography>
                </Box>
              </Link>
            </Box>
          </Box>

          {/* Sección derecha: Elementos específicos para móvil */}
          <Box
            sx={{
              display: { xs: "flex", md: "none" },
              alignItems: "center",
              gap: 1,
            }}
          >
            {/* Mensajes */}
            <Tooltip title="Mensajes (próximamente)">
              <IconButton sx={{ color: theme.palette.text.disabled }}>
                <Mail />
              </IconButton>
            </Tooltip>

            {/* Favoritos */}
            <Tooltip title="Likes (próximamente)">
              <IconButton sx={{ color: theme.palette.text.disabled }}>
                <Favorite />
              </IconButton>
            </Tooltip>

            {/* Marketplace */}
            <Tooltip title="Marketplace">
              <Link href="/checkout" passHref>
              <IconButton sx={{ color: theme.palette.text.disabled }}>
                <ShoppingCartIcon />
              </IconButton>
              </Link>
            </Tooltip>

            {/* Settings solo para admin */}
            {user?.rol === "admin" && (
              <IconButton
                onClick={handleSettingsMenuOpen}
                sx={{ color: "inherit" }}
              >
                <Settings />
              </IconButton>
            )}
          </Box>

          {/* Sección derecha: Versión desktop */}
          <Box
            sx={{
              display: { xs: "none", md: "flex" },
              alignItems: "center",
              gap: 2,
            }}
          >
            {/* Enlaces desktop */}
            <Box sx={{ display: "flex", gap: 2, mr: 1 }}>
              <Button
                component={Link}
                href="/ejemplos"
                className={pathname === "/ejemplos" ? "active-link" : ""}
              >
                Ejemplos
              </Button>
              <Button
                component={Link}
                href="/rankings"
                className={pathname === "/rankings" ? "active-link" : ""}
              >
                Rankings
              </Button>
            </Box>

            {/* Iconos de notificaciones - Orden modificado */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {/* Nuevo orden: corazón primero */}
              <Tooltip title="Likes (próximamente)">
                <IconButton sx={{ color: theme.palette.text.disabled }}>
                  <Favorite />
                </IconButton>
              </Tooltip>

              {/* Mensaje segundo */}
              <Tooltip title="Mensajes (próximamente)">
                <IconButton sx={{ color: theme.palette.text.disabled }}>
                  <Mail />
                </IconButton>
              </Tooltip>

              <Link href="/checkout" passHref>
                <IconButton className="notification-icon">
                  <Badge badgeContent={cartItemsCount} color="secondary">
                    <ShoppingCartIcon />
                  </Badge>
                </IconButton>
              </Link>

              {/* Créditos tercero */}
              {!disableCredits && credits > 0 && (
                <Link href="/user/transactions" passHref>
                  <IconButton className="notification-icon">
                    <MonetizationOn />
                    <span className="notification-badge credits-badge">
                      {credits}
                    </span>
                  </IconButton>
                </Link>
              )}

              {enableCoupons && (
                <Link href="/user/coupon" passHref>
                  <Tooltip title="Tus cupones">
                    <IconButton className="notification-icon">
                      <Badge badgeContent={availableCoupons} color="secondary">
                        <LocalActivity />
                      </Badge>
                    </IconButton>
                  </Tooltip>
                </Link>
              )}

              {gamification && (
                <>
                  {enablePoints && (
                    <Link href="/user/points" passHref>
                      <IconButton className="notification-icon">
                        <Star />
                        <span className="notification-badge points-badge">
                          {gamification.points}
                        </span>
                      </IconButton>
                    </Link>
                  )}
                  {enableBadges && (
                    <Link href="/user/badges" passHref>
                      <IconButton className="notification-icon">
                        <EmojiEvents />
                        <span className="notification-badge badges-badge">
                          {gamification.badges.length}
                        </span>
                      </IconButton>
                    </Link>
                  )}
                </>
              )}
            </Box>

            {/* Menú admin y usuario */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {user?.rol === "admin" && (
                <>
                  <IconButton
                    onClick={handleSettingsMenuOpen}
                    sx={{ color: "inherit" }}
                  >
                    <Settings />
                  </IconButton>
                  <Menu
                    anchorEl={settingsAnchorEl}
                    open={Boolean(settingsAnchorEl)}
                    onClose={handleSettingsMenuClose}
                    PaperProps={{
                      sx: {
                        background: "rgba(255, 255, 255, 0.9)",
                        backdropFilter: "blur(10px)",
                        borderRadius: "12px",
                        mt: 1,
                        minWidth: "200px",
                      },
                    }}
                  >
                    <MenuItem
                      onClick={handleSettingsMenuClose}
                      component={Link}
                      href="/admin/dashboard"
                    >
                      <Dashboard sx={{ mr: 1 }} /> Config
                    </MenuItem>
                    <MenuItem
                      onClick={handleSettingsMenuClose}
                      component={Link}
                      href="/admin/gamification"
                    >
                      <EmojiEvents sx={{ mr: 1 }} /> Gamification
                    </MenuItem>
                    <MenuItem
                      onClick={handleSettingsMenuClose}
                      component={Link}
                      href="/admin/revenues"
                    >
                      <MonetizationOn sx={{ mr: 1 }} /> Revenues
                    </MenuItem>
                    <MenuItem
                      onClick={handleSettingsMenuClose}
                      component={Link}
                      href="/admin/registry"
                    >
                      <ListAlt sx={{ mr: 1 }} /> Registros
                    </MenuItem>
                    <MenuItem
                      onClick={handleSettingsMenuClose}
                      component={Link}
                      href="/admin/users"
                    >
                      <People sx={{ mr: 1 }} /> Usuarios
                    </MenuItem>
                  </Menu>
                </>
              )}

              {user ? (
                <Tooltip title={user.username} arrow>
                  <IconButton
                    component={Link}
                    href="/user/dashboard"
                    className="user-avatar"
                  >
                    <Avatar
                      sx={{
                        bgcolor: theme.palette.primary.main,
                        width: 40,
                        height: 40,
                        fontSize: "1rem",
                      }}
                    >
                      {user.username[0].toUpperCase()}
                    </Avatar>
                  </IconButton>
                </Tooltip>
              ) : (
                <Tooltip
                  title={anonUsername ? "Iniciar sesión" : "Registrarse"}
                  arrow
                >
                  <Box sx={{ position: "relative" }}>
                    <IconButton
                      component={Link}
                      href={
                        anonUsername
                          ? "/user/auth/#login"
                          : "/user/auth/#register"
                      }
                      className="user-avatar"
                    >
                      <Avatar
                        sx={{
                          bgcolor: theme.palette.grey[500],
                          width: 40,
                          height: 40,
                          color: theme.palette.common.white,
                        }}
                      >
                        {anonUsername ? <Person /> : <Key />}
                      </Avatar>
                    </IconButton>
                    {anonUsername && (
                      <Box
                        sx={{
                          position: "absolute",
                          top: 0,
                          right: 0,
                          backgroundColor: theme.palette.secondary.main,
                          borderRadius: "50%",
                          width: 20,
                          height: 20,
                          display: "flex",
                          alignItems: "center",
                          justifyContent: "center",
                          border: `2px solid ${theme.palette.background.paper}`,
                        }}
                      >
                        <Key
                          sx={{
                            fontSize: 12,
                            color: theme.palette.common.white,
                          }}
                        />
                      </Box>
                    )}
                  </Box>
                </Tooltip>
              )}
            </Box>
          </Box>

          {/* Menú hamburguesa */}
          <Drawer anchor="left" open={drawerOpen} onClose={handleDrawerClose}>
            <List>
              <Box
                sx={{
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  p: 2,
                  borderBottom: `1px solid ${theme.palette.divider}`,
                }}
              >
                <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                  <Image
                    src="/logo.png"
                    alt="Logo Neptuno"
                    width={40}
                    height={40}
                    style={{ borderRadius: "50%" }}
                  />
                  <Typography
                    variant="h6"
                    sx={{
                      fontWeight: "bold",
                      background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                      WebkitBackgroundClip: "text",
                      WebkitTextFillColor: "transparent",
                      display: "inline-block",
                    }}
                  >
                    Neptuno
                  </Typography>
                </Box>
                <IconButton onClick={handleDrawerClose}>
                  <Close />
                </IconButton>
              </Box>

              <ListItem component={Link} href="/">
                <ListItemIcon>
                  <Home />
                </ListItemIcon>
                <ListItemText primary="Inicio" />
              </ListItem>
              <ListItem component={Link} href="/ejemplos">
                <ListItemIcon>
                  <School />
                </ListItemIcon>
                <ListItemText primary="Ejemplos" />
              </ListItem>
              <ListItem component={Link} href="/rankings">
                <ListItemIcon>
                  <Leaderboard />
                </ListItemIcon>
                <ListItemText primary="Rankings" />
              </ListItem>
              <ListItem component={Link} href="/about/contact">
                <ListItemIcon>
                  <ContactMail />
                </ListItemIcon>
                <ListItemText primary="Contacto" />
              </ListItem>

              {user?.rol === "admin" && (
                <>
                  <ListItem component={Link} href="/admin/dashboard">
                    <ListItemIcon>
                      <Dashboard />
                    </ListItemIcon>
                    <ListItemText primary="Dashboard" />
                  </ListItem>
                  <ListItem component={Link} href="/admin/registry">
                    <ListItemIcon>
                      <ListAlt />
                    </ListItemIcon>
                    <ListItemText primary="Registros" />
                  </ListItem>
                  <ListItem component={Link} href="/admin/users">
                    <ListItemIcon>
                      <People />
                    </ListItemIcon>
                    <ListItemText primary="Usuarios" />
                  </ListItem>
                </>
              )}
              {user ? (
                <ListItem component={Link} href="/user/dashboard">
                  <ListItemIcon>
                    <Person />
                  </ListItemIcon>
                  <ListItemText primary={user.username} />
                </ListItem>
              ) : (
                <>
                  <ListItem component={Link} href="/user/auth/#login">
                    <ListItemIcon>
                      <Login />
                    </ListItemIcon>
                    <ListItemText primary="Iniciar Sesión" />
                  </ListItem>
                  {enableRegistration && (
                    <ListItem component={Link} href="/user/auth/#register">
                      <ListItemIcon>
                        <PersonAdd />
                      </ListItemIcon>
                      <ListItemText primary="Registrarse" />
                    </ListItem>
                  )}
                </>
              )}
            </List>
          </Drawer>
        </NavContainer>

        <Snackbar
          open={snackbarOpen}
          autoHideDuration={6000}
          onClose={() => setSnackbarOpen(false)}
        >
          <Alert
            onClose={() => setSnackbarOpen(false)}
            severity="success"
            sx={{ width: "100%" }}
          >
            ¡Felicidades! Has obtenido el badge: {newBadge}
          </Alert>
        </Snackbar>
      </GlassNavbar>

      <MobileBottomNav>
        {!disableCredits && credits > 0 && (
          <Link href="/user/transactions" passHref>
            <IconButton className="notification-icon">
              <MonetizationOn />
              <span className="notification-badge credits-badge">
                {credits}
              </span>
            </IconButton>
          </Link>
        )}

        {enableCoupons && (
          <Link href="/user/coupon" passHref>
            <Tooltip title="Tus cupones">
              <IconButton className="notification-icon">
                <Badge badgeContent={availableCoupons} color="secondary">
                  <LocalActivity />
                </Badge>
              </IconButton>
            </Tooltip>
          </Link>
        )}

        {user ? (
          <Tooltip title={user.username} arrow>
            <IconButton component={Link} href="/user/dashboard">
              <Avatar
                sx={{
                  bgcolor: theme.palette.primary.main,
                  width: 32,
                  height: 32,
                  fontSize: "0.9rem",
                }}
              >
                {user.username[0].toUpperCase()}
              </Avatar>
            </IconButton>
          </Tooltip>
        ) : (
          <Tooltip
            title={anonUsername ? "Iniciar sesión" : "Registrarse"}
            arrow
          >
            <IconButton
              component={Link}
              href={anonUsername ? "/user/auth/#login" : "/user/auth/#register"}
            >
              <Avatar
                sx={{
                  bgcolor: theme.palette.grey[500],
                  width: 32,
                  height: 32,
                  color: theme.palette.common.white,
                }}
              >
                {anonUsername ? (
                  <Person fontSize="small" />
                ) : (
                  <Key fontSize="small" />
                )}
              </Avatar>
            </IconButton>
          </Tooltip>
        )}

        {/* Mostrar icono de puntos incluso cuando es 0 */}
        {enablePoints && gamification && (
          <Link href="/user/points" passHref>
            <IconButton className="notification-icon">
              <Star />
              <span className="notification-badge points-badge">
                {gamification.points || 0}
              </span>
            </IconButton>
          </Link>
        )}

        {gamification?.badges && enableBadges && (
          <Link href="/user/badges" passHref>
            <IconButton className="notification-icon">
              <EmojiEvents />
              <span className="notification-badge badges-badge">
                {gamification.badges.length}
              </span>
            </IconButton>
          </Link>
        )}
      </MobileBottomNav>
    </>
  );
}


otros errores:


Console Error

Received NaN for the `value` attribute. If this is expected, cast the value to a string.

src/components/admin/MarketplaceManagement.tsx (94:9) @ MarketplaceManagement

  92 |         <TextField label="Nombre" value={newProduct.name} onChange={(e) => setNewProduct({ ...newProduct, name: e.target.value })} />
  93 |         <TextField label="Descripción" value={newProduct.description} onChange={(e) => setNewProduct({ ...newProduct, description: e.target.value })} />
> 94 |         <TextField label="Precio" type="number" value={newProduct.price} onChange={(e) => setNewProduct({ ...newProduct, price: parseFloat(e.target.value) })} />
     |         ^
  95 |         <TextField label="Categoría ID" type="number" value={newProduct.category_id} onChange={(e) => setNewProduct({ ...newProduct, category_id: parseInt(e.target.value) })} />
  96 |         <FormControlLabel
  97 |           control={<Switch checked={newProduct.is_digital} onChange={(e) => setNewProduct({ ...newProduct, is_digital: e.target.checked })} />}

Call Stack 137
Show 134 ignore-listed frame(s)
input
unknown (0:0)
MarketplaceManagement
src/components/admin/MarketplaceManagement.tsx (94:9)
ConfigurePage
src/app/admin/dashboard/page.tsx (2631:15)

ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1964, in _exec_single_context
    self.dialect.do_execute(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py", line 942, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: table products has no column named subscription_duration

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 214, in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/concurrency.py", line 37, in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/to_thread.py", line 56, in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 2470, in run_sync_in_worker_thread
    return await future
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 967, in run
    result = context.run(func, *args)
  File "/home/vinxenxo/neptuno/neptuno/backend/api/v1/marketplace/marketplace.py", line 49, in create_product_route
    return create_product(db, product)
  File "/home/vinxenxo/neptuno/neptuno/backend/services/marketplace_service.py", line 38, in create_product
    db.commit()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 2032, in commit
    trans.commit(_to_root=True)
  File "<string>", line 2, in commit
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py", line 139, in _go
    ret_value = fn(self, *arg, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 1313, in commit
    self._prepare_impl()
  File "<string>", line 2, in _prepare_impl
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py", line 139, in _go
    ret_value = fn(self, *arg, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 1288, in _prepare_impl
    self.session.flush()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4353, in flush
    self._flush(objects)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4488, in _flush
    with util.safe_reraise():
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 146, in __exit__
    raise exc_value.with_traceback(exc_tb)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4449, in _flush
    flush_context.execute()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py", line 466, in execute
    rec.execute(self)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py", line 642, in execute
    util.preloaded.orm_persistence.save_obj(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py", line 93, in save_obj
    _emit_insert_statements(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py", line 1233, in _emit_insert_statements
    result = connection.execute(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1416, in execute
    return meth(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/elements.py", line 523, in _execute_on_connection
    return connection._execute_clauseelement(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1638, in _execute_clauseelement
    ret = self._execute_context(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1843, in _execute_context
    return self._exec_single_context(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1983, in _exec_single_context
    self._handle_dbapi_exception(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 2352, in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1964, in _exec_single_context
    self.dialect.do_execute(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py", line 942, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) table products has no column named subscription_duration
[SQL: INSERT INTO products (name, description, price, category_id, is_digital, file_path, subscription_duration) VALUES (?, ?, ?, ?, ?, ?, ?)]
[parameters: ('asdfasdfasdasdfasdf', 'asdfasdf', 12.0, 1, 0, None, None)]
(Background on this error at: https://sqlalche.me/e/20/e3q8)

INFO:     127.0.0.1:35780 - "OPTIONS /v1/marketplace/orders HTTP/1.1" 200 OK
2025-04-28 01:31:24,333 - NeptunO - INFO - Procesando solicitud: token=True, session_id=None, ip=127.0.0.1
2025-04-28 01:31:24,398 - NeptunO - INFO - Usuario registrado ID 1 autenticado desde IP 127.0.0.1
2025-04-28 01:31:24,400 - NeptunO - CRITICAL - Error inesperado en POST http://127.0.0.1:8000/v1/marketplace/orders: Foreign key associated with column 'orders.user_id' could not find table 'users' with which to generate a foreign key to target column 'id'
INFO:     127.0.0.1:35780 - "POST /v1/marketplace/orders HTTP/1.1" 500 Internal Server Error
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 214, in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/concurrency.py", line 37, in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/to_thread.py", line 56, in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 2470, in run_sync_in_worker_thread
    return await future
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 967, in run
    result = context.run(func, *args)
  File "/home/vinxenxo/neptuno/neptuno/backend/api/v1/marketplace/marketplace.py", line 86, in create_order_route
    return create_order(db, user_id, session_id, order)
  File "/home/vinxenxo/neptuno/neptuno/backend/services/order_service.py", line 19, in create_order
    db.commit()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 2032, in commit
    trans.commit(_to_root=True)
  File "<string>", line 2, in commit
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py", line 139, in _go
    ret_value = fn(self, *arg, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 1313, in commit
    self._prepare_impl()
  File "<string>", line 2, in _prepare_impl
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py", line 139, in _go
    ret_value = fn(self, *arg, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 1288, in _prepare_impl
    self.session.flush()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4353, in flush
    self._flush(objects)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4488, in _flush
    with util.safe_reraise():
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 146, in __exit__
    raise exc_value.with_traceback(exc_tb)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4449, in _flush
    flush_context.execute()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py", line 466, in execute
    rec.execute(self)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py", line 642, in execute
    util.preloaded.orm_persistence.save_obj(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py", line 76, in save_obj
    for table, mapper in base_mapper._sorted_tables.items():
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 1257, in __get__
    obj.__dict__[self.__name__] = result = self.fget(obj)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/mapper.py", line 4060, in _sorted_tables
    sorted_ = sql_util.sort_tables(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1312, in sort_tables
    for (t, fkcs) in sort_tables_and_constraints(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1382, in sort_tables_and_constraints
    filtered = filter_fn(fkc)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1302, in _skip_fn
    if fixed_skip_fn(fk):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/mapper.py", line 4043, in skip
    dep = table_to_mapper.get(fk.column.table)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 1145, in __get__
    obj.__dict__[self.__name__] = result = self.fget(obj)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 3191, in column
    return self._resolve_column()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 3214, in _resolve_column
    raise exc.NoReferencedTableError(
sqlalchemy.exc.NoReferencedTableError: Foreign key associated with column 'orders.user_id' could not find table 'users' with which to generate a foreign key to target column 'id'

INFO:     127.0.0.1:53436 - "OPTIONS /v1/marketplace/cart HTTP/1.1" 200 OK
2025-04-28 01:32:31,033 - NeptunO - INFO - Procesando solicitud: token=True, session_id=None, ip=127.0.0.1
2025-04-28 01:32:31,097 - NeptunO - INFO - Usuario registrado ID 1 autenticado desde IP 127.0.0.1
2025-04-28 01:32:31,099 - NeptunO - CRITICAL - Error inesperado en POST http://127.0.0.1:8000/v1/marketplace/cart: Foreign key associated with column 'cart_items.user_id' could not find table 'users' with which to generate a foreign key to target column 'id'
INFO:     127.0.0.1:53436 - "POST /v1/marketplace/cart HTTP/1.1" 500 Internal Server Error
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 214, in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/concurrency.py", line 37, in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/to_thread.py", line 56, in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 2470, in run_sync_in_worker_thread
    return await future
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 967, in run
    result = context.run(func, *args)
  File "/home/vinxenxo/neptuno/neptuno/backend/api/v1/marketplace/marketplace.py", line 73, in add_to_cart_route
    return add_to_cart(db, user_id, session_id, cart_item)
  File "/home/vinxenxo/neptuno/neptuno/backend/services/cart_service.py", line 10, in add_to_cart
    db.commit()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 2032, in commit
    trans.commit(_to_root=True)
  File "<string>", line 2, in commit
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py", line 139, in _go
    ret_value = fn(self, *arg, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 1313, in commit
    self._prepare_impl()
  File "<string>", line 2, in _prepare_impl
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py", line 139, in _go
    ret_value = fn(self, *arg, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 1288, in _prepare_impl
    self.session.flush()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4353, in flush
    self._flush(objects)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4488, in _flush
    with util.safe_reraise():
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 146, in __exit__
    raise exc_value.with_traceback(exc_tb)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/session.py", line 4449, in _flush
    flush_context.execute()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py", line 466, in execute
    rec.execute(self)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py", line 642, in execute
    util.preloaded.orm_persistence.save_obj(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py", line 76, in save_obj
    for table, mapper in base_mapper._sorted_tables.items():
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 1257, in __get__
    obj.__dict__[self.__name__] = result = self.fget(obj)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/mapper.py", line 4060, in _sorted_tables
    sorted_ = sql_util.sort_tables(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1312, in sort_tables
    for (t, fkcs) in sort_tables_and_constraints(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1382, in sort_tables_and_constraints
    filtered = filter_fn(fkc)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 1302, in _skip_fn
    if fixed_skip_fn(fk):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/orm/mapper.py", line 4043, in skip
    dep = table_to_mapper.get(fk.column.table)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py", line 1145, in __get__
    obj.__dict__[self.__name__] = result = self.fget(obj)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 3191, in column
    return self._resolve_column()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/schema.py", line 3214, in _resolve_column
    raise exc.NoReferencedTableError(
sqlalchemy.exc.NoReferencedTableError: Foreign key associated with column 'cart_items.user_id' could not find table 'users' with which to generate a foreign key to target column 'id'
2025-04-28 01:32:42,303 - NeptunO - INFO - Proc

Recuerda que debemos manejar añadir al carrito para anonimos y registrados, y que debe ser una solucion sencilla que afecte lo menos a la logica,
en tu versión anterior funcionaba 

te paso los archivos necesarios o que has implantado para su revisión


// frontend/src/lib/auth/context.tsx
// Contexto de autenticación y estado global del usuario

"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge, Coupon } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // Añadimos gamificación al contexto
  coupons: Coupon[];
  setCredits: (credits: number) => void; // Añadido
  setCoupons: (coupons: Coupon[]) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  setGamification: (gamification: Gamification) => void; // Añadido
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}



const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(10); // Valor por defecto para anónimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificación
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const [coupons, setCoupons] = useState<Coupon[]>([]);


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<any>("/whoami"); // Endpoint para obtener info del usuario
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
          } else {
            setUser(null);
            setCredits(0);
          }

          // Obtener datos de gamificación
          const gamificationRes = await fetchAPI<any[]>("/v1/gamification/me");
          if (gamificationRes.data) {
            const totalPoints = gamificationRes.data.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationRes.data.map(g => g.badge).filter(Boolean) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }

          // Obtener cupones del usuario
          const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/me");
          setCoupons(couponsRes.data || []);
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        setCoupons([]);
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesión
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesión
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operación
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits, gamification, coupons, setCoupons, setGamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// frontend/src/lib/payments/example.tsx
// Ejemplo de integración de pagos con PaymentManager y Stripe
import { PaymentManager } from "@/lib/payments/manager";
import { StripeProvider } from "@/lib/payments/stripe";

const paymentManager = new PaymentManager();
paymentManager.registerProvider(new StripeProvider());

const handlePayment = async () => {
  const result = await paymentManager.processPayment("Stripe", 1000, "USD", "Compra de créditos");
  if (result.success) {
    console.log("Pago exitoso:", result.transactionId);
  } else {
    console.error("Error en el pago:", result.error);
  }
};

// frontend/src/lib/types.ts
// Tipos TypeScript para entidades y respuestas de la app

// src/lib/types.ts
export interface User {
  id: number;
  email: string;
  username: string;
  rol: string;
  activo: boolean;
  subscription: string;
  ciudad?: string;
  website?: string;
  credits: number;
  create_at: string; // ISO string (e.g., "2023-10-01T12:00:00Z")
  last_ip?: string;
  last_login: string;
  user_type: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}

export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  ciudad?: string;
  website?: string;
}

export interface UpdateProfileRequest {
  email?: string;
  username?: string;
  ciudad?: string;
  website?: string;
}

export interface PurchaseRequest {
  credits: number;
  payment_amount: number;
  payment_method?: string;
}

export interface PurchaseResponse {
  transaction_id: string;
  credits_added: number;
  new_balance: number;
}

export interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
  created_at: string; // ISO string
  updated_at: string; // ISO string
}

export interface HTTPValidationError {
  detail: ValidationError[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string; // ISO string
}

export interface Integration {
  user_id: number;
  id: number;
  name: string;
  webhook_url: string;
  event_type: string;
  active: boolean;
  created_at: string;
  last_triggered: string | null;
}

export interface SiteSetting {
  id: number;
  key: string;
  value: string;
  description?: string;
  tag?: string;
  updated_by?: number;
  updated_at: string; // ISO string
}

export interface FetchResponse<T> {
  data: T | null;
  error: string | HTTPValidationError | null;
  total_pages?: number;
}

// src/lib/types.ts
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string;
  gamification: UserGamificationResponse[]; // Actualizado para reflejar /whoami
}

export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[];
}

export interface GamificationEventCreate {
  event_type_id: number;
}

export interface GamificationEventResponse {
  id: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  timestamp: string; // ISO string
}

export interface UserGamificationResponse {
  points: number;
  badge_id?: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  event_type: EventType;
  badge?: Badge;
}
export interface RankingResponse {
  username: string;
  points: number;
  badges_count: number;
  user_type: string;
}

export interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}

export interface InfoResponse {
  credits: number;
  gamification: { points: number; badge: Badge | null }[];
}

export interface BadgeWithEventType extends Badge {
  event_type: EventType;
}

// src/lib/types.ts

// Nuevo tipo para cupones
export interface Coupon {
  id: number;
  name: string;
  description?: string;
  unique_identifier: string;
  issued_at: string; // ISO string
  expires_at?: string; // ISO string, opcional
  redeemed_at?: string; // ISO string, opcional
  active: boolean;
  status: "active" | "redeemed" | "expired" | "disabled";
  credits: number;
  user_id?: number; // Opcional, para usuarios registrados
  session_id?: string; // Opcional, para usuarios anónimos
  redeemed_by_user_id?: number; // Quién lo canjeó, si aplica
  redeemed_by_session_id?: string; // Quién lo canjeó (anónimo), si aplica
}

export interface CouponType {
  id: number;
  name: string;
  description?: string;
  credits: number;
  active: boolean;
}

export interface CouponActivity {
  id: number;
  coupon_type: string;
  unique_identifier: string;
  user_id?: number;
  session_id?: string;
  status: string;
  issued_at: string;
  redeemed_at?: string;
}

export interface AllowedOrigin {
  id: number;
  origin: string;
}
// frontend/src/lib/types.ts (actualización)
export interface Category {
  id: number;
  name: string;
  description?: string;
}

export interface Product {
  id: number;
  name: string;
  description?: string;
  price: number;
  category_id: number;
  is_digital: boolean;
  file_path?: string;
  subscription_duration?: number;
}

export interface CartItem {
  id: number;
  product_id: number;
  quantity: number;
  product: Product;
}

export interface OrderItem {
  id: number;
  product_id: number;
  quantity: number;
  price: number;
  product_name: string;
  is_digital: boolean;
  file_path?: string;
}

export interface Order {
  id: number;
  total_amount: number;
  status: string;
  created_at: string;
  items: OrderItem[];
}


// frontend/src/lib/payments/manager.ts
// this file manages the payment providers
import { PaymentProvider, PaymentResult } from "../payments";

export class PaymentManager {
  private providers: Record<string, PaymentProvider> = {};

  registerProvider(provider: PaymentProvider) {
    this.providers[provider.name] = provider;
  }

  async processPayment(providerName: string, amount: number, currency: string, description: string): Promise<PaymentResult> {
    const provider = this.providers[providerName];
    if (!provider) {
      return { success: false, error: `Proveedor ${providerName} no encontrado` };
    }
    return await provider.processPayment(amount, currency, description);
  }
}

import { PaymentProvider, PaymentResult } from "../payments";

export class StripeProvider implements PaymentProvider {
  name = "Stripe";

  async processPayment(amount: number, currency: string, description: string): Promise<PaymentResult> {
    // Placeholder: Integrar Stripe SDK en el futuro
    try {
      // const paymentIntent = await stripe.paymentIntents.create({...});
      return { success: true, transactionId: "stripe_txn_123" };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}


// frontend/src/lib/payments.ts
export interface PaymentProvider {
    name: string;
    processPayment(amount: number, currency: string, description: string): Promise<PaymentResult>;
  }
  
  export interface PaymentResult {
    success: boolean;
    transactionId?: string;
    error?: string;
  }

// frontend/src/lib/api.ts
// Cliente Axios y funciones para consumir la API

// src/lib/api.ts
import axios, { AxiosRequestConfig, AxiosResponse, AxiosError, AxiosInstance } from "axios";
import { useState, useEffect } from 'react';
import { HTTPValidationError, FetchResponse, RegisterRequest, TokenResponse, UpdateProfileRequest, User, ValidationError } from "./types";

// Extender AxiosRequestConfig para incluir _retry
interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  _retry?: boolean;
}

// Crear una instancia personalizada de Axios
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Variables para manejar el estado de refresco
let isRefreshing = false;
let failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

// Agregar el interceptor de solicitudes
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("accessToken");
  const sessionId = localStorage.getItem("session_id");
  if (token) {
    config.headers["Authorization"] = `Bearer ${token}`;
  } else if (sessionId) {
    config.headers["X-Session-ID"] = sessionId;
  }
  return config;
});

const logRequest = (method: string, url: string, status: number, data?: unknown) => {
  console.log(`[${method}] ${url} - Status: ${status}`, data ?? "");
};

const fetchAPI = async <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  contentType: string = "application/json"
): Promise<FetchResponse<T>> => {
  console.log(`Iniciando fetchAPI para ${endpoint}`);

  const config: CustomAxiosRequestConfig = {
    ...options,
    url: endpoint, // baseURL ya está configurado en la instancia
    headers: {
      "Content-Type": contentType,
      ...options.headers,
    },
    data: options.data,
  };

  // Convertir datos a formato x-www-form-urlencoded si es necesario
  if (contentType === "application/x-www-form-urlencoded" && config.data) {
    const formData = new URLSearchParams();
    Object.entries(config.data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });
    config.data = formData;
  }

  const normalizeResponse = (
    response: AxiosResponse<T> | undefined,
    error: unknown
  ): FetchResponse<T> => {
    if (response && response.status >= 200 && response.status < 300) {
      return { data: response.data, error: null };
    }

    if (axios.isAxiosError(error)) {
      const errorData = error.response?.data;
      if (errorData && errorData.detail) {
        if (typeof errorData.detail === "string") {
          return { data: null, error: errorData.detail };
        } else if (Array.isArray(errorData.detail)) {
          const messages = errorData.detail
            .map((err: ValidationError) => err.msg)
            .join(", ");
          return { data: null, error: messages };
        }
      }
    }

    return { data: null, error: "Error desconocido" };
  };

  try {
    const response: AxiosResponse<T> = await api(config); // Usar la instancia 'api'
    logRequest(config.method || "GET", config.url!, response.status, response.data);

    if (response.data && (response.data as any).session_id) {
      localStorage.setItem("session_id", (response.data as any).session_id);
    }

    return normalizeResponse(response, null);
  } catch (err: unknown) {
    const axiosError = err as AxiosError;
    logRequest(
      config.method || "GET",
      config.url!,
      axiosError.response?.status || 500,
      axiosError.response?.data
    );

    if (axiosError.response?.status === 401 && !config._retry) {
      const originalRequest: CustomAxiosRequestConfig = config;
      originalRequest._retry = true;

      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");

      if (accessToken && refreshToken) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token) => {
                originalRequest.headers.Authorization = `Bearer ${token}`;
                api(originalRequest)
                  .then(response => resolve(normalizeResponse(response, null)))
                  .catch(error => reject(normalizeResponse(undefined, error)));
              },
              reject: (error) => reject(normalizeResponse(undefined, error)),
            });
          });
        }

        isRefreshing = true;

        try {
          console.log("Intentando refrescar token de acceso");
          const refreshResponse = await api.post<TokenResponse>(
            "/v1/auth/refresh",
            { refresh_token: refreshToken },
            {
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`,
              },
            }
          );

          localStorage.setItem("accessToken", refreshResponse.data.access_token);
          localStorage.setItem("refreshToken", refreshResponse.data.refresh_token);

          originalRequest.headers.Authorization = `Bearer ${refreshResponse.data.access_token}`;
          processQueue(null, refreshResponse.data.access_token);

          const retryResponse = await api(originalRequest);
          return normalizeResponse(retryResponse, null);
        } catch (refreshError) {
          console.error("Error al refrescar token:", refreshError);
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          localStorage.removeItem("session_id");
          processQueue(refreshError, null);
          window.location.href = "/user/auth/#login";
          return normalizeResponse(undefined, {
            message: "Sesión expirada, por favor inicia sesión nuevamente",
          });
        } finally {
          isRefreshing = false;
        }
      } else {
        return normalizeResponse(undefined, { message: "No autorizado" });
      }
    }

    return normalizeResponse(undefined, err);
  }
};

// Custom hook to fetch data
export const useFetchData = <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  dependencies: any[] = []
): { data: T | null; loading: boolean; error: string | null } => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetchAPI<T>(endpoint, options);
        if (response.error) {
          setError(typeof response.error === 'string' ? response.error : 'Error desconocido');
        } else {
          setData(response.data);
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error desconocido');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [endpoint, options, dependencies]); // Asegurar que la lista de dependencias sea un array literal y agregar endpoint y options como dependencias

  return { data, loading, error };
};

// Funciones específicas de la API
export const getAllUsers = async (
  page: number = 1,
  limit: number = 10
): Promise<FetchResponse<{
  data: User[],
  total_items: number,
  total_pages: number,
  current_page: number
}>> => {
  return fetchAPI(`/v1/users/admin/users?page=${page}&limit=${limit}`, {
    method: "GET"
  });
};

export const getUserById = async (
  userId: number
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "GET"
  });
};

export const updateUser = async (
  userId: number,
  data: UpdateProfileRequest
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "PUT",
    data
  });
};

export const deleteUser = async (
  userId: number
): Promise<FetchResponse<void>> => {
  return fetchAPI<void>(`/v1/users/${userId}`, {
    method: "DELETE"
  });
};

export const createUser = async (
  data: RegisterRequest
): Promise<FetchResponse<TokenResponse>> => {
  return fetchAPI<TokenResponse>("/v1/auth/register", {
    method: "POST",
    data
  });
};

export default fetchAPI;

// frontend/src/hooks/useNotifications.tsx
// Custom hook para manejar notificaciones en la aplicación.
// Este hook utiliza Material-UI y Framer Motion para mostrar notificaciones de manera elegante.
// El hook devuelve una función para mostrar notificaciones y un componente para renderizarlas.
import { useState } from 'react';
import { Snackbar, Alert } from '@mui/material';
import { motion, AnimatePresence } from 'framer-motion';

interface Notification {
  message: string;
  severity: 'success' | 'error' | 'warning' | 'info';
}

export function useNotifications() {
  const [notification, setNotification] = useState<Notification | null>(null);

  const showNotification = (message: string, severity: Notification['severity']) => {
    setNotification({ message, severity });
  };

  const clearNotification = () => {
    setNotification(null);
  };

  const NotificationComponent = () => (
    <AnimatePresence>
      {notification && (
        <Snackbar
          open
          autoHideDuration={3000}
          onClose={clearNotification}
          anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
        >
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 20 }}
          >
            <Alert
              severity={notification.severity}
              onClose={clearNotification}
              sx={{ boxShadow: 6, borderRadius: '12px' }}
            >
              {notification.message}
            </Alert>
          </motion.div>
        </Snackbar>
      )}
    </AnimatePresence>
  );

  return { showNotification, NotificationComponent };
}

// frontend/src/hooks/useFetchData.ts
// frontend/src/hooks/useFetchData.ts
// Custom hook para realizar peticiones HTTP y manejar el estado de carga, error y datos.
import { useState, useEffect } from 'react';

interface FetchDataResult<T> {
  data: T | null;
  error: string | null;
  loading: boolean;
}

export function useFetchData<T>(url: string, dependencies: any[] = []): FetchDataResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Error: ${response.statusText}`);
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url, dependencies]);

  return { data, error, loading };
}

// from: frontend/src/components/ui/FeatureDisabled.tsx
// This component handles the display of a feature based on its enabled state.
// It shows a loading spinner while checking the state and displays a message if the feature is disabled.
// If the feature is enabled, it renders the children components passed to it.
// It uses Material-UI for styling and layout.
// The component is designed to be reusable and can be used in various parts of the application where feature state handling is required.
import React, { ReactNode } from 'react';
import { Box, Typography } from '@mui/material';

interface FeatureDisabledProps {
  message: string;
  isEnabled: boolean | null;
  children?: ReactNode;
}

const FeatureDisabled: React.FC<FeatureDisabledProps> = ({ message, isEnabled, children }) => {
  if (isEnabled === null) return null;

  if (!isEnabled) {
    return (
      <Box
        sx={{
          minHeight: '100vh',
          background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          p: 4,
        }}
      >
        <Typography variant="h6" color="text.secondary">
          {message}
        </Typography>
      </Box>
    );
  }

  return <>{children}</>;
};

export default FeatureDisabled;

// frontend/src/components/admin/MarketplaceManagement.tsx
import { useState, useEffect } from "react";
import fetchAPI from "@/lib/api";
import { Category, Product } from "@/lib/types";
import {
  Box, Typography, Button, TextField, Table, TableBody, TableCell, TableHead, TableRow,
  IconButton, Switch, FormControlLabel
} from "@mui/material";
import { AddCircle, Delete, Edit } from "@mui/icons-material";

export default function MarketplaceManagement() {
  const [categories, setCategories] = useState<Category[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [newCategory, setNewCategory] = useState({ name: "", description: "" });
  const [newProduct, setNewProduct] = useState({
    name: "", description: "", price: 0, category_id: 0,
    is_digital: false, file_path: "", subscription_duration: 0
  });

  useEffect(() => {
    const fetchData = async () => {
      const { data: catData } = await fetchAPI<Category[]>("/v1/marketplace/categories");
      setCategories(catData || []);
      const { data: prodData } = await fetchAPI<Product[]>("/v1/marketplace/products");
      setProducts(prodData || []);
    };
    fetchData();
  }, []);

  const handleAddCategory = async () => {
    const { data } = await fetchAPI<Category>("/v1/marketplace/categories", { method: "POST", data: newCategory });
    if (data) {
      setCategories([...categories, data]);
      setNewCategory({ name: "", description: "" });
    }
  };

  const handleDeleteCategory = async (id: number) => {
    await fetchAPI(`/v1/marketplace/categories/${id}`, { method: "DELETE" });
    setCategories(categories.filter(cat => cat.id !== id));
  };

  const handleAddProduct = async () => {
    const productData = {
      ...newProduct,
      file_path: newProduct.is_digital ? newProduct.file_path : undefined,
      subscription_duration: newProduct.subscription_duration || undefined
    };
    const { data } = await fetchAPI<Product>("/v1/marketplace/products", { method: "POST", data: productData });
    if (data) {
      setProducts([...products, data]);
      setNewProduct({ name: "", description: "", price: 0, category_id: 0, is_digital: false, file_path: "", subscription_duration: 0 });
    }
  };

  const handleDeleteProduct = async (id: number) => {
    await fetchAPI(`/v1/marketplace/products/${id}`, { method: "DELETE" });
    setProducts(products.filter(prod => prod.id !== id));
  };

  return (
    <Box>
      <Typography variant="h6">Gestión de Categorías</Typography>
      <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
        <TextField label="Nombre" value={newCategory.name} onChange={(e) => setNewCategory({ ...newCategory, name: e.target.value })} />
        <TextField label="Descripción" value={newCategory.description} onChange={(e) => setNewCategory({ ...newCategory, description: e.target.value })} />
        <Button variant="contained" onClick={handleAddCategory} startIcon={<AddCircle />}>Añadir Categoría</Button>
      </Box>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Nombre</TableCell>
            <TableCell>Descripción</TableCell>
            <TableCell>Acciones</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {categories.map((cat) => (
            <TableRow key={cat.id}>
              <TableCell>{cat.name}</TableCell>
              <TableCell>{cat.description}</TableCell>
              <TableCell>
                <IconButton onClick={() => handleDeleteCategory(cat.id)}><Delete /></IconButton>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>

      <Typography variant="h6" sx={{ mt: 4 }}>Gestión de Productos</Typography>
      <Box sx={{ display: "flex", flexWrap: "wrap", gap: 2, mb: 2 }}>
        <TextField label="Nombre" value={newProduct.name} onChange={(e) => setNewProduct({ ...newProduct, name: e.target.value })} />
        <TextField label="Descripción" value={newProduct.description} onChange={(e) => setNewProduct({ ...newProduct, description: e.target.value })} />
        <TextField label="Precio" type="number" value={newProduct.price} onChange={(e) => setNewProduct({ ...newProduct, price: parseFloat(e.target.value) })} />
        <TextField label="Categoría ID" type="number" value={newProduct.category_id} onChange={(e) => setNewProduct({ ...newProduct, category_id: parseInt(e.target.value) })} />
        <FormControlLabel
          control={<Switch checked={newProduct.is_digital} onChange={(e) => setNewProduct({ ...newProduct, is_digital: e.target.checked })} />}
          label="Digital"
        />
        {newProduct.is_digital && (
          <TextField label="Archivo" value={newProduct.file_path} onChange={(e) => setNewProduct({ ...newProduct, file_path: e.target.value })} />
        )}
        <TextField label="Duración Suscripción (días)" type="number" value={newProduct.subscription_duration} onChange={(e) => setNewProduct({ ...newProduct, subscription_duration: parseInt(e.target.value) })} />
        <Button variant="contained" onClick={handleAddProduct} startIcon={<AddCircle />}>Añadir Producto</Button>
      </Box>
      <Table>
        <TableHead>
          <TableRow>
            <TableCell>Nombre</TableCell>
            <TableCell>Precio</TableCell>
            <TableCell>Categoría</TableCell>
            <TableCell>Digital</TableCell>
            <TableCell>Duración</TableCell>
            <TableCell>Acciones</TableCell>
          </TableRow>
        </TableHead>
        <TableBody>
          {products.map((prod) => (
            <TableRow key={prod.id}>
              <TableCell>{prod.name}</TableCell>
              <TableCell>{prod.price}</TableCell>
              <TableCell>{prod.category_id}</TableCell>
              <TableCell>{prod.is_digital ? "Sí" : "No"}</TableCell>
              <TableCell>{prod.subscription_duration || "N/A"}</TableCell>
              <TableCell>
                <IconButton onClick={() => handleDeleteProduct(prod.id)}><Delete /></IconButton>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </Box>
  );
}

// frontend/src/app/checkout/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import fetchAPI from "@/lib/api";
import { CartItem, Order } from "@/lib/types";
import { Box, Typography, Button, List, ListItem, ListItemText } from "@mui/material";

export default function CheckoutPage() {
  const { user, credits } = useAuth();
  const [cartItems, setCartItems] = useState<CartItem[]>([]);
  const [total, setTotal] = useState(0);

  useEffect(() => {
    const fetchCart = async () => {
      const { data } = await fetchAPI<CartItem[]>("/v1/marketplace/cart");
      setCartItems(data || []);
      const totalAmount = data?.reduce((sum, item) => sum + item.product.price * item.quantity, 0) || 0;
      setTotal(totalAmount);
    };
    fetchCart();
  }, []);

  const handleCheckout = async () => {
    if (credits < total) {
      alert("No tienes suficientes créditos");
      return;
    }
    const order = { items: cartItems.map(item => ({ product_id: item.product_id, quantity: item.quantity })) };
    const { data } = await fetchAPI<Order>("/v1/marketplace/orders", { method: "POST", data: order });
    if (data) {
      window.location.href = "/user/dashboard"; // Redirigir al dashboard tras éxito
    }
  };

  return (
    <Box sx={{ p: 4 }}>
      <Typography variant="h4">Carrito de Compras</Typography>
      <List>
        {cartItems.map(item => (
          <ListItem key={item.id}>
            <ListItemText primary={item.product.name} secondary={`Cantidad: ${item.quantity} - Precio: ${item.product.price}`} />
          </ListItem>
        ))}
      </List>
      <Typography variant="h6">Total: {total} créditos</Typography>
      <Button variant="contained" onClick={handleCheckout}>Realizar Checkout</Button>
    </Box>
  );
}

// src/app/user/dashboard/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Link,
} from "@mui/material";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box,
  Grid,
  Card,
  CardContent,
  CardHeader,
  TextField,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Typography,
  IconButton,
  Snackbar,
  Alert,
  MenuItem,
  Avatar,
  Chip,
  Divider,
  List,
  ListItem,
  ListItemAvatar,
  ListItemText,
  Badge,
  Paper,
  Tabs,
  Tab,
  useTheme,
  styled,
} from "@mui/material";
import { ShoppingCart } from "@mui/icons-material";
import {
  AccountCircle,
  Lock,
  Payment,
  CreditCard,
  AddCircle,
  Delete,
  ExpandMore,
  Edit,
  History,
  AttachMoney,
  Security,
  Logout,
  Person,
  LocationOn,
  Language,
  Star,
  StarBorder,
  LocalActivity,
} from "@mui/icons-material";
import { Integration, Order } from "@/lib/types";

// Styled Components
const GradientCard = styled(Card)(({ theme }) => ({
  background: `linear-gradient(135deg, var(--primary) 0%, var(--primary-hover) 100%)`,
  color: "white",
  borderRadius: "16px",
  boxShadow: theme.shadows[4],
}));

const GlassCard = styled(Card)(({ theme }) => ({
  background: "rgba(248, 249, 250, 0.8)",
  backdropFilter: "blur(10px)",
  border: "1px solid rgba(222, 226, 230, 0.5)",
  borderRadius: "16px",
  boxShadow: theme.shadows[2],
}));

interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
}

interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string;
}

interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}

export default function UserDashboard() {
  const { user, logout, updateProfile } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState({
    email: "",
    username: "",
    ciudad: "",
    website: "",
  });
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [methods, setMethods] = useState<PaymentMethod[]>([]);
  const [newMethod, setNewMethod] = useState({
    payment_type: "",
    details: "",
    is_default: false,
  });
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>(
    []
  );
  const [credits, setCredits] = useState("");
  const [paymentAmount, setPaymentAmount] = useState("");
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [tabValue, setTabValue] = useState(0);
  const [editMethod, setEditMethod] = useState<PaymentMethod | null>(null);
  const [deleteMethodId, setDeleteMethodId] = useState<number | null>(null);
  const { coupons, setCoupons } = useAuth();
  const [newIntegration, setNewIntegration] = useState({
    name: "",
    webhook_url: "",
    event_type: "",
  });
  const [integrations, setIntegrations] = useState<Integration[]>([]);

  const [orders, setOrders] = useState<Order[]>([]);

  useEffect(() => {
    const fetchOrders = async () => {
      const { data } = await fetchAPI<Order[]>("/v1/marketplace/orders");
      setOrders(data || []);
    };
    fetchOrders();
  }, []);

  // Añadir este useEffect justo después de los useState existentes
  useEffect(() => {
    const fetchCoupons = async () => {
      try {
        const { data } = await fetchAPI<any[]>("/v1/coupons/me"); // Ajusta el endpoint según tu API
        setCoupons(data || []);
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "Error al cargar cupones"
        );
      }
    };
    fetchCoupons();
  }, [setCoupons]);

  // Actualizar la función handleRedeem
  const handleRedeem = async (couponId: number) => {
    try {
      const { data } = await fetchAPI<any>(`/v1/coupons/redeem/${couponId}`, {
        method: "POST",
      });
      if (data) {
        setCoupons(coupons.map((c) => (c.id === couponId ? data : c)));
        const { data: info } = await fetchAPI<any>("/whoami");
        setCredits(info.credits);
        setSuccess("Cupón canjeado exitosamente");
      } else {
        setError("No se pudo canjear el cupón");
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al canjear cupón");
    }
  };

  // Actualizar el contenido de la pestaña "Coupons" (tabValue === 2)

  useEffect(() => {
    if (!user) {
      router.push("/");
      return;
    }
    setFormData({
      email: user.email || "",
      username: user.username || "",
      ciudad: user.ciudad || "",
      website: user.website || "",
    });

    const fetchData = async () => {
      try {
        const [transRes, methRes, providersRes, integrationsRes] =
          await Promise.all([
            fetchAPI<CreditTransaction[]>("/v1/payments/transactions"),
            fetchAPI<PaymentMethod[]>("/v1/payments/methods"),
            fetchAPI<PaymentProvider[]>("/v1/payment-providers"),
            fetchAPI<Integration[]>("/v1/integrations/"),
          ]);
        setTransactions(transRes.data || []);
        setMethods(methRes.data || []);
        setPaymentProviders(providersRes.data?.filter((p) => p.active) || []);
        setIntegrations(integrationsRes.data || []);
        if (providersRes.data && providersRes.data.length > 0) {
          setNewMethod((prev) => ({
            ...prev,
            payment_type: providersRes.data.find((p) => p.active)?.name || "",
          }));
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      }
    };
    fetchData();
  }, [user, router, credits]);

  const handleAddIntegration = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Integration>("/v1/integrations/", {
        method: "POST",
        data: {
          name: newIntegration.name,
          webhook_url: newIntegration.webhook_url,
          event_type: newIntegration.event_type,
        },
      });
      setIntegrations([...integrations, data!]);
      setNewIntegration({ name: "", webhook_url: "", event_type: "" });
      setSuccess("Integración creada con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Error al crear integración"
      );
    }
  };

  const handleDeleteIntegration = async (id: number) => {
    try {
      await fetchAPI(`/v1/integrations/${id}`, { method: "DELETE" });
      setIntegrations(integrations.filter((i) => i.id !== id));
      setSuccess("Integración eliminada");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Error al eliminar integración"
      );
    }
  };

  const handleEditMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editMethod) return;
    try {
      const { data } = await fetchAPI<PaymentMethod>(
        `/v1/payments/methods/${editMethod.id}`,
        {
          method: "PUT",
          data: editMethod,
        }
      );
      setMethods(methods.map((m) => (m.id === data!.id ? data! : m)));
      setEditMethod(null);
      setSuccess("Método actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Error al actualizar método"
      );
    }
  };

  const handleDeleteMethod = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}`, { method: "DELETE" });
      setMethods(methods.filter((m) => m.id !== id));
      setDeleteMethodId(null);
      setSuccess("Método eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar método");
    }
  };

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateProfile(formData);
      setSuccess("Perfil actualizado");
      setEditMode(false);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Error al actualizar perfil"
      );
    }
  };

  const handleChangePassword = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<{ message: string }>(
        "/v1/auth/me/password",
        {
          method: "PUT",
          data: {
            current_password: currentPassword,
            new_password: newPassword,
          },
        }
      );
      setSuccess(data?.message || "Contraseña actualizada");
      setCurrentPassword("");
      setNewPassword("");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Error al cambiar contraseña"
      );
    }
  };

  const handlePurchase = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<CreditTransaction>(
        "/v1/payments/purchase",
        {
          method: "POST",
          data: {
            credits: parseInt(credits),
            payment_amount: parseFloat(paymentAmount),
            payment_method: "stripe",
          },
        }
      );
      setTransactions([data!, ...transactions]);
      setCredits("");
      setPaymentAmount("");
      setSuccess("Créditos comprados");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error ? err.message : "Error al comprar créditos"
      );
    }
  };

  const handleAddMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentMethod>("/v1/payments/methods", {
        method: "POST",
        data: newMethod,
      });
      setMethods([...methods, data!]);
      setNewMethod({
        payment_type: paymentProviders[0]?.name || "",
        details: "",
        is_default: false,
      });
      setSuccess("Método añadido");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir método");
    }
  };

  const handleSetDefault = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}/default`, { method: "PUT" });
      setMethods(methods.map((m) => ({ ...m, is_default: m.id === id })));
      setSuccess("Método predeterminado actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(
        err instanceof Error
          ? err.message
          : "Error al establecer predeterminado"
      );
    }
  };

  const handleDeleteAccount = async () => {
    if (
      confirm(
        "¿Estás seguro de eliminar tu cuenta? Esta acción es irreversible."
      )
    ) {
      try {
        await fetchAPI("/v1/users/me", { method: "DELETE" });
        await logout();
        router.push("/user/auth/#login");
      } catch (err) {
        setError(
          err instanceof Error ? err.message : "Error al eliminar cuenta"
        );
      }
    }
  };

  if (!user)
    return (
      <Box
        sx={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          minHeight: "100vh",
          background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
        }}
      >
        <motion.div
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1, opacity: 1 }}
          transition={{ duration: 0.5 }}
        >
          <Typography variant="h6" color="textSecondary">
            Cargando tu perfil...
          </Typography>
        </motion.div>
      </Box>
    );

  return (
    <Box
      sx={{
        p: { xs: 2, md: 4 },
        minHeight: "100vh",
        background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
      }}
    >
      <Box sx={{ maxWidth: "1400px", mx: "auto" }}>
        {/* Header Section */}
        <Box
          sx={{
            display: "flex",
            flexDirection: { xs: "column", md: "row" },
            justifyContent: "space-between",
            alignItems: "center",
            mb: 4,
            gap: 2,
          }}
        >
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: "bold",
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: "text",
                WebkitTextFillColor: "transparent",
                display: "inline-block",
              }}
            >
              Hola, {user.username}!
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Bienvenido a tu panel de control
            </Typography>
          </motion.div>

          <Badge
            overlap="circular"
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
            badgeContent={
              <IconButton
                onClick={() => setEditMode(true)}
                size="small"
                sx={{ bgcolor: "primary.main", color: "white" }}
              >
                <Edit fontSize="small" />
              </IconButton>
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.primary.main,
                fontSize: "2rem",
                boxShadow: theme.shadows[6],
              }}
            >
              {user.username.charAt(0).toUpperCase()}
            </Avatar>
          </Badge>
        </Box>

        {/* Stats Cards */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.1 }}
        >
          <Grid container spacing={3} sx={{ mb: 4 }}>
            {/* Credits Card */}
            <Grid item xs={12} md={4}>
              <GradientCard>
                <CardContent>
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                    }}
                  >
                    <Box>
                      <Typography
                        variant="overline"
                        color="inherit"
                        sx={{ opacity: 0.8 }}
                      >
                        Tus Créditos
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: "bold" }}>
                        {user.credits ?? 0}
                      </Typography>
                    </Box>
                    <AttachMoney sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Transactions Card */}
            <Grid item xs={12} md={4}>
              <GradientCard
                sx={{
                  background:
                    "linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)",
                }}
              >
                <CardContent>
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                    }}
                  >
                    <Box>
                      <Typography
                        variant="overline"
                        color="inherit"
                        sx={{ opacity: 0.8 }}
                      >
                        Transacciones
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: "bold" }}>
                        {transactions.length}
                      </Typography>
                    </Box>
                    <History sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Payment Methods Card */}
            <Grid item xs={12} md={4}>
              <GradientCard
                sx={{
                  background:
                    "linear-gradient(135deg, #a6c1ee 0%, #fbc2eb 100%)",
                }}
              >
                <CardContent>
                  <Box
                    sx={{
                      display: "flex",
                      justifyContent: "space-between",
                      alignItems: "center",
                    }}
                  >
                    <Box>
                      <Typography
                        variant="overline"
                        color="inherit"
                        sx={{ opacity: 0.8 }}
                      >
                        Métodos de Pago
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: "bold" }}>
                        {methods.length}
                      </Typography>
                    </Box>
                    <Payment sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Tabs Navigation */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <Paper sx={{ mb: 3, borderRadius: "12px", overflow: "hidden" }}>
            <Tabs
              value={tabValue}
              onChange={(_, newValue) => setTabValue(newValue)}
              variant="scrollable"
              scrollButtons="auto"
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label="Perfil" icon={<Person />} iconPosition="start" />

              <Tab label="Seguridad" icon={<Security />} iconPosition="start" />
              <Tab
                label="Cupones"
                icon={<LocalActivity />}
                iconPosition="start"
              />
              <Tab
                label="Transacciones"
                icon={<History />}
                iconPosition="start"
              />
              <Tab
                label="Métodos de Pago"
                icon={<Payment />}
                iconPosition="start"
              />
              <Tab
                label="Comprar Créditos"
                icon={<CreditCard />}
                iconPosition="start"
              />

              <Tab label="Integraciones" icon={<Link />} iconPosition="start" />

              <Tab
                label="Compras"
                icon={<ShoppingCart />}
                iconPosition="start"
              />
              
            </Tabs>
          </Paper>
        </motion.div>

        {/* Tab Content */}
        <Box sx={{ mb: 4 }}>
          {/* Profile Tab */}
          {tabValue === 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Información Personal"
                      avatar={<AccountCircle color="primary" />}
                      action={
                        <IconButton onClick={() => setEditMode(!editMode)}>
                          <Edit color="primary" />
                        </IconButton>
                      }
                    />
                    <CardContent>
                      <AnimatePresence mode="wait">
                        {editMode ? (
                          <Box
                            component={motion.form}
                            key="edit"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                            onSubmit={handleUpdate}
                            sx={{
                              display: "flex",
                              flexDirection: "column",
                              gap: 2,
                            }}
                          >
                            <TextField
                              label="Email"
                              type="email"
                              value={formData.email}
                              onChange={(e) =>
                                setFormData({
                                  ...formData,
                                  email: e.target.value,
                                })
                              }
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Username"
                              type="text"
                              value={formData.username}
                              onChange={(e) =>
                                setFormData({
                                  ...formData,
                                  username: e.target.value,
                                })
                              }
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Ciudad"
                              type="text"
                              value={formData.ciudad}
                              onChange={(e) =>
                                setFormData({
                                  ...formData,
                                  ciudad: e.target.value,
                                })
                              }
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: (
                                  <LocationOn color="action" sx={{ mr: 1 }} />
                                ),
                              }}
                            />
                            <TextField
                              label="Website"
                              type="text"
                              value={formData.website}
                              onChange={(e) =>
                                setFormData({
                                  ...formData,
                                  website: e.target.value,
                                })
                              }
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: (
                                  <Language color="action" sx={{ mr: 1 }} />
                                ),
                              }}
                            />
                            <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
                              <Button
                                type="submit"
                                variant="contained"
                                color="primary"
                                sx={{ flex: 1 }}
                              >
                                Guardar Cambios
                              </Button>
                              <Button
                                onClick={() => setEditMode(false)}
                                variant="outlined"
                                sx={{ flex: 1 }}
                              >
                                Cancelar
                              </Button>
                            </Box>
                          </Box>
                        ) : (
                          <Box
                            component={motion.div}
                            key="view"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                          >
                            <List>
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar
                                    sx={{
                                      bgcolor: theme.palette.primary.light,
                                    }}
                                  >
                                    <Person />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Username"
                                  secondary={user.username || "No especificado"}
                                  secondaryTypographyProps={{
                                    color: "textPrimary",
                                  }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar
                                    sx={{ bgcolor: theme.palette.info.light }}
                                  >
                                    <AccountCircle />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Email"
                                  secondary={user.email || "No especificado"}
                                  secondaryTypographyProps={{
                                    color: "textPrimary",
                                  }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar
                                    sx={{
                                      bgcolor: theme.palette.success.light,
                                    }}
                                  >
                                    <LocationOn />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Ciudad"
                                  secondary={user.ciudad || "No especificado"}
                                  secondaryTypographyProps={{
                                    color: "textPrimary",
                                  }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar
                                    sx={{
                                      bgcolor: theme.palette.warning.light,
                                    }}
                                  >
                                    <Language />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Website"
                                  secondary={user.website || "No especificado"}
                                  secondaryTypographyProps={{
                                    color: "textPrimary",
                                  }}
                                />
                              </ListItem>
                            </List>
                          </Box>
                        )}
                      </AnimatePresence>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Actividad Reciente"
                      avatar={<History color="primary" />}
                    />
                    <CardContent>
                      {transactions.slice(0, 3).length > 0 ? (
                        <List>
                          {transactions.slice(0, 3).map((t) => (
                            <motion.div
                              key={t.id}
                              initial={{ opacity: 0 }}
                              animate={{ opacity: 1 }}
                              transition={{ duration: 0.3 }}
                            >
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar
                                    sx={{
                                      bgcolor:
                                        t.amount > 0
                                          ? theme.palette.success.light
                                          : theme.palette.error.light,
                                    }}
                                  >
                                    {t.amount > 0 ? "+" : "-"}
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary={`${t.transaction_type}`}
                                  secondary={`${new Date(
                                    t.timestamp
                                  ).toLocaleString()} • ${t.payment_status}`}
                                />
                                <Typography
                                  variant="body2"
                                  color={
                                    t.amount > 0 ? "success.main" : "error.main"
                                  }
                                >
                                  {t.amount > 0 ? "+" : ""}
                                  {t.amount} créditos
                                </Typography>
                              </ListItem>
                              <Divider variant="inset" component="li" />
                            </motion.div>
                          ))}
                        </List>
                      ) : (
                        <Typography
                          variant="body2"
                          color="textSecondary"
                          sx={{ textAlign: "center", py: 2 }}
                        >
                          No hay actividad reciente
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(2)}
                      >
                        Ver todas las transacciones
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>

              {/* Danger Zone moved to Profile Tab */}
              <GlassCard sx={{ mt: 3 }}>
                <CardHeader
                  title="Zona Peligrosa"
                  avatar={<Security color="error" />}
                />
                <CardContent>
                  <Typography
                    variant="body2"
                    color="textSecondary"
                    sx={{ mb: 2 }}
                  >
                    Estas acciones son irreversibles. Por favor, procede con
                    precaución.
                  </Typography>
                  <Box sx={{ display: "flex", gap: 2 }}>
                    <Button
                      onClick={logout}
                      variant="outlined"
                      color="secondary"
                      startIcon={<Logout />}
                      sx={{ flex: 1 }}
                    >
                      Cerrar Sesión
                    </Button>
                    <Button
                      onClick={handleDeleteAccount}
                      variant="contained"
                      color="error"
                      startIcon={<Delete />}
                      sx={{ flex: 1 }}
                    >
                      Eliminar Cuenta
                    </Button>
                  </Box>
                </CardContent>
              </GlassCard>
            </motion.div>
          )}
          {/* Security Tab */}
          {tabValue === 1 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Cambiar Contraseña"
                      avatar={<Lock color="primary" />}
                    />
                    <CardContent>
                      <Box
                        component="form"
                        onSubmit={handleChangePassword}
                        sx={{
                          display: "flex",
                          flexDirection: "column",
                          gap: 2,
                        }}
                      >
                        <TextField
                          label="Contraseña Actual"
                          type="password"
                          value={currentPassword}
                          onChange={(e) => setCurrentPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: (
                              <Lock color="action" sx={{ mr: 1 }} />
                            ),
                          }}
                        />
                        <TextField
                          label="Nueva Contraseña"
                          type="password"
                          value={newPassword}
                          onChange={(e) => setNewPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: (
                              <Security color="action" sx={{ mr: 1 }} />
                            ),
                          }}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          sx={{ mt: 1 }}
                        >
                          Actualizar Contraseña
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Métodos de Pago"
                      subheader={`${methods.length} configurados`}
                      avatar={<Payment color="primary" />}
                    />
                    <CardContent>
                      {methods.length > 0 ? (
                        <List>
                          {methods.slice(0, 2).map((m) => (
                            <ListItem key={m.id}>
                              <ListItemAvatar>
                                <Avatar
                                  sx={{
                                    bgcolor: m.is_default
                                      ? theme.palette.success.light
                                      : theme.palette.grey[300],
                                  }}
                                >
                                  {m.is_default ? <Star /> : <StarBorder />}
                                </Avatar>
                              </ListItemAvatar>
                              <ListItemText
                                primary={m.payment_type}
                                secondary={m.details}
                              />
                            </ListItem>
                          ))}
                        </List>
                      ) : (
                        <Typography
                          variant="body2"
                          color="textSecondary"
                          sx={{ textAlign: "center", py: 2 }}
                        >
                          No hay métodos de pago configurados
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(3)}
                      >
                        {methods.length > 0
                          ? "Gestionar métodos"
                          : "Añadir método"}
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}
          {/* Coupons Tab */}
          {tabValue === 2 && (
            <Box>
              <Typography variant="h6">Mis Cupones</Typography>
              {!coupons || coupons.length === 0 ? (
                <Typography>No tienes cupones</Typography>
              ) : (
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Nombre</TableCell>
                      <TableCell>Créditos</TableCell>
                      <TableCell>Estado</TableCell>
                      <TableCell>Acciones</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {coupons.map((coupon) => (
                      <TableRow key={coupon.id}>
                        <TableCell>{coupon.name}</TableCell>
                        <TableCell>{coupon.credits}</TableCell>
                        <TableCell>
                          <Chip
                            label={coupon.status}
                            color={
                              coupon.status === "active" ? "success" : "error"
                            }
                          />
                        </TableCell>
                        <TableCell>
                          {coupon.status === "active" && (
                            <Button
                              variant="contained"
                              onClick={() => handleRedeem(coupon.id)}
                            >
                              Canjear
                            </Button>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
            </Box>
          )}
          {/* Transactions Tab */}
          {tabValue === 3 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <GlassCard>
                <CardHeader
                  title="Historial de Transacciones"
                  avatar={<History color="primary" />}
                  action={
                    <Chip
                      label={`${transactions.length} transacciones`}
                      color="primary"
                      variant="outlined"
                    />
                  }
                />
                <CardContent>
                  {transactions.length === 0 ? (
                    <Typography
                      variant="body2"
                      color="textSecondary"
                      sx={{ textAlign: "center", py: 4 }}
                    >
                      No hay transacciones registradas
                    </Typography>
                  ) : (
                    <List sx={{ maxHeight: "500px", overflow: "auto" }}>
                      {transactions.map((t, index) => (
                        <motion.div
                          key={t.id || index} // Usar `index` como respaldo si `t.id` no está definido
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          transition={{ duration: 0.2 }}
                        >
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar
                                sx={{
                                  bgcolor:
                                    t.amount > 0
                                      ? theme.palette.success.light
                                      : theme.palette.error.light,
                                }}
                              >
                                {t.amount > 0 ? "+" : "-"}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={t.transaction_type || "N/A"}
                              secondary={`${
                                t.timestamp
                                  ? new Date(t.timestamp).toLocaleString()
                                  : "N/A"
                              } • ${t.payment_status || "N/A"}`}
                            />
                          </ListItem>
                          <Divider variant="inset" component="li" />
                        </motion.div>
                      ))}
                    </List>
                  )}
                </CardContent>
              </GlassCard>
            </motion.div>
          )}
          {/* Payment Methods Tab */}
          {tabValue === 4 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <GlassCard>
                <CardHeader
                  title="Métodos de Pago"
                  avatar={<Payment color="primary" />}
                  subheader="Gestiona tus métodos de pago asociados"
                />
                <CardContent>
                  {methods.length > 0 && (
                    <List sx={{ mb: 3 }}>
                      {methods.map((m) => (
                        <Paper
                          key={m.id}
                          elevation={2}
                          sx={{
                            mb: 2,
                            borderRadius: "8px",
                            overflow: "hidden",
                          }}
                        >
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar
                                sx={{
                                  bgcolor: m.is_default
                                    ? theme.palette.success.main
                                    : theme.palette.grey[300],
                                }}
                              >
                                {m.is_default ? <Star /> : <CreditCard />}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={
                                <Box
                                  sx={{ display: "flex", alignItems: "center" }}
                                >
                                  <Typography sx={{ mr: 1 }}>
                                    {m.payment_type}
                                  </Typography>
                                  {m.is_default && (
                                    <Chip
                                      label="Predeterminado"
                                      size="small"
                                      color="success"
                                      variant="outlined"
                                    />
                                  )}
                                </Box>
                              }
                              secondary={m.details}
                            />
                            <Box sx={{ display: "flex", gap: 1 }}>
                              <IconButton
                                onClick={() => setEditMethod(m)}
                                color="primary"
                              >
                                <Edit />
                              </IconButton>
                              <IconButton
                                onClick={() => setDeleteMethodId(m.id)}
                                color="error"
                              >
                                <Delete />
                              </IconButton>
                              {!m.is_default && (
                                <Button
                                  onClick={() => handleSetDefault(m.id)}
                                  variant="outlined"
                                  size="small"
                                >
                                  Hacer Predeterminado
                                </Button>
                              )}
                            </Box>
                          </ListItem>
                        </Paper>
                      ))}
                    </List>
                  )}

                  {/* Formulario para añadir método */}
                  <Accordion
                    sx={{
                      background: "rgba(255, 255, 255, 0.05)",
                      boxShadow: "none",
                      border: "1px solid rgba(255, 255, 255, 0.2)",
                    }}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Typography>Añadir nuevo método de pago</Typography>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Box
                        component="form"
                        onSubmit={handleAddMethod}
                        sx={{
                          display: "flex",
                          flexDirection: "column",
                          gap: 2,
                        }}
                      >
                        <TextField
                          label="Tipo"
                          select
                          value={newMethod.payment_type}
                          onChange={(e) =>
                            setNewMethod({
                              ...newMethod,
                              payment_type: e.target.value,
                            })
                          }
                          fullWidth
                          variant="outlined"
                          size="small"
                        >
                          {paymentProviders.map((provider) => (
                            <MenuItem key={provider.id} value={provider.name}>
                              {provider.name}
                            </MenuItem>
                          ))}
                        </TextField>
                        <TextField
                          label="Detalles"
                          value={newMethod.details}
                          onChange={(e) =>
                            setNewMethod({
                              ...newMethod,
                              details: e.target.value,
                            })
                          }
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          multiline
                          rows={3}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          startIcon={<AddCircle />}
                          sx={{ mt: 1 }}
                        >
                          Añadir Método
                        </Button>
                      </Box>
                    </AccordionDetails>
                  </Accordion>
                </CardContent>
              </GlassCard>

              {/* Diálogo para editar método */}
              <Dialog open={!!editMethod} onClose={() => setEditMethod(null)}>
                <DialogTitle>Editar Método de Pago</DialogTitle>
                <DialogContent>
                  <Box
                    component="form"
                    onSubmit={handleEditMethod}
                    sx={{
                      display: "flex",
                      flexDirection: "column",
                      gap: 2,
                      mt: 2,
                    }}
                  >
                    <TextField
                      label="Tipo"
                      select
                      value={editMethod?.payment_type || ""}
                      onChange={(e) =>
                        setEditMethod({
                          ...editMethod!,
                          payment_type: e.target.value,
                        })
                      }
                      fullWidth
                      variant="outlined"
                      size="small"
                    >
                      {paymentProviders.map((provider) => (
                        <MenuItem key={provider.id} value={provider.name}>
                          {provider.name}
                        </MenuItem>
                      ))}
                    </TextField>
                    <TextField
                      label="Detalles"
                      value={editMethod?.details || ""}
                      onChange={(e) =>
                        setEditMethod({
                          ...editMethod!,
                          details: e.target.value,
                        })
                      }
                      fullWidth
                      required
                      variant="outlined"
                      size="small"
                      multiline
                      rows={3}
                    />
                    <DialogActions>
                      <Button
                        onClick={() => setEditMethod(null)}
                        variant="outlined"
                      >
                        Cancelar
                      </Button>
                      <Button type="submit" variant="contained" color="primary">
                        Guardar
                      </Button>
                    </DialogActions>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Diálogo para confirmar eliminación */}
              <Dialog
                open={!!deleteMethodId}
                onClose={() => setDeleteMethodId(null)}
              >
                <DialogTitle>¿Eliminar Método de Pago?</DialogTitle>
                <DialogContent>
                  <Typography>
                    Esta acción es irreversible. ¿Estás seguro de eliminar este
                    método?
                  </Typography>
                </DialogContent>
                <DialogActions>
                  <Button
                    onClick={() => setDeleteMethodId(null)}
                    variant="outlined"
                  >
                    Cancelar
                  </Button>
                  <Button
                    onClick={() => handleDeleteMethod(deleteMethodId!)}
                    variant="contained"
                    color="error"
                  >
                    Eliminar
                  </Button>
                </DialogActions>
              </Dialog>
            </motion.div>
          )}
          {/* Buy Credits Tab */}
          {tabValue === 5 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Comprar Créditos"
                      avatar={<AttachMoney color="primary" />}
                      subheader="Recarga tu saldo de créditos"
                    />
                    <CardContent>
                      <Box
                        component="form"
                        onSubmit={handlePurchase}
                        sx={{
                          display: "flex",
                          flexDirection: "column",
                          gap: 2,
                        }}
                      >
                        <TextField
                          label="Cantidad de Créditos"
                          type="number"
                          value={credits}
                          onChange={(e) => setCredits(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: (
                              <AttachMoney color="action" sx={{ mr: 1 }} />
                            ),
                          }}
                        />
                        <TextField
                          label="Monto a Pagar (USD)"
                          type="number"
                          inputProps={{ step: "0.01" }}
                          value={paymentAmount}
                          onChange={(e) => setPaymentAmount(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: (
                              <Typography sx={{ mr: 1 }}>$</Typography>
                            ),
                          }}
                        />
                        <TextField
                          label="Método de Pago"
                          select
                          value={
                            methods.find((m) => m.is_default)?.id ||
                            methods[0]?.id ||
                            ""
                          }
                          onChange={(e) => {
                            const selectedMethod = methods.find(
                              (m) => m.id === parseInt(e.target.value)
                            );
                            if (selectedMethod) {
                              handleSetDefault(selectedMethod.id);
                            }
                          }}
                          fullWidth
                          variant="outlined"
                          size="small"
                          disabled={methods.length === 0}
                          helperText={
                            methods.length === 0
                              ? "No hay métodos de pago disponibles"
                              : "Selecciona un método de pago"
                          }
                        >
                          {methods.map((method) => (
                            <MenuItem key={method.id} value={method.id}>
                              {method.payment_type} - {method.details}{" "}
                              {method.is_default ? "(Predeterminado)" : ""}
                            </MenuItem>
                          ))}
                        </TextField>
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          size="large"
                          sx={{ mt: 2 }}
                          disabled={methods.length === 0}
                        >
                          Comprar Créditos
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Tarifas y Beneficios"
                      avatar={<CreditCard color="primary" />}
                    />
                    <CardContent>
                      <List>
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar
                              sx={{ bgcolor: theme.palette.success.light }}
                            >
                              <Star />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText
                            primary="1 crédito = $1 USD"
                            secondary="Tasa de cambio fija"
                          />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                              <Payment />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText
                            primary="Múltiples métodos de pago"
                            secondary="Tarjetas, PayPal y más"
                          />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar
                              sx={{ bgcolor: theme.palette.warning.light }}
                            >
                              <Security />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText
                            primary="Transacciones seguras"
                            secondary="Encriptación SSL"
                          />
                        </ListItem>
                      </List>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}
          {tabValue === 6 && (
            <Box>
              <Box
                component="form"
                onSubmit={handleAddIntegration}
                sx={{ mb: 2 }}
              >
                <TextField
                  label="Nombre"
                  value={newIntegration.name}
                  onChange={(e) =>
                    setNewIntegration({
                      ...newIntegration,
                      name: e.target.value,
                    })
                  }
                />
                <TextField
                  label="Webhook URL"
                  value={newIntegration.webhook_url}
                  onChange={(e) =>
                    setNewIntegration({
                      ...newIntegration,
                      webhook_url: e.target.value,
                    })
                  }
                />
                <TextField
                  label="Tipo de Evento"
                  value={newIntegration.event_type}
                  onChange={(e) =>
                    setNewIntegration({
                      ...newIntegration,
                      event_type: e.target.value,
                    })
                  }
                />
                <Button type="submit" variant="contained">
                  Añadir
                </Button>
              </Box>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Nombre</TableCell>
                    <TableCell>Estado</TableCell>
                    <TableCell>Acciones</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {integrations.map((integration) => (
                    <TableRow key={integration.id}>
                      <TableCell>{integration.name}</TableCell>
                      <TableCell>
                        {integration.active ? "Activo (Admin)" : "Pendiente"}
                      </TableCell>
                      <TableCell>
                        <IconButton
                          onClick={() =>
                            handleDeleteIntegration(integration.id)
                          }
                          color="error"
                        >
                          <Delete />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Box>
          )}

          {/* Orders Tab */}
          {tabValue === 7 && (
            <Box>
              <Typography variant="h6">Historial de Compras</Typography>
              <List>
                {orders.map((order) => (
                  <ListItem key={order.id}>
                    <ListItemText
                      primary={`Orden #${order.id}`}
                      secondary={`Total: ${order.total_amount} - Estado: ${
                        order.status
                      } - Fecha: ${new Date(
                        order.created_at
                      ).toLocaleString()}`}
                    />
                    {order.items.some((item) => item.is_digital) && (
                      <Button
                        href={
                          order.items.find((item) => item.is_digital)?.file_path
                        }
                        download
                        disabled={
                          !order.items.find((item) => item.is_digital)
                            ?.file_path
                        }
                      >
                        Descargar
                      </Button>
                    )}
                  </ListItem>
                ))}
              </List>
            </Box>
          )}
        </Box>
      </Box>

      {/* Notifications */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: "12px" }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: "12px" }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box>
  );
}


# backend/api/v1/marketplace.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from core.database import get_db
from services.marketplace_service import (
    create_category, get_categories, update_category, delete_category,
    create_product, get_products, update_product, delete_product
)
from services.cart_service import add_to_cart, get_cart
from services.order_service import create_order, get_orders
from schemas.marketplace import (
    CategoryCreate, CategoryResponse, ProductCreate, ProductResponse,
    CartItemCreate, CartItemResponse, OrderCreate, OrderResponse
)
from dependencies.auth import get_user_context, UserContext
from typing import List

router = APIRouter(tags=["Marketplace"])

# Categorías
@router.post("/categories", response_model=CategoryResponse)
def create_category_route(category: CategoryCreate, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    if user_context.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_category(db, category)

@router.get("/categories", response_model=List[CategoryResponse])
def get_categories_route(db: Session = Depends(get_db)):
    return get_categories(db)

@router.put("/categories/{category_id}", response_model=CategoryResponse)
def update_category_route(category_id: int, category: CategoryCreate, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    if user_context.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_category(db, category_id, category)

@router.delete("/categories/{category_id}")
def delete_category_route(category_id: int, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    if user_context.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    delete_category(db, category_id)
    return {"message": "Categoría eliminada"}

# Productos
@router.post("/products", response_model=ProductResponse)
def create_product_route(product: ProductCreate, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    if user_context.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_product(db, product)

@router.get("/products", response_model=List[ProductResponse])
def get_products_route(db: Session = Depends(get_db)):
    return get_products(db)

@router.put("/products/{product_id}", response_model=ProductResponse)
def update_product_route(product_id: int, product: ProductCreate, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    if user_context.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_product(db, product_id, product)

@router.delete("/products/{product_id}")
def delete_product_route(product_id: int, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    if user_context.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    delete_product(db, product_id)
    return {"message": "Producto eliminado"}

# Carrito
@router.post("/cart", response_model=CartItemResponse)
def add_to_cart_route(cart_item: CartItemCreate, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    user_id = int(user_context.user_id) if user_context.user_type == "registered" else None
    session_id = user_context.session_id if user_context.user_type == "anonymous" else None
    return add_to_cart(db, user_id, session_id, cart_item)

@router.get("/cart", response_model=List[CartItemResponse])
def get_cart_route(db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    user_id = int(user_context.user_id) if user_context.user_type == "registered" else None
    session_id = user_context.session_id if user_context.user_type == "anonymous" else None
    return get_cart(db, user_id, session_id)

# Órdenes
@router.post("/orders", response_model=OrderResponse)
def create_order_route(order: OrderCreate, db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    user_id = int(user_context.user_id) if user_context.user_type == "registered" else None
    session_id = user_context.session_id if user_context.user_type == "anonymous" else None
    return create_order(db, user_id, session_id, order)

@router.get("/orders", response_model=List[OrderResponse])
def get_orders_route(db: Session = Depends(get_db), user_context: UserContext = Depends(get_user_context)):
    user_id = int(user_context.user_id) if user_context.user_type == "registered" else None
    session_id = user_context.session_id if user_context.user_type == "anonymous" else None
    return get_orders(db, user_id, session_id)

# backend/core/security.py
# Seguridad y autenticación OAuth2 y JWT

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from oauthlib.oauth2 import WebApplicationClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jwt import encode, decode, PyJWTError
from os import getenv
from datetime import datetime, timedelta
from typing import Optional
from core.logging import configure_logging
from core.database import get_db
from services.settings_service import get_setting

logger = configure_logging()

# Configuración de OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/v1/auth/token")
google_client = WebApplicationClient(getenv("GOOGLE_CLIENT_ID"))
meta_client = WebApplicationClient(getenv("META_CLIENT_ID"))

# Configuración de hash de contraseñas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_token(user_id: str, user_type: str = "registered"):
    payload = {
        "sub": str(user_id),
        "type": user_type,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, getenv("SECRET_KEY"), algorithm="HS256")

def decode_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, getenv("SECRET_KEY"), algorithms=["HS256"])
        # Validación adicional del payload
        if not payload.get("sub") or not payload.get("type"):
            logger.warning(f"Token inválido: falta sub o type en el payload")
            return None
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token expirado")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Token inválido: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Error inesperado al decodificar token: {str(e)}")
        return None

def create_access_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "token_expiration") or "3600")
        if expiration < 300:  # Mínimo 5 minutos
            expiration = 3600
            logger.warning("Token expiration too low, using default 1h")
    except Exception as e:
        logger.error(f"Error token_expiration: {str(e)}")
        expiration = 3600
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

def create_refresh_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "refresh_token_expiration") or "604800")
        if expiration < 86400:  # Mínimo 1 día
            expiration = 604800
            logger.warning("Refresh token expiration too low, using default 7d")
    except Exception as e:
        logger.error(f"Error refresh_token_expiration: {str(e)}")
        expiration = 604800
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")


def create_refresh_token(data: dict):
    db = next(get_db())
    expiration_str = get_setting(db, "refresh_token_expiration") or "604800"  # Valor por defecto: 7 días
    try:
        expiration = int(str(expiration_str))  # Convertir a cadena primero y luego a entero
    except ValueError:
        logger.error(f"Valor inválido para refresh_token_expiration: {expiration_str}")
        expiration = 604800  # Valor por defecto si falla
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

    
def get_oauth2_redirect_url(provider: str) -> str:
    if provider == "google":
        return google_client.prepare_request_uri(
            "https://accounts.google.com/o/oauth2/v2/auth",
            redirect_uri=getenv("GOOGLE_REDIRECT_URI"),
            scope=["openid", "email", "profile"]
        )
    elif provider == "meta":
        return meta_client.prepare_request_uri(
            "https://www.facebook.com/v13.0/dialog/oauth",
            redirect_uri=getenv("META_REDIRECT_URI"),
            scope=["email"]
        )
    raise ValueError("Proveedor no soportado")

# backend/dependencies/auth.py
# Módulo de dependencias de autenticación y contexto de usuario
from models.coupon_type import CouponType
from fastapi import Depends, HTTPException, Request
from sqlalchemy.orm import Session
from core.database import get_db
from models.user import User
from models.guests import GuestsSession
from models.token import RevokedToken
from core.security import decode_token
from core.logging import configure_logging
from services.coupon_service import create_coupon
from schemas.coupon import CouponCreate
from uuid import uuid4
from datetime import datetime
from pydantic import BaseModel
from fastapi import Response
import random
import string

logger = configure_logging()

class UserContext(BaseModel):
    user_id: str
    email: str
    username: str
    user_type: str  # "registered" o "anonymous"
    subscription: str
    credits: int
    rol: str
    session_id: str | None = None

    class Config:
        from_attributes = True

def generate_unique_username(db: Session) -> str:
    while True:
        random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        username = f"Guest_{random_chars}"
        if not db.query(GuestsSession).filter(GuestsSession.username == username).first():
            return username

async def get_user_context(request: Request, response: Response, db: Session = Depends(get_db)):
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
    session_id = request.headers.get("X-Session-ID")  # Leer de header en lugar de cookie
    client_ip = request.client.host
    logger.info(f"Procesando solicitud: token={bool(token)}, session_id={session_id}, ip={client_ip}")

    try:
        if token:
            # Lógica para usuarios registrados (sin cambios)
            if db.query(RevokedToken).filter(RevokedToken.token == token).first():
                logger.warning(f"Intento de uso de token revocado desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token revocado")
            payload = decode_token(token)
            if not payload or payload.get("type") != "access":
                logger.error(f"Token inválido recibido desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token inválido o no es de acceso")
            user = db.query(User).filter(User.id == int(payload["sub"])).first()
            if not user:
                logger.error(f"Usuario no encontrado para token desde IP {client_ip}")
                raise HTTPException(status_code=404, detail="Usuario no encontrado")
            if not user.activo:
                logger.warning(f"Intento de acceso con usuario inactivo ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=403, detail="Usuario inactivo")
            if user.token_valid_until and user.token_valid_until < datetime.utcnow():
                logger.warning(f"Token expirado manualmente para usuario ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token no válido")
            
            user.last_ip = client_ip
            user.last_login = datetime.utcnow()
            db.commit()
            logger.info(f"Usuario registrado ID {user.id} autenticado desde IP {client_ip}")
            return UserContext(
                user_type="registered",
                user_id=str(user.id),
                email=user.email,
                username=user.username,
                credits=user.credits,
                subscription=user.subscription.value,
                rol=user.rol
            )

        if not session_id:
            logger.info("No hay session_id en header, creando nueva sesión anónima")
            session_id = str(uuid4())
            username = generate_unique_username(db)  # Generar apodo único
            new_session = GuestsSession(
                id=session_id,
                username=username,  # Asignar el apodo
                credits=10,
                create_at=datetime.utcnow(),
                ultima_actividad=datetime.utcnow(),
                last_ip=client_ip
            )
            db.add(new_session)
            db.commit()

            # Crear cupón de bienvenida
            coupon_type = db.query(CouponType).filter(CouponType.name == "Bienvenida").first()
            if not coupon_type:
                logger.error("Tipo de cupón 'Bienvenida' no encontrado")
                raise HTTPException(status_code=500, detail="Tipo de cupón 'Bienvenida' no encontrado")

            coupon_data = CouponCreate(
                name="Bienvenida",
                description="Cupón de bienvenida para usuarios anónimos",
                credits=5,
                active=True,
                session_id=session_id,
                user_id=session_id,
                expires_at=None,
                issued_at=datetime.utcnow(),
                redeemed_at=None,
                status="active",
                unique_identifier=f"WELCOME-{session_id[:8]}",
                coupon_type_id=coupon_type.id  # Asignar el ID del tipo de cupón
            )
            create_coupon(db, coupon_data, user_id=None, session_id=session_id) 
            logger.info(f"Cupón de bienvenida creado para sesión {session_id}")

        
            logger.info(f"Nueva sesión anónima creada ID {session_id} con username {username} desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session_id,
                email="anonymous@example.com",
                username=username,  # Usar el apodo generado
                credits=10,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )
        else:
            logger.info(f"Buscando sesión anónima con ID {session_id} desde header")
            session = db.query(GuestsSession).filter(GuestsSession.id == session_id).first()
            if not session:
                logger.warning(f"Sesión anónima inválida ID {session_id} desde IP {client_ip}")
                raise HTTPException(status_code=400, detail="Sesión anónima inválida")
            
            session.last_ip = client_ip
            session.ultima_actividad = datetime.utcnow()
            db.commit()
            logger.info(f"Sesión anónima ID {session_id} actualizada desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session.id,
                email="anonymous@example.com",
                username=session.username,  # Usar el username de la sesión
                credits=session.credits,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )

        logger.error(f"No autorizado: sin token ni sesión válida desde IP {client_ip}")
        raise HTTPException(status_code=401, detail="No autorizado")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en get_user_context desde IP {client_ip}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar la autenticación")

# backend/models/marketplace.py
from datetime import datetime
from sqlalchemy import Column, DateTime, Integer, String, Float, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from core.database import Base

class Category(Base):
    __tablename__ = "categories"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(String, nullable=True)
    products = relationship("Product", back_populates="category")

class Product(Base):
    __tablename__ = "products"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    description = Column(String, nullable=True)
    price = Column(Float, nullable=False)
    category_id = Column(Integer, ForeignKey("categories.id"))
    is_digital = Column(Boolean, default=False)
    file_path = Column(String, nullable=True)  # Para descargas digitales
    subscription_duration = Column(Integer, nullable=True)  # Días, para suscripciones
    category = relationship("Category", back_populates="products")
    cart_items = relationship("CartItem", back_populates="product")
    order_items = relationship("OrderItem", back_populates="product")

class CartItem(Base):
    __tablename__ = "cart_items"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    session_id = Column(String, nullable=True)
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Integer, nullable=False)
    product = relationship("Product", back_populates="cart_items")

class Order(Base):
    __tablename__ = "orders"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    session_id = Column(String, nullable=True)
    total_amount = Column(Float, nullable=False)
    status = Column(String, default="pending")
    created_at = Column(DateTime, default=datetime.utcnow)
    items = relationship("OrderItem", back_populates="order", lazy="selectin")

class OrderItem(Base):
    __tablename__ = "order_items"
    id = Column(Integer, primary_key=True, index=True)
    order_id = Column(Integer, ForeignKey("orders.id"))
    product_id = Column(Integer, ForeignKey("products.id"))
    quantity = Column(Integer, nullable=False)
    price = Column(Float, nullable=False)  # Precio en el momento de la compra
    product_name = Column(String, nullable=False)
    is_digital = Column(Boolean, default=False)
    file_path = Column(String, nullable=True)
    order = relationship("Order", back_populates="items")
    product = relationship("Product", back_populates="order_items")

# backend/schemas/marketplace.py
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class CategoryBase(BaseModel):
    name: str
    description: Optional[str] = None

class CategoryCreate(CategoryBase):
    pass

class CategoryResponse(CategoryBase):
    id: int
    class Config:
        orm_mode = True

class ProductBase(BaseModel):
    name: str
    description: Optional[str] = None
    price: float
    category_id: int
    is_digital: bool = False
    file_path: Optional[str] = None
    subscription_duration: Optional[int] = None

class ProductCreate(ProductBase):
    pass

class ProductResponse(ProductBase):
    id: int
    class Config:
        orm_mode = True

class CartItemBase(BaseModel):
    product_id: int
    quantity: int

class CartItemCreate(CartItemBase):
    pass

class CartItemResponse(CartItemBase):
    id: int
    product: ProductResponse
    class Config:
        orm_mode = True

class OrderItemBase(BaseModel):
    product_id: int
    quantity: int

class OrderItemResponse(BaseModel):
    id: int
    product_id: int
    quantity: int
    price: float
    product_name: str
    is_digital: bool
    file_path: Optional[str] = None
    class Config:
        orm_mode = True

class OrderCreate(BaseModel):
    items: List[OrderItemBase]

class OrderResponse(BaseModel):
    id: int
    total_amount: float
    status: str
    created_at: datetime
    items: List[OrderItemResponse]
    class Config:
        orm_mode = True

# backend/api/v1/config/integrations.py
from sqlalchemy.orm import Session
from fastapi import HTTPException
from models.marketplace import Category, Product
from schemas.marketplace import CategoryCreate, CategoryResponse, ProductCreate, ProductResponse
from typing import List

def create_category(db: Session, category: CategoryCreate) -> Category:
    db_category = Category(**category.dict())
    db.add(db_category)
    db.commit()
    db.refresh(db_category)
    return db_category

def get_categories(db: Session) -> List[Category]:
    return db.query(Category).all()

def update_category(db: Session, category_id: int, category: CategoryCreate) -> Category:
    db_category = db.query(Category).filter(Category.id == category_id).first()
    if not db_category:
        raise HTTPException(status_code=404, detail="Categoría no encontrada")
    for key, value in category.dict().items():
        setattr(db_category, key, value)
    db.commit()
    db.refresh(db_category)
    return db_category

def delete_category(db: Session, category_id: int):
    db_category = db.query(Category).filter(Category.id == category_id).first()
    if not db_category:
        raise HTTPException(status_code=404, detail="Categoría no encontrada")
    db.delete(db_category)
    db.commit()

def create_product(db: Session, product: ProductCreate) -> Product:
    db_product = Product(**product.dict())
    db.add(db_product)
    db.commit()
    db.refresh(db_product)
    return db_product

def get_products(db: Session) -> List[Product]:
    return db.query(Product).all()

def update_product(db: Session, product_id: int, product: ProductCreate) -> Product:
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Producto no encontrado")
    for key, value in product.dict().items():
        setattr(db_product, key, value)
    db.commit()
    db.refresh(db_product)
    return db_product

def delete_product(db: Session, product_id: int):
    db_product = db.query(Product).filter(Product.id == product_id).first()
    if not db_product:
        raise HTTPException(status_code=404, detail="Producto no encontrado")
    db.delete(db_product)
    db.commit()

# backend/api/v1/users/users.py
# Endpoints de gestión de usuarios (v1)
from math import ceil
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from models.user import User
from schemas.user import UserResponse, UpdateProfileRequest
from services.user_service import get_user_info, update_user, delete_user, list_users
from core.database import get_db
from dependencies.auth import UserContext, get_user_context
from core.logging import configure_logging

router = APIRouter(tags=["users"])

logger = configure_logging()

@router.get("/me", response_model=UserResponse)
def get_me(user: UserContext = Depends(get_user_context),
           db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(status_code=403,
                            detail="Solo usuarios registrados")
    return get_user_info(db, int(user.user_id))


@router.put("/me", response_model=UserResponse)
def update_me(request: UpdateProfileRequest,
              user: UserContext = Depends(get_user_context),
              db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(status_code=403,
                            detail="Solo usuarios registrados")
    return update_user(db, int(user.user_id), request.email, request.username,
                       request.ciudad, request.website)


@router.delete("/me", response_model=dict)
def delete_me(user: UserContext = Depends(get_user_context),
              db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(status_code=403,
                            detail="Solo usuarios registrados")
    return delete_user(db, int(user.user_id))


@router.get("/admin/users", response_model=dict)
def get_all_users(page: int = Query(1, ge=1),
                  limit: int = Query(10, ge=1, le=100),
                  user=Depends(get_user_context),
                  db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden ver la lista de usuarios")

    offset = (page - 1) * limit
    query = db.query(User)
    total_items = query.count()
    users = query.offset(offset).limit(limit).all()

    # Convertimos los usuarios a esquemas Pydantic
    users_data = [UserResponse.model_validate(user) for user in users]

    return {
        "data": users_data,
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }


@router.get("/{user_id}", response_model=UserResponse)
def get_user(user_id: int,
             user: UserContext = Depends(get_user_context),
             db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden acceder a esta información")
    user_data = get_user_info(db, user_id)
    if not user_data:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return user_data


@router.put("/{user_id}", response_model=UserResponse)
def update_user_by_id(user_id: int,
                      request: UpdateProfileRequest,
                      user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden actualizar usuarios")
    updated_user = update_user(db,
                               user_id,
                               email=request.email,
                               username=request.username,
                               ciudad=request.ciudad,
                               website=request.website)
    return updated_user


@router.delete("/{user_id}", response_model=dict)
def delete_user_by_id(user_id: int,
                      user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden eliminar usuarios")
    result = delete_user(db, user_id)
    return result


# backend/api/v1/users/anonymous_sessions.py
# Endpoints para gestión de sesiones anónimas (v1)

from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
from models.guests import GuestsSession
from schemas.anonymous_session import GuestsSessionResponse 
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Sessions"])

@router.get("/", response_model=dict)
def get_anonymous_sessions(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(GuestsSession)
    total_items = query.count()
    sessions = query.offset(offset).limit(limit).all()

    sessions_data = [GuestsSessionResponse.from_orm(session) for session in sessions]
    
    return {
        "data": sessions_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

@router.get("/credits", response_model=dict)
async def get_anonymous_credits(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.user_type != "anonymous":
        raise HTTPException(status_code=403, detail="Solo para usuarios anónimos")
    session = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Sesión no encontrada")
    return {"credits": session.credits}

# backend/models/user.py
# Modelo de usuario y sus atributos principales
from datetime import datetime
from sqlalchemy import Column, Float, Integer, String, DateTime, Boolean, Enum
from core.database import Base
from sqlalchemy.orm import relationship
import enum

class subscriptionEnum(enum.Enum):
    FREEMIUM = "freemium"
    PREMIUM = "premium"
    CORPORATE = "corporate"

class User(Base):
    __tablename__ = "usuarios"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    username = Column(String(50), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=True)  # Nullable para terceros
    auth_provider = Column(String(20), nullable=True)  # "local", "google", "meta", etc.
    provider_id = Column(String(255), nullable=True)  # ID único del proveedor
    rol = Column(String(20), default="user")  # "user" o "admin"
    activo = Column(Boolean, default=True)  # Estado de la cuenta
    subscription = Column(Enum(subscriptionEnum), default=subscriptionEnum.FREEMIUM)  # subscription de suscripción
    #ciudad = Column(String(100), nullable=True)  # Para perfil
    website = Column(String(255), nullable=True)  # URL de avatar o perfil
    credits = Column(Integer, default=10)  # Créditos disponibles
    #create_at = Column(DateTime, default=datetime.utcnow)  # Fecha de registro
    renewal = Column(DateTime, nullable=True)  # Última renovación de créditos
    last_ip = Column(String(45), nullable=True)  # Última IP conocida (IPv4/IPv6)
    last_login = Column(DateTime, nullable=True)  # Último inicio de sesión
    token_valid_until = Column(DateTime, nullable=True)  # Fecha de expiración del token actual
    
    
    gamification_events = relationship("GamificationEvent", back_populates="user")
    gamification = relationship("UserGamification", back_populates="user")
    

    # Añadir relaciones inversas en los modelos existentes
    coupons = relationship("Coupon", foreign_keys="Coupon.user_id", back_populates="user")

    
      # 📌 Ubicación y demografía
    #pais = Column(String(100), nullable=True)  
    ciudad = Column(String(100), nullable=True)  
    #zona_horaria = Column(String(50), nullable=True)  
    #idioma = Column(String(20), nullable=True)  

    # 📌 Datos de empresa
    #empresa = Column(String(255), nullable=True)  
    #industria = Column(String(100), nullable=True)  
    #tamaño_empresa = Column(String(50), nullable=True)  # Startup, PYME, Enterprise
    #num_empleados = Column(Integer, nullable=True)  
    #ingresos_anuales = Column(Float, nullable=True)  
    #presupuesto_estimado = Column(Float, nullable=True)  

    # 📌 Datos técnicos y uso
    #tecnologias_usadas = Column(String(255), nullable=True)  
    #nivel_digitalizacion = Column(String(50), nullable=True)  
    #dispositivo_frecuente = Column(String(50), nullable=True)  
    #engagement = Column(Float, nullable=True)  # % de funciones utilizadas  
    #tiempo_en_plataforma = Column(Integer, nullable=True)  # Minutos activos por mes  

    # 📌 Ciclo de vida
    create_at = Column(DateTime, default=datetime.utcnow)  
    #ultima_actividad = Column(DateTime, nullable=True)  
    #historial_pagos = Column(String(255), nullable=True)  
    #probabilidad_churn = Column(Float, nullable=True)  

    # 📌 Datos comerciales
    #volumen_transacciones = Column(Float, nullable=True)  
    #origen_lead = Column(String(100), nullable=True)  
    #clientes_referidos = Column(Integer, nullable=True)  

    # Añadir relaciones inversas en los modelos existentes
    coupons = relationship("Coupon", foreign_keys="Coupon.user_id", back_populates="user")

# backend/models/guests.py
# Modelo de sesiones anónimas para usuarios no identificados
# Módulo del modelo de sesión para usuarios anonimos que no estan identificados.
from sqlalchemy import Column, String, Integer, DateTime, Float
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime

class GuestsSession(Base):
    __tablename__ = "sesiones_anonimas"
    
    id = Column(String(36), primary_key=True, index=True)  
    username = Column(String(50), unique=True, nullable=False)  
    credits = Column(Integer, default=10)  
    create_at = Column(DateTime, default=datetime.utcnow)  
    ultima_actividad = Column(DateTime, nullable=True)  
    last_ip = Column(String(45), nullable=True)  

    # 📌 Información Inferida
    #probable_pais = Column(String(100), nullable=True)  
    #probable_industria = Column(String(100), nullable=True)  
    #probable_num_empleados = Column(Integer, nullable=True)  
    #probable_ingresos_anuales = Column(Float, nullable=True)  
    #probable_tecnologias_usadas = Column(String(255), nullable=True)  
    #engagement_anonimo = Column(Float, nullable=True)  # % de uso en la sesión  

    # Relación con gamificación
    gamification_events = relationship("GamificationEvent", back_populates="session")
    gamification = relationship("UserGamification", back_populates="session")


    coupons = relationship("Coupon", foreign_keys="Coupon.session_id", back_populates="session")



# backend/ini_db.py
# Inicialización y carga de datos de ejemplo en la base de datos

import uuid
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy.orm import sessionmaker
from models.marketplace import Category, Product
from schemas.marketplace import CategoryCreate, ProductCreate
from services.marketplace_service import create_category, create_product
from services.settings_service import set_setting
from core.database import SessionLocal, Base, engine
from models.site_settings import SiteSettings
from models.user import User, subscriptionEnum
from models.allowed_origin import AllowedOrigin
from models.credit_transaction import CreditTransaction
from models.error_log import ErrorLog
from models.integration import Integration
from models.log import APILog
from models.payment_method import PaymentMethod
from models.gamification import EventType, Badge, GamificationEvent, UserGamification
from models.guests import GuestsSession
from models.token import RevokedToken, PasswordResetToken
from models.coupon import Coupon
from models.coupon_type import CouponType
from models.payment_provider import PaymentProvider
from core.security import hash_password
import json


def init_db():
    """Crea todas las tablas en la base de datos"""
    Base.metadata.create_all(bind=engine)


def init_settings_and_users():
    """Pobla la base de datos con datos iniciales si está vacía."""
    Session = sessionmaker(bind=engine)
    db = Session()
    try:
        # Verificar si la base de datos ya tiene datos
        if db.query(User).first():
            print(
                "La base de datos ya está poblada. No se realizarán cambios.")
            return

        # Configuraciones iniciales en site_settings
        settings_data = [
            {
                "key": "token_expiration",
                "value": 3600,
                "description": "Tiempo de vida del access token (segundos)",
                "tag": "auth"
            },
            {
                "key": "refresh_token_expiration",
                "value": 604800,
                "description": "Tiempo de vida del refresh token (7 días)",
                "tag": "auth"
            },
            {
                "key": "max_login_attempts",
                "value": 5,
                "description": "Máximo de intentos de login antes de bloqueo",
                "tag": "auth"
            },
            {
                "key": "rate_limit_auth",
                "value": {
                    "times": 20,
                    "seconds": 60
                },
                "description": "Límite de peticiones para auth",
                "tag": "rate_limit"
            },
            {
                "key": "rate_limit_api",
                "value": {
                    "times": 100,
                    "seconds": 60
                },
                "description": "Límite de peticiones para API",
                "tag": "rate_limit"
            },
            {
                "key": "rate_limit_admin",
                "value": {
                    "times": 50,
                    "seconds": 60
                },
                "description": "Límite de peticiones para admin",
                "tag": "rate_limit"
            },
            {
                "key": "cache_ttl",
                "value": 300,
                "description": "Tiempo de vida del caché en Redis (segundos)",
                "tag": "cache"
            },
            {
                "key": "cache_enabled",
                "value": True,
                "description": "Habilitar/deshabilitar el caché",
                "tag": "cache"
            },
            {
                "key": "cache_max_size",
                "value": 10000,
                "description": "Tamaño máximo del caché en entradas",
                "tag": "cache"
            },
            {
                "key": "allowed_origins",
                "value": True,
                "description":
                "Activar/desactivar orígenes permitidos para CORS",
                "tag": "cors"
            },
            {
                "key": "cors_enabled",
                "value": True,
                "description": "Habilitar/deshabilitar CORS",
                "tag": "cors"
            },
            {
                "key": "celery_workers",
                "value": 4,
                "description": "Número de workers de Celery",
                "tag": "celery"
            },
            {
                "key": "celery_task_timeout",
                "value": 300,
                "description":
                "Tiempo máximo de ejecución de tareas Celery (segundos)",
                "tag": "celery"
            },
            {
                "key": "celery_max_retries",
                "value": 3,
                "description": "Máximo de reintentos para tareas Celery",
                "tag": "celery"
            },
            {
                "key": "db_pool_size",
                "value": 20,
                "description": "Tamaño del pool de conexiones a la DB",
                "tag": "database"
            },
            {
                "key": "db_max_overflow",
                "value": 10,
                "description": "Conexiones adicionales permitidas en el pool",
                "tag": "database"
            },
            {
                "key": "db_pool_timeout",
                "value": 30,
                "description":
                "Tiempo de espera para una conexión del pool (segundos)",
                "tag": "database"
            },
            {
                "key": "freemium_credits",
                "value": 100,
                "description": "Créditos iniciales para suscripción freemium",
                "tag": "credits"
            },
            {
                "key": "premium_credits",
                "value": 1000,
                "description": "Créditos iniciales para suscripción premium",
                "tag": "credits"
            },
            {
                "key": "corporate_credits",
                "value": 5000,
                "description":
                "Créditos iniciales para suscripción corporativa",
                "tag": "credits"
            },
            {
                "key": "credit_reset_interval",
                "value": 30,
                "description": "Intervalo de reinicio de créditos (días)",
                "tag": "credits"
            },
            {
                "key": "log_level",
                "value": "INFO",
                "description": "Nivel de logging",
                "tag": "logging"
            },
            {
                "key": "log_retention_days",
                "value": 90,
                "description": "Días de retención de logs",
                "tag": "logging"
            },
            {
                "key": "maintenance_mode",
                "value": False,
                "description": "Activar/desactivar modo mantenimiento",
                "tag": "system"
            },
            {
                "key": "api_version",
                "value": "1.0.0",
                "description": "Versión actual de la API",
                "tag": "system"
            },
            {
                "key": "enable_registration",
                "value": True,
                "description": "Activar/desactivar registro de usuarios",
                "tag": "features"
            },
            {
                "key": "enable_social_login",
                "value": True,
                "description": "Activar/desactivar login social",
                "tag": "features"
            },
            {
                "key": "disable_anonymous_users",
                "value": False,
                "description": "Desactivar usuarios anónimos",
                "tag": "features"
            },
            {
                "key": "disable_credits",
                "value": False,
                "description": "Desactivar sistema de créditos",
                "tag": "features"
            },
            {
                "key": "enable_payment_methods",
                "value": True,
                "description": "Activar métodos de pago",
                "tag": "features"
            },
            {
                "key": "enable_points",
                "value": True,
                "description": "Activar sistema de puntos",
                "tag": "features"
            },
            {
                "key": "enable_badges",
                "value": True,
                "description": "Activar insignias",
                "tag": "features"
            },
            {
                "key": "enable_coupons",
                "value": True,
                "description": "Activar cupones",
                "tag": "features"
            },
        ]

        for setting in settings_data:
            if not db.query(SiteSettings).filter(
                    SiteSettings.key == setting["key"]).first():
                db.add(
                    SiteSettings(key=setting["key"],
                                 value=json.dumps(setting["value"]),
                                 description=setting["description"],
                                 tag=setting["tag"]))

        # Usuarios iniciales
        users_data = [{
            "email": "admin@example.com",
            "username": "admin_user1",
            "password_hash": hash_password("admin123"),
            "subscription": subscriptionEnum.PREMIUM,
            "credits": 1000,
            "rol": "admin",
            "create_at": datetime.utcnow() - timedelta(days=40),
            "activo": True
        }, {
            "email": "user@example.com",
            "username": "user",
            "password_hash": hash_password("user123"),
            "subscription": subscriptionEnum.CORPORATE,
            "credits": 5000,
            "rol": "user",
            "create_at": datetime.utcnow() - timedelta(days=35),
            "activo": True
        }]

        users = []
        for user_data in users_data:
            if not db.query(User).filter(
                    User.email == user_data["email"]).first():
                user = User(**user_data)
                db.add(user)
                users.append(user)

        db.commit()  # Necesario para obtener los IDs de los usuarios

        # Orígenes permitidos
        origins = [
            "localhost:3000", "neptuno.app", "staging.neptuno.app",
            "api.neptuno.app", "admin.neptuno.app"
        ]
        for origin in origins:
            if not db.query(AllowedOrigin).filter(
                    AllowedOrigin.origin == origin).first():
                db.add(AllowedOrigin(origin=origin))

        # Sesiones anónimas
        anonymous_sessions = []
        for i in range(2):
            session_id = str(uuid.uuid4())
            session = GuestsSession(
                id=session_id,
                username=f"anon_user_{i+1}",
                credits=100 - (i * 15),
                create_at=datetime.utcnow() - timedelta(days=i * 2),
                ultima_actividad=datetime.utcnow() - timedelta(hours=i),
                last_ip=f"192.168.1.{100 + i}")
            db.add(session)
            anonymous_sessions.append(session)

        # Proveedores de pago
        payment_providers = [{
            "name": "STRIPE",
            "active": True
        }, {
            "name": "PayPal",
            "active": True
        }, {
            "name": "Transferencia bancaria",
            "active": False
        }, {
            "name": "Crypto",
            "active": True
        }]
        for provider in payment_providers:
            if not db.query(PaymentProvider).filter(
                    PaymentProvider.name == provider["name"]).first():
                db.add(PaymentProvider(**provider))

        # Transacciones de créditos
        transactions = [{
            "user_id": users[0].id,
            "user_type": "registered",
            "amount": -10,
            "transaction_type": "api_call",
            "description": "Llamada a API"
        }]

        for transaction in transactions:
            db.add(CreditTransaction(**transaction))

        # Logs de errores
        error_logs = [{
            "user_id": users[0].id,
            "user_type": "registered",
            "error_code": 400,
            "message": "Invalid request",
            "details": "Missing 'email'",
            "url": "/api/v1/users",
            "method": "POST",
            "ip_address": "192.168.1.100"
        }, {
            "session_id": anonymous_sessions[0].id,
            "user_type": "anonymous",
            "error_code": 429,
            "message": "Rate limit exceeded",
            "details": "Too many requests",
            "url": "/api/v1/process",
            "method": "POST",
            "ip_address": "192.168.1.101"
        }]

        for error in error_logs:
            db.add(ErrorLog(**error))

        # Integraciones
        integrations = [{
            "user_id":
            users[0].id,
            "name":
            "slack_notif",
            "webhook_url":
            "https://hooks.slack.com/services/XXX",
            "event_type":
            "credit_usage",
            "active":
            True,
            "last_triggered":
            datetime.utcnow() - timedelta(hours=1)
        }]

        for integration in integrations:
            db.add(Integration(**integration))

        # Logs de API
        api_logs = [{
            "user_id":
            users[0].id,
            "endpoint":
            "/api/v1/auth/login",
            "method":
            "POST",
            "status_code":
            200,
            "request_data":
            json.dumps({"email": "freemium1@example.com"}),
            "response_data":
            json.dumps({"token": "xxx.yyy.zzz"})
        }]

        for log in api_logs:
            db.add(APILog(**log))

        # Métodos de pago
        payment_methods = [{
            "user_id": users[0].id,
            "payment_type": "credit_card",
            "details": "VISA ending in 4242",
            "is_default": True
        }]
        for method in payment_methods:
            db.add(PaymentMethod(**method))

        # Tokens revocados
        revoked_tokens = [{
            "token": "expired.token.xxx",
            "revoked_at": datetime.utcnow() - timedelta(days=10),
            "user_id": users[0].id
        }]
        for token in revoked_tokens:
            db.add(RevokedToken(**token))

        # Tokens de reseteo de contraseña
        reset_tokens = [{
            "user_id": users[0].id,
            "token": "reset_abc123",
            "expires_at": datetime.utcnow() + timedelta(hours=1)
        }]
        for token in reset_tokens:
            db.add(PasswordResetToken(**token))

        # Tipos de cupones
        coupon_types = [{
            "name": "Bienvenida",
            "description": "Cupón para nuevos usuarios",
            "credits": 50,
            "active": True
        }, {
            "name": "FIDELIDAD",
            "description": "Cupón por lealtad",
            "credits": 100,
            "active": True
        }, {
            "name": "PROMOCION",
            "description": "Cupón promocional especial",
            "credits": 200,
            "active": True
        }, {
            "name": "EVENTO",
            "description": "Cupón para eventos",
            "credits": 75,
            "active": False
        }]
        coupon_type_objects = []
        for ct in coupon_types:
            if not db.query(CouponType).filter(
                    CouponType.name == ct["name"]).first():
                coupon_type = CouponType(**ct)
                db.add(coupon_type)
                coupon_type_objects.append(coupon_type)
        db.commit()

        # Cupones
        coupons = [{
            "coupon_type_id": coupon_type_objects[0].id,
            "unique_identifier": str(uuid.uuid4()),
            "name": str(uuid.uuid4()),
            "issued_at": datetime.utcnow() - timedelta(days=5),
            "expires_at": datetime.utcnow() + timedelta(days=25),
            "active": True,
            "status": "active",
            "user_id": users[0].id,
            "session_id": anonymous_sessions[0].id,
            "credits": 50
        }]
        for coupon in coupons:
            db.add(Coupon(**coupon))

        # Eventos de gamificación
        event_types = [{
            "name": "api_usage",
            "description": "Uso de la API",
            "points_per_event": 10
        }, {
            "name": "login",
            "description": "Inicio de sesión",
            "points_per_event": 5
        }, {
            "name": "purchase",
            "description": "Compra de créditos",
            "points_per_event": 50
        }, {
            "name": "error_report",
            "description": "Reporte de error",
            "points_per_event": 20
        }]
        event_type_objects = []
        for event in event_types:
            if not db.query(EventType).filter(
                    EventType.name == event["name"]).first():
                event_type = EventType(**event)
                db.add(event_type)
                event_type_objects.append(event_type)
        db.commit()

        # Insignias
        badges = [{
            "name": "Novato",
            "description": "Primer uso de API",
            "event_type_id": event_type_objects[0].id,
            "required_points": 10,
            "user_type": "both"
        }, {
            "name": "Experto",
            "description": "100 usos de API",
            "event_type_id": event_type_objects[0].id,
            "required_points": 100,
            "user_type": "both"
        }, {
            "name": "Comprador",
            "description": "Primera compra",
            "event_type_id": event_type_objects[2].id,
            "required_points": 50,
            "user_type": "registered"
        }, {
            "name": "Solucionador",
            "description": "Reporte de errores",
            "event_type_id": event_type_objects[3].id,
            "required_points": 40,
            "user_type": "registered"
        }]
        badge_objects = []
        for badge in badges:
            if not db.query(Badge).filter(Badge.name == badge["name"]).first():
                badge_obj = Badge(**badge)
                db.add(badge_obj)
                badge_objects.append(badge_obj)
        db.commit()

        # Eventos de gamificación
        gamification_events = [{
            "event_type_id":
            event_type_objects[0].id,
            "user_id":
            users[0].id,
            "timestamp":
            datetime.utcnow() - timedelta(days=1)
        }]
        for event in gamification_events:
            db.add(GamificationEvent(**event))

        # Puntos de gamificación de usuarios
        user_gamification_data = [{
            "user_id": users[0].id,
            "event_type_id": event_type_objects[0].id,
            "points": 10,
            "badge_id": badge_objects[0].id
        }]
        for ug in user_gamification_data:
            db.add(UserGamification(**ug))

        # Configuración inicial del marketplace
        if not db.query(SiteSettings).filter(
                SiteSettings.key == "enable_marketplace").first():
            db.add(
                SiteSettings(key="enable_marketplace",
                             value=json.dumps(True),
                             description="Habilitar/deshabilitar marketplace",
                             tag="marketplace"))

        # Categorías de ejemplo
        categories_data = [{
            "name": "Electrónica",
            "description": "Dispositivos electrónicos"
        }, {
            "name": "Libros",
            "description": "Libros físicos y digitales"
        }]
        categories = []
        for cat_data in categories_data:
            if not db.query(Category).filter(
                    Category.name == cat_data["name"]).first():
                category = Category(**cat_data)
                db.add(category)
                categories.append(category)
        db.commit()  # Necesario para obtener los IDs de las categorías

        # Productos de ejemplo
        products_data = [{
            "name": "Smartphone",
            "description": "Teléfono inteligente",
            "price": 299.99,
            "category_id": categories[0].id,
            "is_digital": False,
            "file_path": None
        }, {
            "name": "Ebook",
            "description": "Libro digital",
            "price": 9.99,
            "category_id": categories[1].id,
            "is_digital": True,
            "file_path": "/path/to/ebook.pdf"
        }]
        for prod_data in products_data:
            if not db.query(Product).filter(
                    Product.name == prod_data["name"]).first():
                db.add(Product(**prod_data))

        db.commit()
        print(
            "✅ Base de datos inicializada con datos de ejemplo en todas las tablas."
        )
    except Exception as e:
        db.rollback()
        print(f"❌ Error al cargar datos iniciales: {str(e)}")
        raise
    finally:
        db.close()


if __name__ == "__main__":
    print("Creando tablas en la base de datos...")
    init_db()
    print("Cargando datos iniciales...")
    init_settings_and_users()


# backend/services/payment_service.py
# Servicio para pagos y métodos de pago de usuarios
from sqlalchemy.orm import Session
from schemas.payment import PaymentMethodResponse
from models.payment_method import PaymentMethod
from models.user import User
from core.logging import configure_logging
from models.credit_transaction import CreditTransaction
from fastapi import HTTPException, status

logger = configure_logging()

class StripeSimulator:
    @staticmethod
    def create_payment_intent(amount: float, currency: str = "usd"):
        return {"id": "pi_simulated", "status": "succeeded"}

stripe = StripeSimulator()

def purchase_credits(db: Session, user_id: int, credits: int, payment_amount: float, payment_method: str = "stripe"):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")

        transaction = CreditTransaction(
            user_type="registered",  # ¡Añadimos esto explícitamente!
            user_id=user_id,
            amount=credits,
            transaction_type="purchase",
            payment_amount=payment_amount,
            payment_method=payment_method,
            payment_status="pending"
        )
        db.add(transaction)
        db.commit()
        db.refresh(transaction)

        payment_intent = stripe.create_payment_intent(payment_amount)
        if payment_intent["status"] == "succeeded":
            transaction.payment_status = "completed"
            user.credits += credits
            db.commit()
            logger.info(f"Compra de {credits} créditos completada para usuario {user_id}")
            return {"transaction_id": transaction.id, "credits_added": credits, "new_balance": user.credits}
        else:
            transaction.payment_status = "failed"
            db.commit()
            raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail="Error al procesar el pago")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al procesar compra de créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar compra")

def add_payment_method(db: Session, user_id: int, payment_type: str, details: str, is_default: bool = False):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        if is_default:
            db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id, PaymentMethod.is_default == True).update({"is_default": False})
        
        payment_method = PaymentMethod(
            user_id=user_id,
            payment_type=payment_type,
            details=details,
            is_default=is_default
        )
        db.add(payment_method)
        db.commit()
        logger.info(f"Método de pago añadido para usuario ID {user_id}: {payment_type}")
        return payment_method
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al añadir método de pago para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al añadir método de pago")

def get_payment_methods(db: Session, user_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        return db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id).all()
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al listar métodos de pago para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al listar métodos de pago")

def set_default_payment_method(db: Session, user_id: int, payment_method_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        payment_method = db.query(PaymentMethod).filter(PaymentMethod.id == payment_method_id, PaymentMethod.user_id == user_id).first()
        if not payment_method:
            raise HTTPException(status_code=404, detail="Método de pago no encontrado")
        
        db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id, PaymentMethod.is_default == True).update({"is_default": False})
        payment_method.is_default = True
        db.commit()
        logger.info(f"Método de pago ID {payment_method_id} establecido como predeterminado para usuario ID {user_id}")
        return payment_method
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al establecer método de pago predeterminado para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al establecer método de pago")

def get_credit_transactions(db: Session, user_id: int):
    try:
        return db.query(CreditTransaction).filter(CreditTransaction.user_id == user_id).all()
    except Exception as e:
        logger.error(f"Error al obtener transacciones de créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener transacciones")
    
    
def update_payment_method(db: Session, user_id: int, method_id: int, payment_type: str, details: str) -> PaymentMethodResponse:
    method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id, PaymentMethod.user_id == user_id).first()
    if not method:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado")
    method.payment_type = payment_type
    method.details = details
    db.commit()
    db.refresh(method)
    return PaymentMethodResponse.from_orm(method)

def delete_payment_method(db: Session, user_id: int, method_id: int):
    method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id, PaymentMethod.user_id == user_id).first()
    if not method:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado")
    if method.is_default:
        raise HTTPException(status_code=400, detail="No se puede eliminar el método de pago predeterminado")
    db.delete(method)
    db.commit()

    # backend/schemas/payment.py
# Esquemas Pydantic para pagos y métodos de pago

from pydantic import BaseModel
from datetime import datetime
from typing import Optional


class PurchaseRequest(BaseModel):
    credits: int
    payment_amount: float
    payment_method: Optional[str] = "stripe"

class PurchaseResponse(BaseModel):
    transaction_id: int
    credits_added: int
    new_balance: int

class PaymentMethodCreate(BaseModel):
    payment_type: str
    details: str
    is_default: bool = False

class PaymentMethodResponse(BaseModel):
    id: int
    payment_type: str
    details: str
    is_default: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class CreditTransactionResponse(BaseModel):
    id: int
    amount: int
    transaction_type: str
    payment_amount: Optional[float] = None
    payment_method: Optional[str] = None
    payment_status: Optional[str] = None
    timestamp: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class PaymentProviderBase(BaseModel):
    name: str
    active: bool = True

class PaymentProviderCreate(PaymentProviderBase):
    pass

class PaymentProviderResponse(PaymentProviderBase):
    id: int

    class Config:
        from_attributes = True

# backend/schemas/payment.py
# Esquemas Pydantic para pagos y métodos de pago

from pydantic import BaseModel
from datetime import datetime
from typing import Optional


class PurchaseRequest(BaseModel):
    credits: int
    payment_amount: float
    payment_method: Optional[str] = "stripe"

class PurchaseResponse(BaseModel):
    transaction_id: int
    credits_added: int
    new_balance: int

class PaymentMethodCreate(BaseModel):
    payment_type: str
    details: str
    is_default: bool = False

class PaymentMethodResponse(BaseModel):
    id: int
    payment_type: str
    details: str
    is_default: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class CreditTransactionResponse(BaseModel):
    id: int
    amount: int
    transaction_type: str
    payment_amount: Optional[float] = None
    payment_method: Optional[str] = None
    payment_status: Optional[str] = None
    timestamp: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class PaymentProviderBase(BaseModel):
    name: str
    active: bool = True

class PaymentProviderCreate(PaymentProviderBase):
    pass

class PaymentProviderResponse(PaymentProviderBase):
    id: int

    class Config:
        from_attributes = True

  # backend/models/credit_transaction.py
# Modelo de transacciones de crédito en la base de datos
from sqlalchemy import CheckConstraint, Column, Integer, String, ForeignKey, DateTime, Float
from models.user import Base
from datetime import datetime


class CreditTransaction(Base):
    __tablename__ = "credit_transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36),
                        ForeignKey("sesiones_anonimas.id"),
                        nullable=True)
    user_type = Column(String(20), nullable=False) #, default="anonymous") # "registered" o "anonymous"
    amount = Column(Integer, nullable=False)
    transaction_type = Column(String(50), nullable=False)
    description = Column(String(255), nullable=True)
    payment_amount = Column(Float, nullable=True)
    payment_method = Column(String(50), nullable=True)
    payment_status = Column(String(20), default="pending")
    timestamp = Column(DateTime, default=datetime.utcnow)

    # Restricción para asegurar que solo uno de user_id o session_id esté presente
    __table_args__ = (CheckConstraint(
        "(user_id IS NOT NULL AND session_id IS NULL AND user_type = 'registered') OR "
        "(user_id IS NULL AND session_id IS NOT NULL AND user_type = 'anonymous')",
        name="check_user_or_session"), )


# backend/models/payment_method.py
# Modelo de métodos de pago de usuario

from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from models.user import Base
from datetime import datetime

class PaymentMethod(Base):
    __tablename__ = "payment_methods"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=False)  # Vinculado a un usuario
    payment_type = Column(String(20), nullable=False)  # "credit_card", "paypal", "bank_transfer"
    details = Column(String(255), nullable=False)  # Datos encriptados (ej. últimos 4 dígitos, email PayPal)
    is_default = Column(Boolean, default=False)  # Método favorito
    created_at = Column(DateTime, default=datetime.utcnow)  # Fecha de creación
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)  # Última actualización

# backend/models/payment_provider.py
# Modelo de proveedores de pago

from sqlalchemy import Column, Integer, String, Boolean
from models.user import Base

class PaymentProvider(Base):
    __tablename__ = "payment_providers"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "Stripe", "Paypal"
    active = Column(Boolean, default=True)  # Si está activo o no

# backend/api/v1/transaction/payments.py
# Endpoints para pagos y métodos de pago (v1)
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from services.payment_service import add_payment_method, delete_payment_method, get_credit_transactions, get_payment_methods, purchase_credits, set_default_payment_method, update_payment_method
from core.database import get_db
from core.logging import configure_logging
from schemas.payment import CreditTransactionResponse, PurchaseRequest, PaymentMethodCreate, PaymentMethodResponse, PurchaseResponse

router = APIRouter(tags=["payments"])

logger = configure_logging()


@router.post("/purchase", response_model=PurchaseResponse)
async def buy_credits(request: PurchaseRequest,
                      user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden comprar créditos")
    return purchase_credits(db, int(user.user_id), request.credits,
                            request.payment_amount, request.payment_method)


@router.post("/methods", response_model=PaymentMethodResponse)
def add_method(method: PaymentMethodCreate,
               user: UserContext = Depends(get_user_context),
               db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden añadir métodos de pago")
    return add_payment_method(db, int(user.user_id), method.payment_type,
                              method.details, method.is_default)


@router.get("/methods", response_model=list[PaymentMethodResponse])
def list_methods(user: UserContext = Depends(get_user_context),
                 db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden ver sus métodos de pago")
    return get_payment_methods(db, int(user.user_id))


@router.put("/methods/{method_id}/default",
            response_model=PaymentMethodResponse)
def set_default(method_id: int,
                user: UserContext = Depends(get_user_context),
                db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail=
            "Solo usuarios registrados pueden establecer un método de pago por defecto"
        )
    return set_default_payment_method(db, int(user.user_id), method_id)


@router.get("/transactions", response_model=list[CreditTransactionResponse])
def list_transactions(user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden ver sus transacciones")
    return get_credit_transactions(db, int(user.user_id))


@router.put("/methods/{method_id}", response_model=PaymentMethodResponse)
def update_method(
        method_id: int,
        method: PaymentMethodCreate,
        user: UserContext = Depends(get_user_context),
        db: Session = Depends(get_db),
):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden actualizar métodos de pago"
        )
    return update_payment_method(db, int(user.user_id), method_id,
                                 method.payment_type, method.details)


@router.delete("/methods/{method_id}")
def delete_method(
        method_id: int,
        user: UserContext = Depends(get_user_context),
        db: Session = Depends(get_db),
):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden eliminar métodos de pago")
    delete_payment_method(db, int(user.user_id), method_id)
    return {"message": "Método de pago eliminado"}


# backend/api/v1/transaction/payment_providers.py
# Endpoints para gestión de proveedores de pago (v1)

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.payment_provider_service import (
    create_payment_provider, get_payment_providers, update_payment_provider, delete_payment_provider
)
from schemas.payment import PaymentProviderCreate, PaymentProviderResponse
from typing import List

router = APIRouter(tags=["Payment Providers"])

@router.get("/", response_model=List[PaymentProviderResponse])
def get_providers(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.user_type != "registered" and user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Acceso no autorizado")
    return get_payment_providers(db)

@router.post("/", response_model=PaymentProviderResponse, status_code=status.HTTP_201_CREATED)
def create_provider(provider_data: PaymentProviderCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Se requieren privilegios de administrador")
    return create_payment_provider(db, provider_data)

@router.put("/{provider_id}", response_model=PaymentProviderResponse)
def update_provider(provider_id: int, provider_update: PaymentProviderCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Se requieren privilegios de administrador")
    return update_payment_provider(db, provider_id, provider_update)

@router.delete("/{provider_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_provider(provider_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Se requieren privilegios de administrador")
    delete_payment_provider(db, provider_id)
    return {"detail": "Proveedor eliminado exitosamente"}

# backend/api/v1/transactions/credit_transactions.py
# Endpoints para logs de transacciones de crédito (v1)
from datetime import datetime, timedelta
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy import func
from sqlalchemy.orm import Session
from typing import List
from models.user import User, subscriptionEnum
from models.credit_transaction import CreditTransaction
from schemas.credit_transaction import CreditTransactionResponse
from dependencies.auth import get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Transactions"])


@router.get("/", response_model=dict)
def get_credit_transactions(page: int = Query(1, ge=1),
                            limit: int = Query(10, ge=1, le=100),
                            user=Depends(get_user_context),
                            db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo los administradores pueden acceder a este recurso")

    offset = (page - 1) * limit
    query = db.query(CreditTransaction)
    total_items = query.count()
    transactions = query.offset(offset).limit(limit).all()

    # Convertir los modelos SQLAlchemy a esquemas Pydantic
    transactions_data = [
        CreditTransactionResponse.from_orm(t) for t in transactions
    ]

    return {
        "data": transactions_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }
    

@router.get("/kpis")
def get_saas_kpis(user=Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo administradores")

    now = datetime.utcnow()
    last_30_days = now - timedelta(days=30)
    last_7_days = now - timedelta(days=7)
    last_60_days = now - timedelta(days=60)
    current_month = now.month
    current_year = now.year

    # Usuarios
    total_users = db.query(User).count()
    active_users_30d = db.query(User).filter(User.last_login >= last_30_days).count()
    new_users_month = db.query(User).filter(
        func.extract('month', User.create_at) == current_month,
        func.extract('year', User.create_at) == current_year
    ).count()
    paying_users = db.query(User).filter(User.subscription != subscriptionEnum.FREEMIUM).count()

    # Ingresos
    payment_tx = db.query(CreditTransaction).filter(
        CreditTransaction.payment_status == "success",
        CreditTransaction.transaction_type == "payment",
        CreditTransaction.user_type == "registered"
    )
    monthly_payments = payment_tx.filter(
        func.extract('month', CreditTransaction.timestamp) == current_month,
        func.extract('year', CreditTransaction.timestamp) == current_year
    ).all()
    mrr = sum(tx.payment_amount for tx in monthly_payments if tx.payment_amount) or 0
    arr = mrr * 12
    total_revenue = sum(tx.payment_amount for tx in payment_tx.all() if tx.payment_amount) or 0

    # ARPU y LTV
    arpu = mrr / paying_users if paying_users else 0
    churned_users = db.query(User).filter(
        User.subscription.in_([subscriptionEnum.PREMIUM, subscriptionEnum.CORPORATE]),
        User.last_login < last_60_days
    ).count()
    churn_rate = churned_users / paying_users if paying_users else 0
    ltv = arpu / churn_rate if churn_rate else 0

    # Conversión
    conversions = db.query(User).filter(
        User.subscription.in_([subscriptionEnum.PREMIUM, subscriptionEnum.CORPORATE]),
        func.extract('month', User.create_at) == current_month
    ).count()
    conversion_rate = conversions / total_users if total_users else 0

    # Créditos
    total_credits = db.query(func.sum(User.credits)).scalar() or 0
    credits_used = db.query(CreditTransaction).filter(
        CreditTransaction.transaction_type == "usage"
    ).count()

    # DAU/WAU/MAU
    dau = db.query(User).filter(User.last_login >= now - timedelta(days=1)).count()
    wau = db.query(User).filter(User.last_login >= last_7_days).count()
    mau = active_users_30d

    return {
        "total_users": total_users,
        "active_users_30d": active_users_30d,
        "new_users_month": new_users_month,
        "paying_users": paying_users,
        "mrr": round(mrr, 2),
        "arr": round(arr, 2),
        "total_revenue": round(total_revenue, 2),
        "arpu": round(arpu, 2),
        "ltv": round(ltv, 2),
        "churn_rate": round(churn_rate, 4),
        "churned_users": churned_users,
        "conversion_rate": round(conversion_rate, 4),
        "total_credits": total_credits,
        "credits_used": credits_used,
        "dau": dau,
        "wau": wau,
        "mau": mau
    }


# backend/api/v1/config/site_settings.py
# Endpoints para configuración y orígenes permitidos (CORS)
from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from schemas.site_settings import SiteSettingResponse
from services.origin_service import add_allowed_origin, delete_allowed_origin
from models.user import User
from dependencies.auth import UserContext, get_user_context
from services.settings_service import get_all_settings, set_setting, update_setting, get_setting
from core.database import get_db
from core.logging import configure_logging
from pydantic import BaseModel
import json

router = APIRouter(tags=["site_settings"])

logger = configure_logging()


class AddOriginRequest(BaseModel):
    origin: str


@router.post("/allowed-origins")
async def add_origin(request: AddOriginRequest,
                     user: UserContext = Depends(get_user_context),
                     db: Session = Depends(get_db)):
    if not get_setting(db, "allowed_origins"):
        raise HTTPException(status_code=400, detail="CORS no está habilitado")
    return add_allowed_origin(db, request.origin, user.user_id)


@router.delete("/allowed-origins/{origin}")
async def remove_origin(origin: str,
                        user: UserContext = Depends(get_user_context),
                        db: Session = Depends(get_db)):
    if not get_setting(db, "allowed_origins"):
        raise HTTPException(status_code=400, detail="CORS no está habilitado")
    return delete_allowed_origin(db, origin, user.user_id)


@router.get("/admin/config", response_model=List[SiteSettingResponse])
def get_admin_config(user=Depends(get_user_context),
                     db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo administradores")
    return get_all_settings(db, user.user_id)


class UpdateConfigRequest(BaseModel):
    key: str
    value: dict | list | int | str
    description: str | None = None


@router.post("/admin/config")
async def update_config(request: UpdateConfigRequest,
                        user: UserContext = Depends(get_user_context),
                        db: Session = Depends(get_db)):
    return set_setting(db, request.key, request.value, user.user_id,
                       request.description)


@router.put("/{key}")
def update_site_setting(key: str,
                        value: str,
                        description: str = None,
                        user: UserContext = Depends(get_user_context),
                        db: Session = Depends(get_db)):
    if user.user_type != "registered" or not db.query(User).filter(
            User.id == user.user_id, User.rol == "admin").first():
        raise HTTPException(status_code=403, detail="Solo administradores")
    return update_setting(db, user.user_id, key, value, description)


@router.get("/{key}")
def get_site_setting(key: str, db: Session = Depends(get_db)):
    return get_setting(db, key)



Te voy a dar un truco: fijate en como se realiza la transacción de comprar creditos en el dashboard de user, ya que hacer un checkout es algo parecido
y es una transacción del usuario tambien pero en vez de creditos de dinero con un producto.

Recuerda tambien ser consistente en la navbar y los archivos importantes.

En cuanto al desarrollo tecnico a la hora de generar el codifo fuente de los cambios solicitados, debes seguir estas indicaciones:los criterios a seguir son: usabilidad, legibilidad, jerarquia de contenidos, facilidad, orden, sentido comun, visualizaciónreutiliza elementos visuales y componentes visuales / UI a la hora de programar, manteniendo la robusted y solidez del codigo fuente actual que ya has estudiado.
haz tu codigo fuente modular y escalable
no rompas el desarrollo actual
recuerda organizar de forma modular y escalable las carpetas y ficheros de la app que crees nuevos
NO ROMPAS el proyecto actual,estamos ampliando no cambiando.

Si necesitas más ayuda o necesitas código adicional que ver, no dudes en decírmelo. A ver como te desenvuelves con mi software.Se que es muchiiiisima información, por favor leela toda con detenimiento. Si es mucho separa tu respuesta en partes. Solicitame los archivos que necesites ver. Respeta la logica actual para no romper ningun servicio activo. 
Es importante esta parte que salga bien, tomate tu tiempo.
Pideme los archivos que necesites ver para una mejor implantación.Para la parte del frontend, al ser en nextjs, ten en mente la reutilización y reuso de componentes reutilizables y modulares.Recuerda generar codigo completo.Solicita cualquier archivo que necesites.Ya puedes proceder paso a paso con tu respuesta.

en cuanto a la parte especifica que te he pedido de la implantacion del marketplace en neptuno:

por favor revisa todos los archivos para que los modelos, relaciones, typados, schemas, servicios, auths, rutas y toda la logica que has implantado nueva
este alineada con los estandares de reutilizacion, modularidad, robusted y sobre todo robusted otra vez para que sea estable, revisalo todo el flujo bien y su logica,
y ademas por finalizar, visualmente debe continuar la guia de estilos actual.



