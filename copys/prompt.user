Estas preparado ya? 

Neptuno es todo lo que ya sabes pero tiene algo que lo hace bestial en cuanto a engagement:
todas las Funcionalidades estan disponibles para usuarios anonimos (guests) o sea Usuarios
que no se han registrado pueden tener puntos, creditos de cortesia, ganar insignias,etc...

esta "magia" sucede porque el front utiliza localstorage tanto para guest como para registered
(el campo user_type), para evitar usar cookies y ganar velocidad, al usar local storage manejamos
invitados y registrados.

esta magia explica algo que quizas no te has preguntado aun:
veras que el tipado en el front del usuario tiene user_id y session_id, bien: estan los dos porque
se dan escenarios que el usuario invitado no tiene user_id pero si tiene session_id o viceversa cuando
es anonimo (antes de hacer login o registrarse o volver), es la manera que esta implantando ahora
quizas se cambie mas adelante, por ahora es asi como Funcionalidades

Esta "curiosidad" hace especial a neptuno porque los leads desde que entran pueden interactuar
con la gamificación y el auth aqui para los tokens etc y la info que guardamos en localstorage
que luego influye en toda la logica de navbar etc esta aqui metida

por favor no lo olvides, esto te lo queria comentar explicitamente, porque lo que quiero que hagamos es...(redoble de tambores)

###  ¡Vamos a Unificar modelos de usuarios guest y user en **Neptuno**!

El objetivo es unificar los modelos User (usuarios registrados) y GuestsSession (usuarios anónimos) en un solo modelo User, 
manteniendo la lógica actual como respaldo hasta que la unificación esté completamente probada.

Unificar los modelos de usuarios anónimos (guest) y registrados (user) en un solo modelo es un cambio importante. 
Debemos hacerlo con la precisión de un cirujano para hacerlo sin romper la aplicación
Tienes todo el codigo fuente de backend y frontend para consultarlo, pero te voy a pasar todos los archivos implicados
para que realices un IMPLANTACIÓN TOTAL.


Actualizaremos las funciones donde sea necesario para usar únicamente user.user_id como identificador, 
ya que todos los usuarios (registrados y anónimos) tendran un id en la tabla usuarios.

Tendremos que eliminar todas las distinción entre user_id y session_id, usando solo user_id para referenciar al modelo unificado de User.

Revisa todos los archivos (te los pasare mas adelante para que los adaptes todos sin excepcion) para asegurar que UserContext se 
construya correctamente con el modelo unificado.

Asegúrate de que el frontend gestione consistentemente los usuarios independientemente del tipo de usuario.


Consideraciones
No romper la aplicación: Implementa esto en paralelo, dejando la lógica actual como fallback hasta que la unificación esté completa.
Permisos: Asegúrate de que las acciones restringidas (ej. admin) verifiquen type y otros campos relevantes.

Aqui tienes todos los archivos implicados

# backend/api/v1/anonymous_sessions.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
# from models.guests import GuestsSession
from schemas.anonymous_session import GuestsSessionResponse 
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Sessions"])

@router.get("/", response_model=dict)
def get_anonymous_sessions(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(GuestsSession)
    total_items = query.count()
    sessions = query.offset(offset).limit(limit).all()

    sessions_data = [GuestsSessionResponse.from_orm(session) for session in sessions]
    
    return {
        "data": sessions_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

@router.get("/credits", response_model=dict)
async def get_anonymous_credits(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.user_type != "anonymous":
        raise HTTPException(status_code=403, detail="Solo para usuarios anónimos")
    session = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Sesión no encontrada")
    return {"credits": session.credits}

#backend/api/v1/users.py
from math import ceil
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from models.user import User
from schemas.user import UserResponse, UpdateProfileRequest
from services.user_service import get_user_info, update_user, delete_user, list_users
from core.database import get_db
from dependencies.auth import UserContext, get_user_context
from core.logging import configure_logging

router = APIRouter(tags=["users"])

logger = configure_logging()

@router.get("/me", response_model=UserResponse)
def get_me(user: UserContext = Depends(get_user_context),
           db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(status_code=403,
                            detail="Solo usuarios registrados")
    return get_user_info(db, int(user.user_id))


@router.put("/me", response_model=UserResponse)
def update_me(request: UpdateProfileRequest,
              user: UserContext = Depends(get_user_context),
              db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(status_code=403,
                            detail="Solo usuarios registrados")
    return update_user(db, int(user.user_id), request.email, request.username,
                       request.ciudad, request.website)


@router.delete("/me", response_model=dict)
def delete_me(user: UserContext = Depends(get_user_context),
              db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(status_code=403,
                            detail="Solo usuarios registrados")
    return delete_user(db, int(user.user_id))


@router.get("/admin/users", response_model=dict)
def get_all_users(page: int = Query(1, ge=1),
                  limit: int = Query(10, ge=1, le=100),
                  user=Depends(get_user_context),
                  db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden ver la lista de usuarios")

    offset = (page - 1) * limit
    query = db.query(User)
    total_items = query.count()
    users = query.offset(offset).limit(limit).all()

    # Convertimos los usuarios a esquemas Pydantic
    users_data = [UserResponse.model_validate(user) for user in users]

    return {
        "data": users_data,
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }


@router.get("/{user_id}", response_model=UserResponse)
def get_user(user_id: int,
             user: UserContext = Depends(get_user_context),
             db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden acceder a esta información")
    user_data = get_user_info(db, user_id)
    if not user_data:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return user_data


@router.put("/{user_id}", response_model=UserResponse)
def update_user_by_id(user_id: int,
                      request: UpdateProfileRequest,
                      user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden actualizar usuarios")
    updated_user = update_user(db,
                               user_id,
                               email=request.email,
                               username=request.username,
                               ciudad=request.ciudad,
                               website=request.website)
    return updated_user


@router.delete("/{user_id}", response_model=dict)
def delete_user_by_id(user_id: int,
                      user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden eliminar usuarios")
    result = delete_user(db, user_id)
    return result


# backend/core/security.py
# Usar OAuth2 con Password Flow para autenticación segur

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from oauthlib.oauth2 import WebApplicationClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jwt import encode, decode, PyJWTError
from os import getenv
from datetime import datetime, timedelta
from typing import Optional
from core.logging import configure_logging
from core.database import get_db
from services.settings_service import get_setting

logger = configure_logging()

# Configuración de OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/v1/auth/token")
google_client = WebApplicationClient(getenv("GOOGLE_CLIENT_ID"))
meta_client = WebApplicationClient(getenv("META_CLIENT_ID"))

# Configuración de hash de contraseñas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_token(user_id: str, user_type: str = "registered"):
    payload = {
        "sub": str(user_id),
        "type": user_type,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, getenv("SECRET_KEY"), algorithm="HS256")

def decode_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, getenv("SECRET_KEY"), algorithms=["HS256"])
        # Validación adicional del payload
        if not payload.get("sub") or not payload.get("type"):
            logger.warning(f"Token inválido: falta sub o type en el payload")
            return None
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token expirado")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Token inválido: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Error inesperado al decodificar token: {str(e)}")
        return None

def create_access_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "token_expiration") or "3600")
        if expiration < 300:  # Mínimo 5 minutos
            expiration = 3600
            logger.warning("Token expiration too low, using default 1h")
    except Exception as e:
        logger.error(f"Error token_expiration: {str(e)}")
        expiration = 3600
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

def create_refresh_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "refresh_token_expiration") or "604800")
        if expiration < 86400:  # Mínimo 1 día
            expiration = 604800
            logger.warning("Refresh token expiration too low, using default 7d")
    except Exception as e:
        logger.error(f"Error refresh_token_expiration: {str(e)}")
        expiration = 604800
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")


def create_refresh_token(data: dict):
    db = next(get_db())
    expiration_str = get_setting(db, "refresh_token_expiration") or "604800"  # Valor por defecto: 7 días
    try:
        expiration = int(str(expiration_str))  # Convertir a cadena primero y luego a entero
    except ValueError:
        logger.error(f"Valor inválido para refresh_token_expiration: {expiration_str}")
        expiration = 604800  # Valor por defecto si falla
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

    
def get_oauth2_redirect_url(provider: str) -> str:
    if provider == "google":
        return google_client.prepare_request_uri(
            "https://accounts.google.com/o/oauth2/v2/auth",
            redirect_uri=getenv("GOOGLE_REDIRECT_URI"),
            scope=["openid", "email", "profile"]
        )
    elif provider == "meta":
        return meta_client.prepare_request_uri(
            "https://www.facebook.com/v13.0/dialog/oauth",
            redirect_uri=getenv("META_REDIRECT_URI"),
            scope=["email"]
        )
    raise ValueError("Proveedor no soportado")

# backend/dependencies/auth.py
# Módulo de dependencias de autenticación.
# backend/dependencies/auth.py
from models.coupon_type import CouponType
from fastapi import Depends, HTTPException, Request
from sqlalchemy.orm import Session
from core.database import get_db
from models.user import User
# from models.guests import GuestsSession
from models.token import RevokedToken
from core.security import decode_token
from core.logging import configure_logging
from services.coupon_service import create_coupon
from schemas.coupon import CouponCreate
from uuid import uuid4
from datetime import datetime
from pydantic import BaseModel
from fastapi import Response
import random
import string

logger = configure_logging()

class UserContext(BaseModel):
    user_id: str
    email: str
    username: str
    user_type: str  # "registered" o "anonymous"
    subscription: str
    credits: int
    rol: str
    session_id: str | None = None

    class Config:
        from_attributes = True

def generate_unique_username(db: Session) -> str:
    while True:
        random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        username = f"Guest_{random_chars}"
        if not db.query(GuestsSession).filter(GuestsSession.username == username).first():
            return username

async def get_user_context(request: Request, response: Response, db: Session = Depends(get_db)):
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
    session_id = request.headers.get("X-Session-ID")  # Leer de header en lugar de cookie
    client_ip = request.client.host
    logger.info(f"Procesando solicitud: token={bool(token)}, session_id={session_id}, ip={client_ip}")

    try:
        if token:
            # Lógica para usuarios registrados (sin cambios)
            if db.query(RevokedToken).filter(RevokedToken.token == token).first():
                logger.warning(f"Intento de uso de token revocado desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token revocado")
            payload = decode_token(token)
            if not payload or payload.get("type") != "access":
                logger.error(f"Token inválido recibido desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token inválido o no es de acceso")
            user = db.query(User).filter(User.id == int(payload["sub"])).first()
            if not user:
                logger.error(f"Usuario no encontrado para token desde IP {client_ip}")
                raise HTTPException(status_code=404, detail="Usuario no encontrado")
            if not user.activo:
                logger.warning(f"Intento de acceso con usuario inactivo ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=403, detail="Usuario inactivo")
            if user.token_valid_until and user.token_valid_until < datetime.utcnow():
                logger.warning(f"Token expirado manualmente para usuario ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token no válido")
            
            user.last_ip = client_ip
            user.last_login = datetime.utcnow()
            db.commit()
            logger.info(f"Usuario registrado ID {user.id} autenticado desde IP {client_ip}")
            return UserContext(
                user_type="registered",
                user_id=str(user.id),
                email=user.email,
                username=user.username,
                credits=user.credits,
                subscription=user.subscription.value,
                rol=user.rol
            )

        if not session_id:
            logger.info("No hay session_id en header, creando nueva sesión anónima")
            session_id = str(uuid4())
            username = generate_unique_username(db)  # Generar apodo único
            new_session = GuestsSession(
                id=session_id,
                username=username,  # Asignar el apodo
                credits=10,
                create_at=datetime.utcnow(),
                ultima_actividad=datetime.utcnow(),
                last_ip=client_ip
            )
            db.add(new_session)
            db.commit()

            # Crear cupón de bienvenida
            coupon_type = db.query(CouponType).filter(CouponType.name == "Bienvenida").first()
            if not coupon_type:
                logger.error("Tipo de cupón 'Bienvenida' no encontrado")
                raise HTTPException(status_code=500, detail="Tipo de cupón 'Bienvenida' no encontrado")

            coupon_data = CouponCreate(
                name="Bienvenida",
                description="Cupón de bienvenida para usuarios anónimos",
                credits=5,
                active=True,
                session_id=session_id,
                user_id=session_id,
                expires_at=None,
                issued_at=datetime.utcnow(),
                redeemed_at=None,
                status="active",
                unique_identifier=f"WELCOME-{session_id[:8]}",
                coupon_type_id=coupon_type.id  # Asignar el ID del tipo de cupón
            )
            create_coupon(db, coupon_data, user_id=None, session_id=session_id) 
            logger.info(f"Cupón de bienvenida creado para sesión {session_id}")

        
            logger.info(f"Nueva sesión anónima creada ID {session_id} con username {username} desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session_id,
                email="anonymous@example.com",
                username=username,  # Usar el apodo generado
                credits=10,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )
        else:
            logger.info(f"Buscando sesión anónima con ID {session_id} desde header")
            session = db.query(GuestsSession).filter(GuestsSession.id == session_id).first()
            if not session:
                logger.warning(f"Sesión anónima inválida ID {session_id} desde IP {client_ip}")
                raise HTTPException(status_code=400, detail="Sesión anónima inválida")
            
            session.last_ip = client_ip
            session.ultima_actividad = datetime.utcnow()
            db.commit()
            logger.info(f"Sesión anónima ID {session_id} actualizada desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session.id,
                email="anonymous@example.com",
                username=session.username,  # Usar el username de la sesión
                credits=session.credits,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )

        logger.error(f"No autorizado: sin token ni sesión válida desde IP {client_ip}")
        raise HTTPException(status_code=401, detail="No autorizado")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en get_user_context desde IP {client_ip}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar la autenticación")

# backend/models/user.py
# Módulo del modelo de usuario.
from datetime import datetime
from sqlalchemy import Column, Float, Integer, String, DateTime, Boolean, Enum
from core.database import Base
from sqlalchemy.orm import relationship
import enum

class subscriptionEnum(enum.Enum):
    FREEMIUM = "freemium"
    PREMIUM = "premium"
    CORPORATE = "corporate"

class User(Base):
    __tablename__ = "usuarios"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    username = Column(String(50), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=True)  # Nullable para terceros
    auth_provider = Column(String(20), nullable=True)  # "local", "google", "meta", etc.
    provider_id = Column(String(255), nullable=True)  # ID único del proveedor
    rol = Column(String(20), default="user")  # "user" o "admin"
    activo = Column(Boolean, default=True)  # Estado de la cuenta
    subscription = Column(Enum(subscriptionEnum), default=subscriptionEnum.FREEMIUM)  # subscription de suscripción
    #ciudad = Column(String(100), nullable=True)  # Para perfil
    website = Column(String(255), nullable=True)  # URL de avatar o perfil
    credits = Column(Integer, default=10)  # Créditos disponibles
    #create_at = Column(DateTime, default=datetime.utcnow)  # Fecha de registro
    renewal = Column(DateTime, nullable=True)  # Última renovación de créditos
    last_ip = Column(String(45), nullable=True)  # Última IP conocida (IPv4/IPv6)
    last_login = Column(DateTime, nullable=True)  # Último inicio de sesión
    token_valid_until = Column(DateTime, nullable=True)  # Fecha de expiración del token actual
    
    
    gamification_events = relationship("GamificationEvent", back_populates="user")
    gamification = relationship("UserGamification", back_populates="user")
    

    # Añadir relaciones inversas en los modelos existentes
    coupons = relationship("Coupon", foreign_keys="Coupon.user_id", back_populates="user")

    
      # 📌 Ubicación y demografía
    #pais = Column(String(100), nullable=True)  
    ciudad = Column(String(100), nullable=True)  
    #zona_horaria = Column(String(50), nullable=True)  
    #idioma = Column(String(20), nullable=True)  

    # 📌 Datos de empresa
    #empresa = Column(String(255), nullable=True)  
    #industria = Column(String(100), nullable=True)  
    #tamaño_empresa = Column(String(50), nullable=True)  # Startup, PYME, Enterprise
    #num_empleados = Column(Integer, nullable=True)  
    #ingresos_anuales = Column(Float, nullable=True)  
    #presupuesto_estimado = Column(Float, nullable=True)  

    # 📌 Datos técnicos y uso
    #tecnologias_usadas = Column(String(255), nullable=True)  
    #nivel_digitalizacion = Column(String(50), nullable=True)  
    #dispositivo_frecuente = Column(String(50), nullable=True)  
    #engagement = Column(Float, nullable=True)  # % de funciones utilizadas  
    #tiempo_en_plataforma = Column(Integer, nullable=True)  # Minutos activos por mes  

    # 📌 Ciclo de vida
    create_at = Column(DateTime, default=datetime.utcnow)  
    #ultima_actividad = Column(DateTime, nullable=True)  
    #historial_pagos = Column(String(255), nullable=True)  
    #probabilidad_churn = Column(Float, nullable=True)  

    # 📌 Datos comerciales
    #volumen_transacciones = Column(Float, nullable=True)  
    #origen_lead = Column(String(100), nullable=True)  
    #clientes_referidos = Column(Integer, nullable=True)  

    # Añadir relaciones inversas en los modelos existentes
    coupons = relationship("Coupon", foreign_keys="Coupon.user_id", back_populates="user")
    

# backend/models/guests.py
# Módulo del modelo de sesión para usuarios anonimos que no estan identificados.
from sqlalchemy import Column, String, Integer, DateTime, Float
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime

class GuestsSession(Base):
    __tablename__ = "sesiones_anonimas"
    
    id = Column(String(36), primary_key=True, index=True)  
    username = Column(String(50), unique=True, nullable=False)  
    credits = Column(Integer, default=10)  
    create_at = Column(DateTime, default=datetime.utcnow)  
    ultima_actividad = Column(DateTime, nullable=True)  
    last_ip = Column(String(45), nullable=True)  

    # 📌 Información Inferida
    #probable_pais = Column(String(100), nullable=True)  
    #probable_industria = Column(String(100), nullable=True)  
    #probable_num_empleados = Column(Integer, nullable=True)  
    #probable_ingresos_anuales = Column(Float, nullable=True)  
    #probable_tecnologias_usadas = Column(String(255), nullable=True)  
    #engagement_anonimo = Column(Float, nullable=True)  # % de uso en la sesión  

    # Relación con gamificación
    gamification_events = relationship("GamificationEvent", back_populates="session")
    gamification = relationship("UserGamification", back_populates="session")


    coupons = relationship("Coupon", foreign_keys="Coupon.session_id", back_populates="session")
    
# backend/schemas/user.py
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class RegisterRequest(BaseModel):
    email: EmailStr
    username: str
    password: str
    ciudad: Optional[str] = None
    website: Optional[str] = None

class UpdateProfileRequest(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    ciudad: Optional[str] = None
    website: Optional[str] = None

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    username: str
    rol: str
    activo: bool
    subscription: str  # Esto funciona porque Pydantic automáticamente usa el .value de los Enum
    ciudad: Optional[str] = None
    website: Optional[str] = None
    credits: int
    create_at: datetime
    last_ip: Optional[str] = None

    class Config:
        from_attributes = True  # Esto reemplaza a orm_mode = True en Pydantic v2


#backend/schemas/auth.py
from pydantic import BaseModel, EmailStr

# Respuesta de tokens tras autenticación exitosa
class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str

# Solicitud para refrescar un token
class RefreshTokenRequest(BaseModel):
    refresh_token: str

# Solicitud para restablecer contraseña
class PasswordResetRequest(BaseModel):
    email: EmailStr
    
class PasswordResetConfirm(BaseModel):
    token: str
    new_password: str

class LoginRequest(BaseModel):
    username: str  # En este caso, es el email
    password: str
    
class ChangePasswordRequest(BaseModel):
    current_password: str
    new_password: str

# backend/api/v1/anonymous_sessions.py
from pydantic import BaseModel
from datetime import datetime

class GuestsSessionBase(BaseModel):
    id: str
    username: str  # Nuevo campo
    credits: int
    create_at: datetime
    ultima_actividad: datetime | None
    last_ip: str | None

class GuestsSessionResponse(GuestsSessionBase):
    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

// src/lib/auth/context.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge, Coupon } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // Añadimos gamificación al contexto
  coupons: Coupon[];
  setCredits: (credits: number) => void; // Añadido
  setCoupons: (coupons: Coupon[]) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  setGamification: (gamification: Gamification) => void; // Añadido
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}



const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(10); // Valor por defecto para anónimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificación
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const [coupons, setCoupons] = useState<Coupon[]>([]);


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<any>("/info"); // Endpoint para obtener info del usuario
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
          } else {
            setUser(null);
            setCredits(0);
          }

          // Obtener datos de gamificación
          const gamificationRes = await fetchAPI<any[]>("/v1/gamification/me");
          if (gamificationRes.data) {
            const totalPoints = gamificationRes.data.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationRes.data.map(g => g.badge).filter(Boolean) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }

          // Obtener cupones del usuario
          const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/me");
          setCoupons(couponsRes.data || []);
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        setCoupons([]);
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesión
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesión
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operación
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits, gamification, coupons, setCoupons, setGamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// src/lib/api.ts
import axios, { AxiosRequestConfig, AxiosResponse, AxiosError, AxiosInstance } from "axios";
import { HTTPValidationError, FetchResponse, RegisterRequest, TokenResponse, UpdateProfileRequest, User, ValidationError } from "./types";

// Extender AxiosRequestConfig para incluir _retry
interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  _retry?: boolean;
}

// Crear una instancia personalizada de Axios
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Variables para manejar el estado de refresco
let isRefreshing = false;
let failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

// Agregar el interceptor de solicitudes
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("accessToken");
  const sessionId = localStorage.getItem("session_id");
  if (token) {
    config.headers["Authorization"] = `Bearer ${token}`;
  } else if (sessionId) {
    config.headers["X-Session-ID"] = sessionId;
  }
  return config;
});

const logRequest = (method: string, url: string, status: number, data?: unknown) => {
  console.log(`[${method}] ${url} - Status: ${status}`, data ?? "");
};

const fetchAPI = async <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  contentType: string = "application/json"
): Promise<FetchResponse<T>> => {
  console.log(`Iniciando fetchAPI para ${endpoint}`);

  const config: CustomAxiosRequestConfig = {
    ...options,
    url: endpoint, // baseURL ya está configurado en la instancia
    headers: {
      "Content-Type": contentType,
      ...options.headers,
    },
    data: options.data,
  };

  // Convertir datos a formato x-www-form-urlencoded si es necesario
  if (contentType === "application/x-www-form-urlencoded" && config.data) {
    const formData = new URLSearchParams();
    Object.entries(config.data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });
    config.data = formData;
  }

  const normalizeResponse = (
    response: AxiosResponse<T> | undefined,
    error: unknown
  ): FetchResponse<T> => {
    if (response && response.status >= 200 && response.status < 300) {
      return { data: response.data, error: null };
    }

    if (axios.isAxiosError(error)) {
      const errorData = error.response?.data;
      if (errorData && errorData.detail) {
        if (typeof errorData.detail === "string") {
          return { data: null, error: errorData.detail };
        } else if (Array.isArray(errorData.detail)) {
          const messages = errorData.detail
            .map((err: ValidationError) => err.msg)
            .join(", ");
          return { data: null, error: messages };
        }
      }
    }

    return { data: null, error: "Error desconocido" };
  };

  try {
    const response: AxiosResponse<T> = await api(config); // Usar la instancia 'api'
    logRequest(config.method || "GET", config.url!, response.status, response.data);

    if (response.data && (response.data as any).session_id) {
      localStorage.setItem("session_id", (response.data as any).session_id);
    }

    return normalizeResponse(response, null);
  } catch (err: unknown) {
    const axiosError = err as AxiosError;
    logRequest(
      config.method || "GET",
      config.url!,
      axiosError.response?.status || 500,
      axiosError.response?.data
    );

    if (axiosError.response?.status === 401 && !config._retry) {
      const originalRequest: CustomAxiosRequestConfig = config;
      originalRequest._retry = true;

      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");

      if (accessToken && refreshToken) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token) => {
                originalRequest.headers.Authorization = `Bearer ${token}`;
                api(originalRequest)
                  .then(response => resolve(normalizeResponse(response, null)))
                  .catch(error => reject(normalizeResponse(undefined, error)));
              },
              reject: (error) => reject(normalizeResponse(undefined, error)),
            });
          });
        }

        isRefreshing = true;

        try {
          console.log("Intentando refrescar token de acceso");
          const refreshResponse = await api.post<TokenResponse>(
            "/v1/auth/refresh",
            { refresh_token: refreshToken },
            {
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`,
              },
            }
          );

          localStorage.setItem("accessToken", refreshResponse.data.access_token);
          localStorage.setItem("refreshToken", refreshResponse.data.refresh_token);

          originalRequest.headers.Authorization = `Bearer ${refreshResponse.data.access_token}`;
          processQueue(null, refreshResponse.data.access_token);

          const retryResponse = await api(originalRequest);
          return normalizeResponse(retryResponse, null);
        } catch (refreshError) {
          console.error("Error al refrescar token:", refreshError);
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          localStorage.removeItem("session_id");
          processQueue(refreshError, null);
          window.location.href = "/user/auth/#login";
          return normalizeResponse(undefined, {
            message: "Sesión expirada, por favor inicia sesión nuevamente",
          });
        } finally {
          isRefreshing = false;
        }
      } else {
        return normalizeResponse(undefined, { message: "No autorizado" });
      }
    }

    return normalizeResponse(undefined, err);
  }
};

// Funciones específicas de la API
export const getAllUsers = async (
  page: number = 1,
  limit: number = 10
): Promise<FetchResponse<{
  data: User[],
  total_items: number,
  total_pages: number,
  current_page: number
}>> => {
  return fetchAPI(`/v1/users/admin/users?page=${page}&limit=${limit}`, {
    method: "GET"
  });
};

export const getUserById = async (
  userId: number
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "GET"
  });
};

export const updateUser = async (
  userId: number,
  data: UpdateProfileRequest
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "PUT",
    data
  });
};

export const deleteUser = async (
  userId: number
): Promise<FetchResponse<void>> => {
  return fetchAPI<void>(`/v1/users/${userId}`, {
    method: "DELETE"
  });
};

export const createUser = async (
  data: RegisterRequest
): Promise<FetchResponse<TokenResponse>> => {
  return fetchAPI<TokenResponse>("/v1/auth/register", {
    method: "POST",
    data
  });
};

export default fetchAPI;

// src/lib/api.ts
import axios, { AxiosRequestConfig, AxiosResponse, AxiosError, AxiosInstance } from "axios";
import { HTTPValidationError, FetchResponse, RegisterRequest, TokenResponse, UpdateProfileRequest, User, ValidationError } from "./types";

// Extender AxiosRequestConfig para incluir _retry
interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  _retry?: boolean;
}

// Crear una instancia personalizada de Axios
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Variables para manejar el estado de refresco
let isRefreshing = false;
let failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

// Agregar el interceptor de solicitudes
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("accessToken");
  const sessionId = localStorage.getItem("session_id");
  if (token) {
    config.headers["Authorization"] = `Bearer ${token}`;
  } else if (sessionId) {
    config.headers["X-Session-ID"] = sessionId;
  }
  return config;
});

const logRequest = (method: string, url: string, status: number, data?: unknown) => {
  console.log(`[${method}] ${url} - Status: ${status}`, data ?? "");
};

const fetchAPI = async <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  contentType: string = "application/json"
): Promise<FetchResponse<T>> => {
  console.log(`Iniciando fetchAPI para ${endpoint}`);

  const config: CustomAxiosRequestConfig = {
    ...options,
    url: endpoint, // baseURL ya está configurado en la instancia
    headers: {
      "Content-Type": contentType,
      ...options.headers,
    },
    data: options.data,
  };

  // Convertir datos a formato x-www-form-urlencoded si es necesario
  if (contentType === "application/x-www-form-urlencoded" && config.data) {
    const formData = new URLSearchParams();
    Object.entries(config.data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });
    config.data = formData;
  }

  const normalizeResponse = (
    response: AxiosResponse<T> | undefined,
    error: unknown
  ): FetchResponse<T> => {
    if (response && response.status >= 200 && response.status < 300) {
      return { data: response.data, error: null };
    }

    if (axios.isAxiosError(error)) {
      const errorData = error.response?.data;
      if (errorData && errorData.detail) {
        if (typeof errorData.detail === "string") {
          return { data: null, error: errorData.detail };
        } else if (Array.isArray(errorData.detail)) {
          const messages = errorData.detail
            .map((err: ValidationError) => err.msg)
            .join(", ");
          return { data: null, error: messages };
        }
      }
    }

    return { data: null, error: "Error desconocido" };
  };

  try {
    const response: AxiosResponse<T> = await api(config); // Usar la instancia 'api'
    logRequest(config.method || "GET", config.url!, response.status, response.data);

    if (response.data && (response.data as any).session_id) {
      localStorage.setItem("session_id", (response.data as any).session_id);
    }

    return normalizeResponse(response, null);
  } catch (err: unknown) {
    const axiosError = err as AxiosError;
    logRequest(
      config.method || "GET",
      config.url!,
      axiosError.response?.status || 500,
      axiosError.response?.data
    );

    if (axiosError.response?.status === 401 && !config._retry) {
      const originalRequest: CustomAxiosRequestConfig = config;
      originalRequest._retry = true;

      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");

      if (accessToken && refreshToken) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token) => {
                originalRequest.headers.Authorization = `Bearer ${token}`;
                api(originalRequest)
                  .then(response => resolve(normalizeResponse(response, null)))
                  .catch(error => reject(normalizeResponse(undefined, error)));
              },
              reject: (error) => reject(normalizeResponse(undefined, error)),
            });
          });
        }

        isRefreshing = true;

        try {
          console.log("Intentando refrescar token de acceso");
          const refreshResponse = await api.post<TokenResponse>(
            "/v1/auth/refresh",
            { refresh_token: refreshToken },
            {
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`,
              },
            }
          );

          localStorage.setItem("accessToken", refreshResponse.data.access_token);
          localStorage.setItem("refreshToken", refreshResponse.data.refresh_token);

          originalRequest.headers.Authorization = `Bearer ${refreshResponse.data.access_token}`;
          processQueue(null, refreshResponse.data.access_token);

          const retryResponse = await api(originalRequest);
          return normalizeResponse(retryResponse, null);
        } catch (refreshError) {
          console.error("Error al refrescar token:", refreshError);
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          localStorage.removeItem("session_id");
          processQueue(refreshError, null);
          window.location.href = "/user/auth/#login";
          return normalizeResponse(undefined, {
            message: "Sesión expirada, por favor inicia sesión nuevamente",
          });
        } finally {
          isRefreshing = false;
        }
      } else {
        return normalizeResponse(undefined, { message: "No autorizado" });
      }
    }

    return normalizeResponse(undefined, err);
  }
};

// Funciones específicas de la API
export const getAllUsers = async (
  page: number = 1,
  limit: number = 10
): Promise<FetchResponse<{
  data: User[],
  total_items: number,
  total_pages: number,
  current_page: number
}>> => {
  return fetchAPI(`/v1/users/admin/users?page=${page}&limit=${limit}`, {
    method: "GET"
  });
};

export const getUserById = async (
  userId: number
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "GET"
  });
};

export const updateUser = async (
  userId: number,
  data: UpdateProfileRequest
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "PUT",
    data
  });
};

export const deleteUser = async (
  userId: number
): Promise<FetchResponse<void>> => {
  return fetchAPI<void>(`/v1/users/${userId}`, {
    method: "DELETE"
  });
};

export const createUser = async (
  data: RegisterRequest
): Promise<FetchResponse<TokenResponse>> => {
  return fetchAPI<TokenResponse>("/v1/auth/register", {
    method: "POST",
    data
  });
};

export default fetchAPI;

// src/components/web/Navbar.tsx
// src/components/web/Navbar.tsx
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import { usePathname } from "next/navigation";
import fetchAPI from "@/lib/api";
import {
  Button,
  Avatar,
  IconButton,
  Menu,
  MenuItem,
  useTheme,
  styled,
  Box,
  Typography,
  Snackbar,
  Alert,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Tooltip,
  Badge
} from "@mui/material";
import {
  MonetizationOn,
  Settings,
  ListAlt,
  People,
  Dashboard,
  Login,
  PersonAdd,
  Person,
  Home,
  Star,
  EmojiEvents,
  Leaderboard,
  School,
  Menu as MenuIcon,
  ContactMail,
  Close,
  Key,
  LocalActivity
} from "@mui/icons-material";
import Image from "next/image";

const GlassNavbar = styled("nav")(({ theme }) => ({
  background: "rgba(255, 255, 255, 0.1)",
  backdropFilter: "blur(10px)",
  borderBottom: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1, 2),
  position: "fixed",
  top: 0,
  left: 0,
  right: 0,
  zIndex: 1000,
}));

const NavContainer = styled(Box)(({ theme }) => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  maxWidth: "1200px",
  margin: "0 auto",
  [theme.breakpoints.down("md")]: {
    flexDirection: "row",
    alignItems: "center",
    gap: 1
  },
}));

export default function Navbar() {
  const theme = useTheme();
  const pathname = usePathname();
  const { user, credits, gamification, coupons, setCredits, setGamification, logout } = useAuth();
  const [settingsAnchorEl, setSettingsAnchorEl] = useState<null | HTMLElement>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [disableCredits, setDisableCredits] = useState(false);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const [enablePoints, setEnablePoints] = useState(true);
  const [enableCoupons, setEnableCoupons] = useState(true);
  const [enableBadges, setEnableBadges] = useState(true);
  const [enablePaymentMethods, setEnablePaymentMethods] = useState(true);
  const [anonUsername, setAnonUsername] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [newBadge, setNewBadge] = useState<string | null>(null);

  useEffect(() => {
    const storedAnonUsername = localStorage.getItem("anonUsername");
    setAnonUsername(storedAnonUsername);
  }, []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const [
          disableCreditsRes,
          enableRegistrationRes,
          enablePointsRes,
          enableCouponsRes,
          enableBadgesRes,
          enablePaymentMethodsRes,
        ] = await Promise.all([
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_coupons"),
          fetchAPI("/v1/settings/enable_badges"),
          fetchAPI("/v1/settings/enable_payment_methods"),
        ]);
        setDisableCredits(disableCreditsRes.data === "true" || disableCreditsRes.data === true);
        setEnableRegistration(enableRegistrationRes.data === "true" || enableRegistrationRes.data === true);
        setEnablePoints(enablePointsRes.data === "true" || enablePointsRes.data === true);
        setEnableCoupons(enableCouponsRes.data === "true" || enableCouponsRes.data === true);
        setEnableBadges(enableBadgesRes.data === "true" || enableBadgesRes.data === true);
        setEnablePaymentMethods(enablePaymentMethodsRes.data === "true" || enablePaymentMethodsRes.data === true);
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
      }
    };
    fetchSettings();
  }, []);

  interface InfoData {
    credits: number;
  }

  useEffect(() => {
    if (!enablePoints && !enableBadges) return;

    const interval = setInterval(async () => {
      try {
        const { data: infoData } = await fetchAPI<InfoData>("/info");
        if (infoData) {
          setCredits(infoData.credits);
        }

        const { data: gamificationData } = await fetchAPI("/v1/gamification/me");
        if (gamificationData && Array.isArray(gamificationData)) {
          const totalPoints = enablePoints
            ? gamificationData.reduce((sum, g) => sum + g.points, 0)
            : 0;
          const badges = enableBadges
            ? gamificationData.map((g) => g.badge).filter((b) => b !== null)
            : [];

          const previousBadges = JSON.parse(localStorage.getItem("badges") || "[]");
          const currentBadgeIds = badges.map((b) => b.id);
          const newBadges = currentBadgeIds.filter((id) => !previousBadges.includes(id));
          if (newBadges.length > 0 && enableBadges) {
            const badge = badges.find((b) => b.id === newBadges[0]);
            setNewBadge(badge?.name || "Nuevo badge");
            setSnackbarOpen(true);
            localStorage.setItem("badges", JSON.stringify(currentBadgeIds));
          }

          setGamification({ points: totalPoints, badges });
        }
      } catch (err) {
        console.error("Error al actualizar datos:", err);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [setCredits, setGamification, enablePoints, enableBadges]);

  const handleSettingsMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchorEl(event.currentTarget);
  };

  const handleSettingsMenuClose = () => {
    setSettingsAnchorEl(null);
  };

  const handleDrawerOpen = () => {
    setDrawerOpen(true);
  };

  const handleDrawerClose = () => {
    setDrawerOpen(false);
  };

  // Contar cupones activos y no expirados
  const availableCoupons = (coupons || []).filter(
    (coupon) =>
      coupon && // Verifica que coupon no sea null/undefined
      coupon.status === "active" &&
      (!coupon.expires_at || new Date(coupon.expires_at) > new Date())
  ).length;

  return (
    <GlassNavbar>
      <NavContainer>
        {/* Sección izquierda: Logo y menú hamburguesa */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <IconButton
            onClick={handleDrawerOpen}
            sx={{ display: { xs: "block", md: "none" } }}
          >
            <MenuIcon />
          </IconButton>

          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            <Link href="/" passHref>
              <Box sx={{
                display: "flex",
                alignItems: "center",
                gap: 1,
                cursor: "pointer"
              }}>
                <Image
                  src="/logo.png"
                  alt="Logo Neptuno"
                  width={40}
                  height={40}
                  style={{ borderRadius: "50%" }}
                />
                <Typography
                  variant="h6"
                  component="span"
                  className="app-logo"
                  sx={{
                    fontWeight: "bold",
                    display: {
                      xs: 'none', // Oculto en móvil
                      md: 'block' // Visible en desktop
                    }
                  }}
                >
                  Neptuno
                </Typography>
              </Box>
            </Link>
          </Box>
        </Box>

        {/* Sección derecha: Todos los elementos */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
          {/* Enlaces desktop + iconos */}
          <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
            {/* Enlaces desktop */}
            <Box sx={{ display: { xs: "none", md: "flex" }, gap: 2, mr: 1 }}>
              <Button
                component={Link}
                href="/ejemplos"
                className={pathname === '/ejemplos' ? 'active-link' : ''}
              >
                Ejemplos
              </Button>
              <Button
                component={Link}
                href="/rankings"
                className={pathname === '/rankings' ? 'active-link' : ''}
              >
                Rankings
              </Button>
            </Box>

            {/* Iconos de notificaciones */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {!disableCredits && credits > 0 && (
                <Link href="/user/transactions" passHref>
                  <IconButton className="notification-icon">
                    <MonetizationOn />
                    <span className="notification-badge credits-badge">{credits}</span>
                  </IconButton>
                </Link>
              )}

              {/* Cupones */}
              {enableCoupons && (
                <Link href="/user/coupon" passHref>
                  <Tooltip title="Tus cupones">
                    <IconButton className="notification-icon">
                      <Badge badgeContent={availableCoupons} color="secondary">
                        <LocalActivity />
                      </Badge>
                    </IconButton>
                  </Tooltip>
                </Link>
              )}

              {gamification && (
                <>
                  {enablePoints && (
                    <Link href="/user/points" passHref>
                      <IconButton className="notification-icon">
                        <Star />
                        <span className="notification-badge points-badge">{gamification.points}</span>
                      </IconButton>
                    </Link>
                  )}
                  {enableBadges && (
                    <Link href="/user/badges" passHref>
                      <IconButton className="notification-icon">
                        <EmojiEvents />
                        <span className="notification-badge badges-badge">{gamification.badges.length}</span>
                      </IconButton>
                    </Link>
                  )}
                </>
              )}
            </Box>
          </Box>

          {/* Menú admin y usuario */}
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            {user?.rol === "admin" && (
              <>
                <IconButton
                  onClick={handleSettingsMenuOpen}
                  sx={{ color: "inherit" }}
                >
                  <Settings />
                </IconButton>
                <Menu
                  anchorEl={settingsAnchorEl}
                  open={Boolean(settingsAnchorEl)}
                  onClose={handleSettingsMenuClose}
                  PaperProps={{
                    sx: {
                      background: "rgba(255, 255, 255, 0.9)",
                      backdropFilter: "blur(10px)",
                      borderRadius: "12px",
                      mt: 1,
                      minWidth: "200px",
                    },
                  }}
                >
                  <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/dashboard">
                    <Dashboard sx={{ mr: 1 }} /> Dashboard
                  </MenuItem>
                  <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/registry">
                    <ListAlt sx={{ mr: 1 }} /> Registros
                  </MenuItem>
                  <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/users">
                    <People sx={{ mr: 1 }} /> Usuarios
                  </MenuItem>
                </Menu>
              </>
            )}

            {/* Avatar de usuario */}
            {user ? (
              <Tooltip title={user.username} arrow>
                <IconButton
                  component={Link}
                  href="/user/dashboard"
                  className="user-avatar"
                >
                  <Avatar sx={{
                    bgcolor: theme.palette.primary.main,
                    width: 40,
                    height: 40,
                    fontSize: '1rem'
                  }}>
                    {user.username[0].toUpperCase()}
                  </Avatar>
                </IconButton>
              </Tooltip>
            ) : (
              <Tooltip title={anonUsername ? "Iniciar sesión" : "Registrarse"} arrow>
                <Box sx={{ position: 'relative' }}>
                  <IconButton
                    component={Link}
                    href={anonUsername ? "/user/auth/#login" : "/user/auth/#register"}
                    className="user-avatar"
                  >
                    <Avatar sx={{
                      bgcolor: theme.palette.grey[500],
                      width: 40,
                      height: 40,
                      color: theme.palette.common.white
                    }}>
                      {anonUsername ? <Person /> : <Key />}
                    </Avatar>
                  </IconButton>
                  {anonUsername && (
                    <Box sx={{
                      position: 'absolute',
                      top: 0,
                      right: 0,
                      backgroundColor: theme.palette.secondary.main,
                      borderRadius: '50%',
                      width: 20,
                      height: 20,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      border: `2px solid ${theme.palette.background.paper}`
                    }}>
                      <Key sx={{ fontSize: 12, color: theme.palette.common.white }} />
                    </Box>
                  )}
                </Box>
              </Tooltip>
            )}
          </Box>
        </Box>

        {/* Menú hamburguesa */}
        <Drawer anchor="left" open={drawerOpen} onClose={handleDrawerClose}>
          <List>
            {/* Header del menú */}
            <Box sx={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              p: 2,
              borderBottom: `1px solid ${theme.palette.divider}`
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Image
                  src="/logo.png"
                  alt="Logo Neptuno"
                  width={40}
                  height={40}
                  style={{ borderRadius: "50%" }}
                />
                <Typography
                  variant="h6"
                  sx={{
                    fontWeight: "bold",
                    background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                    WebkitBackgroundClip: "text",
                    WebkitTextFillColor: "transparent",
                    display: "inline-block",
                  }}
                >
                  Neptuno
                </Typography>
              </Box>
              <IconButton onClick={handleDrawerClose}>
                <Close />
              </IconButton>
            </Box>

            <ListItem component={Link} href="/">
              <ListItemIcon><Home /></ListItemIcon>
              <ListItemText primary="Inicio" />
            </ListItem>
            <ListItem component={Link} href="/ejemplos">
              <ListItemIcon><School /></ListItemIcon>
              <ListItemText primary="Ejemplos" />
            </ListItem>
            <ListItem component={Link} href="/rankings">
              <ListItemIcon><Leaderboard /></ListItemIcon>
              <ListItemText primary="Rankings" />
            </ListItem>
            <ListItem component={Link} href="/about/contact">
              <ListItemIcon><ContactMail /></ListItemIcon>
              <ListItemText primary="Contacto" />
            </ListItem>

            {user?.rol === "admin" && (
              <>
                <ListItem component={Link} href="/admin/dashboard">
                  <ListItemIcon><Dashboard /></ListItemIcon>
                  <ListItemText primary="Dashboard" />
                </ListItem>
                <ListItem component={Link} href="/admin/registry">
                  <ListItemIcon><ListAlt /></ListItemIcon>
                  <ListItemText primary="Registros" />
                </ListItem>
                <ListItem component={Link} href="/admin/users">
                  <ListItemIcon><People /></ListItemIcon>
                  <ListItemText primary="Usuarios" />
                </ListItem>
              </>
            )}
            {user ? (
              <ListItem component={Link} href="/user/dashboard">
                <ListItemIcon><Person /></ListItemIcon>
                <ListItemText primary={user.username} />
              </ListItem>
            ) : (
              <>
                <ListItem component={Link} href="/user/auth/#login">
                  <ListItemIcon><Login /></ListItemIcon>
                  <ListItemText primary="Iniciar Sesión" />
                </ListItem>
                {enableRegistration && (
                  <ListItem component={Link} href="/user/auth/#register">
                    <ListItemIcon><PersonAdd /></ListItemIcon>
                    <ListItemText primary="Registrarse" />
                  </ListItem>
                )}
              </>
            )}
          </List>
        </Drawer>
      </NavContainer>

      <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)}>
        <Alert onClose={() => setSnackbarOpen(false)} severity="success" sx={{ width: "100%" }}>
          ¡Felicidades! Has obtenido el badge: {newBadge}
        </Alert>
      </Snackbar>
    </GlassNavbar >
  );
}

// src/app/user/auth/page.tsx..
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import { useRouter, usePathname } from "next/navigation";
import { motion, AnimatePresence } from "framer-motion";
import { RegisterRequest } from "@/lib/types";
import fetchAPI from "@/lib/api";
import { 
  Box, 
  Typography, 
  TextField, 
  Button, 
  Alert, 
  Snackbar, 
  Divider, 
  useTheme,
  styled,
  Container,
  Avatar,
  IconButton,
  Chip
} from "@mui/material";
import { 
  Lock, 
  Person, 
  Email, 
  ArrowBack,
  VerifiedUser,
  VpnKey,
  PersonAdd,
  EmojiEvents,
  Stars
} from "@mui/icons-material";

// Styled Components
const AuthGlassCard = styled(Box)(({ theme }) => ({
  background: 'rgba(255, 255, 255, 0.1)',
  backdropFilter: 'blur(10px)',
  border: '1px solid rgba(255, 255, 255, 0.2)',
  borderRadius: '24px',
  boxShadow: theme.shadows[10],
  padding: theme.spacing(6),
  width: '100%',
  maxWidth: '500px',
  margin: '0 auto'
}));

const AuthButton = styled(Button)(({ theme }) => ({
  borderRadius: '12px',
  padding: theme.spacing(2),
  fontWeight: 'bold',
  fontSize: '1rem',
  textTransform: 'none',
  marginTop: theme.spacing(2)
}));

const AuthLayoutContainer = styled(Box)(({ theme }) => ({
  minHeight: '100vh',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'space-between',
  background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
}));

export default function AuthPage() {
  const theme = useTheme();
  const router = useRouter();
  const pathname = usePathname();
  const [mode, setMode] = useState<"login" | "register" | "reset">("login");
  const [email, setEmail] = useState("");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [token, setToken] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const { login, register } = useAuth();

  useEffect(() => {
    const handleHashChange = () => {
      const hash = window.location.hash.substring(1);
      if (hash === "register" && enableRegistration) {
        setMode("register");
      } else if (hash === "reset") {
        setMode("reset");
      } else {
        setMode("login");
      }
    };

    handleHashChange();
    window.addEventListener("hashchange", handleHashChange);

    return () => {
      window.removeEventListener("hashchange", handleHashChange);
    };
  }, [enableRegistration]);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const enableRegistrationRes = await fetchAPI("/v1/settings/enable_registration");
        setEnableRegistration(enableRegistrationRes.data === "true" || enableRegistrationRes.data === true);
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
        setEnableRegistration(true);
      }
    };
    fetchSettings();
  }, []);

  const changeMode = (newMode: "login" | "register" | "reset") => {
    setMode(newMode);
    if (newMode === "login") {
      router.replace(pathname);
    } else {
      window.location.hash = newMode;
    }
  };

  const handleLogin = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);
    try {
      await login(email, password);
      
      // Gamificación: Punto por login exitoso
      try {
        await fetchAPI("/v1/gamification/events", {
          method: "POST",
          data: { event_type_id: 100 } // ID del evento de login
        });
        setSuccess("¡Inicio de sesión exitoso! Redirigiendo... (+1 punto 🎉)");
      } catch (gamErr) {
        setSuccess("¡Inicio de sesión exitoso! Redirigiendo...");
      }
      
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al iniciar sesión");
    }
  };

  const handleRegister = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);
    if (!enableRegistration) return;
    try {
      const data: RegisterRequest = { email, username, password };
      await register(data);

      // Gamificación: Eventos de progreso y badge
      try {
        // Registrar progreso por cada campo completado
        await Promise.all([
          fetchAPI("/v1/gamification/events", { 
            method: "POST",
            data: { event_type_id: 101 } // Email completado
          }),
          fetchAPI("/v1/gamification/events", { 
            method: "POST",
            data: { event_type_id: 102 } // Username completado
          }),
          fetchAPI("/v1/gamification/events", { 
            method: "POST",
            data: { event_type_id: 103 } // Password completado
          })
        ]);
        
        // Otorgar badge por registro completo
        await fetchAPI("/v1/gamification/events", { 
          method: "POST",
          data: { event_type_id: 104 } // Badge de registro completo
        });
        
        setSuccess("¡Registro exitoso! 🏆 ¡Insignia obtenida! Redirigiendo...");
      } catch (gamErr) {
        setSuccess("¡Registro exitoso! Redirigiendo...");
      }

    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "Error al registrarse";
      if (errorMessage.includes("email")) {
        setError("El email ya está registrado");
      } else if (errorMessage.includes("username")) {
        setError("El nombre de usuario ya está en uso");
      } else {
        setError(errorMessage);
      }
    }
  };

  const handleResetPassword = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);
    try {
      const { data, error } = await fetchAPI<{ message: string; token?: string }>("/v1/auth/password-reset", {
        method: "POST",
        data: { email },
      });
      if (error) throw new Error(error as string);
      setSuccess(data?.message || "Solicitud enviada, revisa tu correo.");
      setToken(data?.token || "");
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al solicitar recuperación");
    }
  };

  const handleConfirmReset = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccess(null);
    try {
      const { data, error } = await fetchAPI<{ message: string }>("/v1/auth/password-reset/confirm", {
        method: "POST",
        data: { token, new_password: newPassword },
      });
      if (error) throw new Error(error as string);
      setSuccess(data?.message || "Contraseña actualizada con éxito.");
      setTimeout(() => setMode("login"), 2000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar contraseña");
    }
  };

  return (
    <AuthLayoutContainer>
      <Box component="header" sx={{ p: 4, textAlign: 'center' }}>
        <Link href="/" passHref>
          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: 1 }}>
            <Avatar sx={{ bgcolor: theme.palette.primary.main }}>
              <VerifiedUser />
            </Avatar>
            <Typography 
              variant="h4" 
              component="span" 
              sx={{ 
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent'
              }}
            >
              Neptuno
            </Typography>
          </Box>
        </Link>
      </Box>

      <Box component="main" sx={{ display: 'flex', alignItems: 'center', justifyContent: 'center', p: 2 }}>
        <AuthGlassCard>
          <AnimatePresence mode="wait">
            {mode === "login" && (
              <motion.div
                key="login"
                initial={{ x: -100, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ x: 100, opacity: 0 }}
                transition={{ duration: 0.3 }}
              >
                <Box sx={{ textAlign: 'center', mb: 4 }}>
                  <Lock color="primary" sx={{ fontSize: 48, mb: 2 }} />
                  <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold', mb: 1 }}>
                    Iniciar Sesión
                  </Typography>
                  <Typography variant="body1" color="text.secondary">
                    Accede a tu cuenta para continuar
                  </Typography>
                </Box>

                {error && (
                  <Alert severity="error" sx={{ mb: 3, borderRadius: '12px' }}>
                    {error}
                  </Alert>
                )}
                {success && (
                  <Alert severity="success" sx={{ mb: 3, borderRadius: '12px' }}>
                    {success}
                  </Alert>
                )}

                <Box component="form" onSubmit={handleLogin} sx={{ mt: 3 }}>
                  <TextField
                    fullWidth
                    label="Email"
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    margin="normal"
                    InputProps={{
                      startAdornment: <Email color="action" sx={{ mr: 1 }} />
                    }}
                    sx={{ mb: 2 }}
                  />
                  <TextField
                    fullWidth
                    label="Contraseña"
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    margin="normal"
                    InputProps={{
                      startAdornment: <VpnKey color="action" sx={{ mr: 1 }} />
                    }}
                    sx={{ mb: 2 }}
                  />
                  <AuthButton
                    fullWidth
                    type="submit"
                    variant="contained"
                    color="primary"
                    size="large"
                    startIcon={<Lock />}
                  >
                    Iniciar Sesión
                  </AuthButton>
                </Box>

                <Box sx={{ textAlign: 'center', mt: 2 }}>
                  <Chip 
                    icon={<EmojiEvents />}
                    label="+1 punto por cada login"
                    color="warning"
                    variant="outlined"
                  />
                </Box>

                <Divider sx={{ my: 3 }} />

                <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                  {enableRegistration ? (
                    <Button onClick={() => changeMode("register")} color="secondary">
                      Crear una cuenta
                    </Button>
                  ) : (
                    <Typography variant="body2" color="text.secondary">
                      Registro deshabilitado
                    </Typography>
                  )}
                  <Button onClick={() => changeMode("reset")} color="inherit">
                    ¿Olvidaste tu contraseña?
                  </Button>
                </Box>
              </motion.div>
            )}

            {mode === "register" && (
              <motion.div
                key="register"
                initial={{ x: 100, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                exit={{ x: -100, opacity: 0 }}
                transition={{ duration: 0.3 }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                  <IconButton onClick={() => changeMode("login")} sx={{ mr: 1 }}>
                    <ArrowBack />
                  </IconButton>
                  <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
                    Crear Cuenta
                  </Typography>
                </Box>

                {!enableRegistration && (
                  <Alert severity="warning" sx={{ mb: 3, borderRadius: '12px' }}>
                    El registro está deshabilitado en este momento.
                  </Alert>
                )}
                {error && (
                  <Alert severity="error" sx={{ mb: 3, borderRadius: '12px' }}>
                    {error}
                  </Alert>
                )}
                {success && (
                  <Alert severity="success" sx={{ mb: 3, borderRadius: '12px' }}>
                    {success}
                  </Alert>
                )}

                <Box sx={{ textAlign: 'center', mt: 2, mb: 3 }}>
                  <Chip 
                    icon={<Stars />}
                    label="¡Gana 3 puntos + insignia al registrarte!"
                    color="secondary"
                    variant="outlined"
                  />
                </Box>

                <Box component="form" onSubmit={handleRegister} sx={{ mt: 2 }}>
                  <TextField
                    fullWidth
                    label="Email"
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    margin="normal"
                    disabled={!enableRegistration}
                    InputProps={{
                      startAdornment: <Email color="action" sx={{ mr: 1 }} />
                    }}
                    sx={{ mb: 2 }}
                  />
                  <TextField
                    fullWidth
                    label="Nombre de usuario"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    margin="normal"
                    disabled={!enableRegistration}
                    InputProps={{
                      startAdornment: <Person color="action" sx={{ mr: 1 }} />
                    }}
                    sx={{ mb: 2 }}
                  />
                  <TextField
                    fullWidth
                    label="Contraseña"
                    type="password"
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    margin="normal"
                    disabled={!enableRegistration}
                    InputProps={{
                      startAdornment: <VpnKey color="action" sx={{ mr: 1 }} />
                    }}
                    sx={{ mb: 2 }}
                  />
                  <AuthButton
                    fullWidth
                    type="submit"
                    variant="contained"
                    color="primary"
                    size="large"
                    disabled={!enableRegistration}
                    startIcon={<PersonAdd />}
                  >
                    Registrarse
                  </AuthButton>
                </Box>

                <Typography variant="body2" sx={{ mt: 3, textAlign: 'center' }}>
                  ¿Ya tienes una cuenta?{' '}
                  <Button onClick={() => changeMode("login")} color="primary">
                    Inicia sesión
                  </Button>
                </Typography>
              </motion.div>
            )}

            {mode === "reset" && (
              <motion.div
                key="reset"
                initial={{ y: 100, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                exit={{ y: -100, opacity: 0 }}
                transition={{ duration: 0.3 }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 3 }}>
                  <IconButton onClick={() => changeMode("login")} sx={{ mr: 1 }}>
                    <ArrowBack />
                  </IconButton>
                  <Typography variant="h4" component="h1" sx={{ fontWeight: 'bold' }}>
                    Recuperar Contraseña
                  </Typography>
                </Box>

                {error && (
                  <Alert severity="error" sx={{ mb: 3, borderRadius: '12px' }}>
                    {error}
                  </Alert>
                )}
                {success && (
                  <Alert severity="success" sx={{ mb: 3, borderRadius: '12px' }}>
                    {success}
                  </Alert>
                )}

                {!success ? (
                  <Box component="form" onSubmit={handleResetPassword} sx={{ mt: 2 }}>
                    <TextField
                      fullWidth
                      label="Email"
                      type="email"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      margin="normal"
                      InputProps={{
                        startAdornment: <Email color="action" sx={{ mr: 1 }} />
                      }}
                      sx={{ mb: 2 }}
                    />
                    <AuthButton
                      fullWidth
                      type="submit"
                      variant="contained"
                      color="primary"
                      size="large"
                      startIcon={<VpnKey />}
                    >
                      Solicitar Recuperación
                    </AuthButton>
                  </Box>
                ) : (
                  <Box component="form" onSubmit={handleConfirmReset} sx={{ mt: 2 }}>
                    <TextField
                      fullWidth
                      label="Token"
                      value={token}
                      onChange={(e) => setToken(e.target.value)}
                      margin="normal"
                      InputProps={{
                        startAdornment: <VerifiedUser color="action" sx={{ mr: 1 }} />
                      }}
                      sx={{ mb: 2 }}
                    />
                    <TextField
                      fullWidth
                      label="Nueva Contraseña"
                      type="password"
                      value={newPassword}
                      onChange={(e) => setNewPassword(e.target.value)}
                      margin="normal"
                      InputProps={{
                        startAdornment: <VpnKey color="action" sx={{ mr: 1 }} />
                      }}
                      sx={{ mb: 2 }}
                    />
                    <AuthButton
                      fullWidth
                      type="submit"
                      variant="contained"
                      color="primary"
                      size="large"
                      startIcon={<Lock />}
                    >
                      Actualizar Contraseña
                    </AuthButton>
                  </Box>
                )}

                <Typography variant="body2" sx={{ mt: 3, textAlign: 'center' }}>
                  <Button onClick={() => changeMode("login")} color="primary">
                    Volver a Iniciar Sesión
                  </Button>
                </Typography>
              </motion.div>
            )}
          </AnimatePresence>
        </AuthGlassCard>
      </Box>

      <Box component="footer" sx={{ p: 3, textAlign: 'center' }}>
        <Typography variant="body2" color="text.secondary">
          © {new Date().getFullYear()} Neptuno. Todos los derechos reservados.
        </Typography>
      </Box>
    </AuthLayoutContainer>
  );
}

// src/app/user/badges/page.tsx
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box,
  Typography,
  Grid,
  Chip,
  Avatar,
  useTheme,
  styled,
  Tabs,
  Tab,
  Fade,
  Paper,
} from "@mui/material";
import {
  GlassCard,
  GradientText,
  BadgeIcon,
  EmptyState,
} from "@/components/ui";
import fetchAPI from "@/lib/api";
import { UserGamificationResponse, BadgeWithEventType } from "@/lib/types";
import { EmojiEvents, Stars } from "@mui/icons-material";

// Styled Components - Actualizados para mejor legibilidad
const BadgeContainer = styled("div")(({ theme }) => ({
  display: "grid",
  gridTemplateColumns: "repeat(auto-fill, minmax(300px, 1fr))",
  gap: theme.spacing(3),
  padding: theme.spacing(3),
  [theme.breakpoints.down('sm')]: {
    gridTemplateColumns: "1fr",
    padding: theme.spacing(2),
  },
}));

const BadgeCard = styled(Box)(({ theme }) => ({
  height: "100%",
  transition: "transform 0.3s ease, box-shadow 0.3s ease",
  position: "relative",
  overflow: "hidden",
  borderRadius: "16px",
  background: theme.palette.background.paper,
  boxShadow: theme.shadows[2],
  border: "1px solid rgba(222, 226, 230, 0.5)",
  "&:hover": {
    transform: "translateY(-5px)",
    boxShadow: theme.shadows[6],
  },
}));

const EventTypeSection = styled("section")(({ theme }) => ({
  marginBottom: theme.spacing(4),
}));

const StyledTabs = styled(Tabs)(({ theme }) => ({
  "& .MuiTabs-indicator": {
    backgroundColor: theme.palette.primary.main,
    height: 3,
  },
  "& .MuiTab-root": {
    color: theme.palette.text.secondary,
    opacity: 0.8,
    fontSize: "0.875rem",
    fontWeight: 500,
    textTransform: "capitalize",
    minWidth: "auto",
    padding: "6px 16px",
    "&.Mui-selected": {
      color: theme.palette.primary.main,
      opacity: 1,
    },
    "&:hover": {
      opacity: 1,
      color: theme.palette.primary.main,
    },
  },
}));

export default function Badges() {
  const theme = useTheme();
  const router = useRouter();
  const [badges, setBadges] = useState<BadgeWithEventType[]>([]);
  const [groupedBadges, setGroupedBadges] = useState<Record<string, BadgeWithEventType[]>>({});
  const [selectedTab, setSelectedTab] = useState("all");
  const [enableBadges, setEnableBadges] = useState<boolean | null>(null);

  useEffect(() => {
    const checkSettingsAndFetchBadges = async () => {
      try {
        const { data: settingsData } = await fetchAPI("/v1/settings/enable_badges");
        const isEnabled = settingsData === "true" || settingsData === true;
        setEnableBadges(isEnabled);

        if (!isEnabled) {
          return;
        }

        const { data } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
        if (data) {
          const userBadges = data
            .filter((g) => g.badge)
            .map((g) => ({
              ...g.badge!,
              event_type: g.event_type,
            })) as BadgeWithEventType[];

          setBadges(userBadges);

          const grouped = userBadges.reduce((acc, badge) => {
            const key = badge.event_type.name;
            if (!acc[key]) acc[key] = [];
            acc[key].push(badge);
            return acc;
          }, {} as Record<string, BadgeWithEventType[]>);

          setGroupedBadges(grouped);
        }
      } catch (err) {
        console.error("Error al cargar datos de insignias:", err);
      }
    };
    checkSettingsAndFetchBadges();
  }, [router]);

  if (enableBadges === null) return null;

  if (!enableBadges) {
    return (
      <Box
        sx={{
          minHeight: "100vh",
          background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          py: { xs: 4, md: 6 },
          px: { xs: 2, md: 6 },
        }}
      >
        <Typography variant="h6" color="text.secondary">
          Esta funcionalidad no está habilitada en este momento.
        </Typography>
      </Box>
    );
  }

  const eventTypes = Object.keys(groupedBadges);
  const filteredBadges = selectedTab === "all" ? badges : groupedBadges[selectedTab] || [];

  return (
    <Box
      sx={{
        minHeight: "100vh",
        background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
        py: { xs: 4, md: 6 },
        px: { xs: 2, md: 6 },
      }}
    >
      <Box sx={{ maxWidth: "1600px", mx: "auto" }}>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Box
            sx={{
              fontSize: { xs: "2rem", md: "2.5rem" },
              fontWeight: "bold",
              mb: 4,
              textAlign: "center",
            }}
          >
            <GradientText>Mis Logros</GradientText>
            <Typography variant="subtitle1" color="text.secondary" sx={{ mt: 1 }}>
              Tus insignias de reconocimiento
            </Typography>
          </Box>
        </motion.div>

        <Paper elevation={0} sx={{ mb: 4, borderRadius: "12px", background: "rgba(255, 255, 255, 0.7)" }}>
          <StyledTabs
            value={selectedTab}
            onChange={(_, val) => setSelectedTab(val)}
            variant="scrollable"
            scrollButtons="auto"
            sx={{ 
              "& .MuiTabs-scroller": {
                padding: "0 16px",
              }
            }}
          >
            <Tab label="Todos" value="all" />
            {eventTypes.map((type) => (
              <Tab 
                key={type} 
                label={type.replace(/_/g, " ")} 
                value={type} 
                icon={<BadgeIcon type={type} />}
                iconPosition="start"
              />
            ))}
          </StyledTabs>
        </Paper>

        {filteredBadges.length === 0 ? (
          <EmptyState
            icon="🎖️"
            title="Aún no tienes insignias"
            description="Completa acciones en la plataforma para desbloquear logros"
          />
        ) : (
          <BadgeContainer>
            <AnimatePresence>
              {filteredBadges.map((badge) => (
                <motion.div
                  key={badge.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  whileHover={{ scale: 1.02 }}
                >
                  <BadgeCard>
                    <Box sx={{ p: 3, height: "100%" }}>
                      <Box
                        sx={{
                          display: "flex",
                          alignItems: "center",
                          mb: 2,
                          gap: 2,
                        }}
                      >
                        <Avatar
                          sx={{
                            width: 56,
                            height: 56,
                            bgcolor: theme.palette.primary.light,
                            color: theme.palette.primary.contrastText
                          }}
                        >
                          <BadgeIcon type={badge.event_type.name} />
                        </Avatar>
                        <Box>
                          <Typography
                            variant="h6"
                            fontWeight="bold"
                            color="text.primary"
                          >
                            {badge.name}
                          </Typography>
                          <Typography variant="body2" color="text.secondary">
                            {badge.event_type.name.replace(/_/g, " ")}
                          </Typography>
                        </Box>
                      </Box>

                      <Typography variant="body2" color="text.primary" sx={{ mb: 3 }}>
                        {badge.description}
                      </Typography>

                      <Box
                        sx={{
                          display: "flex",
                          justifyContent: "space-between",
                          alignItems: "center",
                          mt: "auto",
                        }}
                      >
                        <Chip
                          label={`${badge.required_points} pts`}
                          color="primary"
                          size="small"
                          icon={<Stars sx={{ fontSize: "1rem" }} />}
                          sx={{ 
                            background: theme.palette.primary.main,
                            color: theme.palette.primary.contrastText
                          }}
                        />
                        <Typography variant="caption" color="text.secondary">
                          {badge.user_type}
                        </Typography>
                      </Box>
                    </Box>
                  </BadgeCard>
                </motion.div>
              ))}
            </AnimatePresence>
          </BadgeContainer>
        )}
      </Box>
    </Box>
  );
}

// src/app/user/coupon/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box,
  Typography,
  Button,
  Chip,
  Snackbar,
  Alert,
  useTheme,
  styled,
  Tabs,
  Tab,
  Paper,
  Avatar,
  Divider,
  Grid
} from "@mui/material";
import {
  LocalOffer,
  CheckCircle,
  Pending,
  ErrorOutline,
  Block,
  Redeem
} from "@mui/icons-material";

// Styled Components
const CouponCard = styled(Paper)(({ theme }) => ({
  background: 'rgba(248, 249, 250, 0.85)',
  backdropFilter: 'blur(10px)',
  borderRadius: '16px',
  padding: theme.spacing(3),
  boxShadow: theme.shadows[4],
  border: '1px solid rgba(222, 226, 230, 0.5)',
  transition: 'all 0.3s ease',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: theme.shadows[6],
    background: 'rgba(248, 249, 250, 0.95)'
  }
}));

const StatusChip = styled(Chip)(({ theme }) => ({
  borderRadius: '8px',
  fontWeight: 600,
  fontSize: '0.75rem',
  padding: '2px 8px',
  height: 'auto',
  color: 'white',
  '&.MuiChip-colorSuccess': {
    backgroundColor: theme.palette.success.main
  },
  '&.MuiChip-colorWarning': {
    backgroundColor: theme.palette.warning.main
  },
  '&.MuiChip-colorError': {
    backgroundColor: theme.palette.error.main
  },
  '&.MuiChip-colorDefault': {
    backgroundColor: theme.palette.grey[500]
  }
}));

const StyledTabs = styled(Tabs)(({ theme }) => ({
  '& .MuiTabs-indicator': {
    backgroundColor: theme.palette.primary.main,
    height: 3,
    borderRadius: '2px'
  },
  '& .MuiTab-root': {
    color: theme.palette.text.primary,
    opacity: 0.8,
    fontSize: '0.875rem',
    fontWeight: 500,
    textTransform: 'capitalize',
    padding: '12px 16px',
    minHeight: 'auto',
    '&.Mui-selected': {
      color: theme.palette.primary.main,
      opacity: 1,
      fontWeight: 600
    },
    '&:hover': {
      opacity: 1,
      color: theme.palette.primary.dark
    }
  }
}));

export default function CouponPage() {
  const { coupons, setCoupons, setCredits } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [enableCoupons, setEnableCoupons] = useState<boolean | null>(null);
  const [statusFilter, setStatusFilter] = useState<string>('active');

  useEffect(() => {
    if (!coupons) router.push("/");
  }, [coupons, router]);

  const handleRedeem = async (couponId: number) => {
    try {
      const { data } = await fetchAPI<any>(`/v1/coupons/redeem/${couponId}`, {
        method: "POST",
      });
      if (data) {
        setCoupons(coupons.map((c) => (c.id === couponId ? data : c)));
        const { data: info } = await fetchAPI<any>("/info");
        setCredits(info.credits);
        setSuccess("Cupón canjeado exitosamente");
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al canjear cupón");
    }
  };

  const filteredCoupons = coupons.filter(coupon => {
    if (statusFilter === 'all') return true;
    return coupon.status === statusFilter;
  });

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'active': return <CheckCircle fontSize="small" />;
      case 'pending': return <Pending fontSize="small" />;
      case 'expired': return <ErrorOutline fontSize="small" />;
      case 'disabled': return <Block fontSize="small" />;
      case 'redeemed': return <Redeem fontSize="small" />;
      default: return <LocalOffer fontSize="small" />;
    }
  };

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'active': return 'success';
      case 'pending': return 'warning';
      case 'redeemed': return 'primary';
      case 'expired':
      case 'disabled': 
      default: return 'error';
    }
  };

  //if (enableCoupons === null) return null;

 /* if (!enableCoupons) {
    return (
      <Box sx={{
        minHeight: "100vh",
        background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        p: 4
      }}>
        <Typography variant="h6" color="text.secondary">
          Esta funcionalidad no está habilitada en este momento.
        </Typography>
      </Box>
    );
  }
*/
  return (
    <Box sx={{
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      p: { xs: 2, md: 4 },
      color: 'text.primary'
    }}>
      <Box sx={{ 
        maxWidth: "1200px", 
        mx: "auto",
        position: 'relative'
      }}>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Typography
            variant="h3"
            sx={{
              mb: 4,
              fontWeight: "bold",
              background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              display: 'inline-block',
              letterSpacing: '-0.5px'
            }}
          >
            Mis Cupones
          </Typography>
        </motion.div>

        <Paper sx={{ mb: 4, borderRadius: '12px', overflow: 'hidden' }}>
          <StyledTabs
            value={statusFilter}
            onChange={(e, newValue) => setStatusFilter(newValue)}
            variant="scrollable"
            scrollButtons="auto"
          >
            
            <Tab label="Activos" value="active" icon={<CheckCircle fontSize="small" />} iconPosition="start" />
            <Tab label="Canjeados" value="redeemed" icon={<Redeem fontSize="small" />} iconPosition="start" />
            <Tab label="Pendientes" value="pending" icon={<Pending fontSize="small" />} iconPosition="start" />
            <Tab label="Expirados" value="expired" icon={<ErrorOutline fontSize="small" />} iconPosition="start" />
            <Tab label="Desactivados" value="disabled" icon={<Block fontSize="small" />} iconPosition="start" />
          </StyledTabs>
        </Paper>

        {filteredCoupons.length === 0 ? (
          <Box sx={{
            textAlign: 'center',
            py: 6,
            background: 'rgba(255, 255, 255, 0.7)',
            borderRadius: '24px',
            backdropFilter: 'blur(12px)',
            border: '1px solid rgba(222, 226, 230, 0.5)',
            boxShadow: theme.shadows[2]
          }}>
            <LocalOffer sx={{ 
              fontSize: 48, 
              color: 'text.secondary', 
              mb: 2,
              opacity: 0.5
            }} />
            <Typography variant="h6" color="text.secondary">
              No hay cupones disponibles
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              {statusFilter === 'all' 
                ? 'No tienes cupones registrados' 
                : `No tienes cupones con estado ${statusFilter}`}
            </Typography>
          </Box>
        ) : (
          <AnimatePresence>
            <Grid container spacing={3}>
              {filteredCoupons.map((coupon) => (
                <Grid item xs={12} sm={6} md={4} key={coupon.id}>
                  <motion.div
                    initial={{ opacity: 0, y: 20 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0 }}
                    transition={{ duration: 0.3 }}
                    whileHover={{ scale: 1.02 }}
                  >
                    <CouponCard>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2, mb: 2 }}>
                        <Avatar
                          sx={{
                            bgcolor: theme.palette.primary.main,
                            color: 'white',
                            width: 48,
                            height: 48,
                            boxShadow: theme.shadows[2]
                          }}
                        >
                          {getStatusIcon(coupon.status)}
                        </Avatar>
                        <Box>
                          <Typography variant="h6" fontWeight="bold">
                            {coupon.name}
                          </Typography>
                          <StatusChip 
                            label={coupon.status} 
                            size="small"
                            color={getStatusColor(coupon.status)}
                            sx={{ mt: 0.5 }}
                          />
                        </Box>
                      </Box>
                      
                      <Divider sx={{ my: 2, borderColor: 'rgba(0,0,0,0.1)' }} />
                      
                      <Typography variant="body1" sx={{ mb: 2 }}>
                        {coupon.description || "Sin descripción"}
                      </Typography>
                      
                      <Box sx={{ 
                        display: 'flex', 
                        justifyContent: 'space-between',
                        alignItems: 'center',
                        mt: 3
                      }}>
                        <Typography variant="h5" color="primary.main" fontWeight="bold">
                          {coupon.credits} créditos
                        </Typography>
                        
                        {coupon.status === 'active' && (
                          <Button
                            variant="contained"
                            color="primary"
                            onClick={() => handleRedeem(coupon.id)}
                            startIcon={<Redeem />}
                          >
                            Canjear
                          </Button>
                        )}
                      </Box>
                    </CouponCard>
                  </motion.div>
                </Grid>
              ))}
            </Grid>
          </AnimatePresence>
        )}
      </Box>

      <Snackbar
        open={!!error}
        autoHideDuration={3000}
        onClose={() => setError(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert severity="error" sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}>
          {error}
        </Alert>
      </Snackbar>
      
      <Snackbar
        open={!!success}
        autoHideDuration={3000}
        onClose={() => setSuccess(null)}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
      >
        <Alert severity="success" sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}>
          {success}
        </Alert>
      </Snackbar>
    </Box>
  );
}

// frontend/src/app/user/points/page.tsx
"use client";

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { GlassCard, GradientText, TimelineIcon, EmptyState } from "@/components/ui";
import { Box, Typography, Tabs, Tab, styled, Chip, useTheme } from "@mui/material";

const TimelineItemContainer = styled(motion.div)(({ theme }) => ({
  display: "flex",
  gap: theme.spacing(3),
  position: "relative",
  paddingLeft: theme.spacing(6),
  paddingBottom: theme.spacing(4),
  borderLeft: `2px solid ${theme.palette.divider}`,
  "&:last-child": {
    borderLeft: "none",
    paddingBottom: 0,
  },
  "&::before": {
    content: '""',
    position: "absolute",
    left: "-9px",
    top: 0,
    width: "16px",
    height: "16px",
    borderRadius: "50%",
    background: theme.palette.primary.main,
    boxShadow: `0 0 0 4px ${theme.palette.primary.light}33`,
  },
}));

const StyledTabs = styled(Tabs)(({ theme }) => ({
  "& .MuiTabs-indicator": {
    backgroundColor: theme.palette.primary.main,
    height: 3,
    borderRadius: 3,
  },
  "& .MuiTab-root": {
    color: theme.palette.text.secondary,
    opacity: 0.8,
    fontSize: "0.875rem",
    fontWeight: 500,
    textTransform: "capitalize",
    minWidth: "auto",
    padding: "6px 16px",
    "&.Mui-selected": {
      color: theme.palette.primary.main,
      opacity: 1,
    },
    "&:hover": {
      color: theme.palette.primary.main,
      opacity: 1,
    },
  },
}));

const StyledGlassCard = styled(GlassCard)(({ theme }) => ({
  position: "relative",
  overflow: "hidden",
  background: "rgba(255, 255, 255, 0.9)",
  backdropFilter: "blur(12px)",
  border: `1px solid ${theme.palette.divider}`,
  borderRadius: theme.shape.borderRadius,
  boxShadow: theme.shadows[2],
  "& > div": {
    position: "relative",
    zIndex: 1,
  },
}));

const PointsBadge = styled(Chip)(({ theme }) => ({
  fontSize: "1rem",
  fontWeight: "bold",
  padding: theme.spacing(1, 2),
  background: `linear-gradient(135deg, ${theme.palette.primary.main} 0%, ${theme.palette.secondary.main} 100%)`,
  color: theme.palette.common.white,
}));

export default function PointsPage() {
  const theme = useTheme();
  const { user } = useAuth();
  const router = useRouter();
  const [pointsHistory, setPointsHistory] = useState<any[]>([]);
  const [enablePoints, setEnablePoints] = useState<boolean | null>(null);
  const [groupedPoints, setGroupedPoints] = useState<Record<string, any[]>>({});
  const [selectedTab, setSelectedTab] = useState("all");

  useEffect(() => {
    const checkSettingsAndFetchPoints = async () => {
      try {
        const { data: settingsData } = await fetchAPI("/v1/settings/enable_points");
        const isEnabled = settingsData === "true" || settingsData === true;
        setEnablePoints(isEnabled);

        if (!isEnabled) {
          return;
        }

        const { data }: { data: any[] } = await fetchAPI("/v1/gamification/me");
        if (data) {
          setPointsHistory(Array.isArray(data) ? data : []);

          const grouped = data.reduce((acc, entry) => {
            const key = entry.event_type.name;
            if (!acc[key]) acc[key] = [];
            acc[key].push(entry);
            return acc;
          }, {} as Record<string, any[]>);

          setGroupedPoints(grouped);
        }
      } catch (err) {
        console.error("Error al obtener historial de puntos:", err);
      }
    };
    checkSettingsAndFetchPoints();
  }, [router]);

  if (enablePoints === null) return null;

  if (!enablePoints) {
    return (
      <Box
        sx={{
          minHeight: "100vh",
          background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          p: 8,
        }}
      >
        <Typography variant="h6" color="textSecondary">
          Esta funcionalidad no está habilitada en este momento.
        </Typography>
      </Box>
    );
  }

  const eventTypes = Object.keys(groupedPoints);
  const filteredPoints = selectedTab === "all" ? pointsHistory : groupedPoints[selectedTab] || [];
  const totalPoints = pointsHistory.reduce((sum, entry) => sum + entry.points, 0);

  return (
    <Box
      sx={{
        minHeight: "100vh",
        background: "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)",
        py: { xs: 4, md: 8 },
        px: { xs: 2, md: 8 },
      }}
    >
      <Box sx={{ maxWidth: "1200px", mx: "auto" }}>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Box sx={{ mb: 6, textAlign: "center" }}>
            <Typography variant="h3" sx={{ fontWeight: "bold", mb: 1 }}>
              <GradientText>Historial de Puntos</GradientText>
            </Typography>
            <Typography variant="subtitle1" color="text.secondary">
              Tu progreso y logros en la plataforma
            </Typography>
          </Box>
        </motion.div>

        <StyledTabs
          value={selectedTab}
          onChange={(_, val) => setSelectedTab(val)}
          variant="scrollable"
          scrollButtons="auto"
          sx={{ 
            mb: 4,
            "& .MuiTabs-scroller": {
              padding: "0 16px",
            },
            background: "rgba(255, 255, 255, 0.7)",
            borderRadius: theme.shape.borderRadius,
            px: 2,
            py: 1,
          }}
        >
          <Tab label="Todos" value="all" />
          {eventTypes.map((type) => (
            <Tab 
              key={type} 
              label={type.replace(/_/g, " ")} 
              value={type} 
              icon={<TimelineIcon type={type} />}
              iconPosition="start"
            />
          ))}
        </StyledTabs>

        <StyledGlassCard sx={{ p: { xs: 4, md: 6 } }}>
          <Box
            sx={{
              display: "flex",
              flexDirection: { xs: "column", md: "row" },
              alignItems: { xs: "flex-start", md: "center" },
              justifyContent: "space-between",
              mb: 6,
              gap: 3,
            }}
          >
            <Box>
              <Typography variant="h6" color="text.secondary" sx={{ mb: 1 }}>
                Puntos Totales
              </Typography>
              <Typography 
                variant="h3" 
                sx={{ 
                  fontWeight: "bold",
                  background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent',
                  display: 'inline-block'
                }}
              >
                {totalPoints}
              </Typography>
            </Box>
            {user && (
              <Box sx={{ textAlign: { xs: "left", md: "right" } }}>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                  Nivel Actual
                </Typography>
                <PointsBadge
                  label="Experto"
                />
              </Box>
            )}
          </Box>

          <Box sx={{ "& > * + *": { mt: 4 } }}>
            <AnimatePresence>
              {filteredPoints.map((entry, index) => (
                <TimelineItemContainer
                  key={index}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.3 }}
                >
                  <TimelineIcon type={entry.event_type.name} />
                  <Box sx={{ flex: 1 }}>
                    <Box
                      sx={{
                        display: "flex",
                        flexDirection: { xs: "column", sm: "row" },
                        justifyContent: "space-between",
                        alignItems: { xs: "flex-start", sm: "center" },
                        mb: 2,
                        gap: 1,
                      }}
                    >
                      <Typography variant="h6" sx={{ color: "text.primary", fontWeight: "semibold" }}>
                        +{entry.points} puntos
                      </Typography>
                      <Typography variant="body2" color="text.secondary">
                        {new Date(entry.created_at).toLocaleDateString("es-ES", {
                          day: "numeric",
                          month: "short",
                          year: "numeric",
                        })}
                      </Typography>
                    </Box>
                    <Typography variant="body1" sx={{ color: "text.primary", mb: 2 }}>
                      {entry.event_type.description}
                    </Typography>
                    <Chip
                      label={entry.event_type.name}
                      size="small"
                      sx={{ 
                        background: theme.palette.action.selected,
                        color: theme.palette.text.primary,
                      }}
                    />
                  </Box>
                </TimelineItemContainer>
              ))}
            </AnimatePresence>

            {filteredPoints.length === 0 && (
              <EmptyState
                icon="📊"
                title="Aún no tienes puntos"
                description="Realiza actividades en la plataforma para ganar puntos"
              />
            )}
          </Box>
        </StyledGlassCard>
      </Box>
    </Box>
  );
}

// frontend/src/app/user/transactions/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box,
  Typography,
  Avatar,
  Chip,
  Divider,
  useTheme,
  styled,
  Tabs,
  Tab
} from "@mui/material";
import {
  History,
  ArrowUpward,
  ArrowDownward,
  Paid,
  CreditCard,
  AccountBalance,
  CheckCircle,
  Pending,
  Error
} from "@mui/icons-material";

interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string;
}

const TransactionCard = styled(Box)(({ theme }) => ({
  background: 'rgba(248, 249, 250, 0.85)',
  backdropFilter: 'blur(10px)',
  borderRadius: '16px',
  padding: theme.spacing(3),
  boxShadow: theme.shadows[4],
  border: '1px solid rgba(222, 226, 230, 0.5)',
  transition: 'all 0.3s ease',
  '&:hover': {
    transform: 'translateY(-4px)',
    boxShadow: theme.shadows[6],
    background: 'rgba(248, 249, 250, 0.95)'
  }
}));

const StyledTabs = styled(Tabs)(({ theme }) => ({
  '& .MuiTabs-indicator': {
    backgroundColor: theme.palette.primary.main,
    height: 3,
    borderRadius: '2px'
  },
  '& .MuiTab-root': {
    color: theme.palette.text.primary,
    opacity: 0.8,
    fontSize: '0.875rem',
    fontWeight: 500,
    textTransform: 'capitalize',
    padding: '12px 16px',
    minHeight: 'auto',
    '&.Mui-selected': {
      color: theme.palette.primary.main,
      opacity: 1,
      fontWeight: 600
    },
    '&:hover': {
      opacity: 1,
      color: theme.palette.primary.dark
    }
  }
}));

const StatusChip = styled(Chip)(({ theme }) => ({
  borderRadius: '8px',
  fontWeight: 600,
  fontSize: '0.75rem',
  padding: '2px 8px',
  height: 'auto',
  color: 'white',
  '&.MuiChip-colorSuccess': {
    backgroundColor: theme.palette.success.main
  },
  '&.MuiChip-colorWarning': {
    backgroundColor: theme.palette.warning.main
  },
  '&.MuiChip-colorError': {
    backgroundColor: theme.palette.error.main
  }
}));

export default function TransactionsPage() {
  const { user } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [typeFilter, setTypeFilter] = useState<string>('all');
  const [statusFilter, setStatusFilter] = useState<string>('all');
  const [enableCredits, setEnableCredits] = useState<boolean | null>(null);

  useEffect(() => {
    const checkSettingsAndFetchTransactions = async () => {
      try {
        const { data: settingsData } = await fetchAPI("/v1/settings/disable_credits");
        const isEnabled = settingsData !== "true" && settingsData !== true;
        setEnableCredits(isEnabled);

        if (!isEnabled) {
          return;
        }

        const { data } = await fetchAPI<CreditTransaction[]>("/v1/payments/transactions");
        setTransactions(data || []);
      } catch (err) {
        setError((err as Error)?.message || "Error al cargar transacciones");
      }
    };
    checkSettingsAndFetchTransactions();
  }, [router]);

  const filtered = transactions.filter(t => {
    // Filtro por tipo (entrada/salida)
    if (typeFilter === 'in') return t.amount > 0;
    if (typeFilter === 'out') return t.amount < 0;
    if (typeFilter !== 'all') return false;
    
    // Filtro por estado
    if (statusFilter === 'completed') return t.payment_status === 'completed';
    if (statusFilter === 'pending') return t.payment_status === 'pending';
    if (statusFilter === 'failed') return t.payment_status === 'failed';
    
    // Todos
    return true;
  });

  const getPaymentMethodIcon = (method?: string) => {
    switch (method?.toLowerCase()) {
      case 'card':
        return <CreditCard fontSize="small" />;
      case 'bank':
        return <AccountBalance fontSize="small" />;
      default:
        return <Paid fontSize="small" />;
    }
  };

  if (enableCredits === null) return null;

  if (!enableCredits) {
    return (
      <Box sx={{
        minHeight: "100vh",
        background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        p: 4
      }}>
        <Typography variant="h6" color="text.secondary">
          Esta funcionalidad no está habilitada en este momento.
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)',
      p: { xs: 2, md: 4 },
      color: 'text.primary'
    }}>
      <Box sx={{ 
        maxWidth: "1200px", 
        mx: "auto",
        position: 'relative'
      }}>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Typography
            variant="h3"
            sx={{
              mb: 4,
              fontWeight: "bold",
              background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              display: 'inline-block',
              letterSpacing: '-0.5px'
            }}
          >
            Historial de Transacciones
          </Typography>
        </motion.div>

        <Box sx={{ display: 'flex', gap: 2, mb: 4, flexDirection: { xs: 'column', sm: 'row' } }}>
          <StyledTabs
            value={typeFilter}
            onChange={(e, newValue) => {
              setTypeFilter(newValue);
              setStatusFilter('all'); // Reset status filter when changing type
            }}
            textColor="primary"
            indicatorColor="primary"
            variant="scrollable"
            scrollButtons="auto"
            sx={{ 
              background: 'rgba(255, 255, 255, 0.7)',
              borderRadius: '12px',
              padding: '4px',
              boxShadow: theme.shadows[1]
            }}
          >
            <Tab label="Todas" value="all" />
            <Tab label="Entradas" value="in" icon={<ArrowDownward fontSize="small" />} iconPosition="start" />
            <Tab label="Salidas" value="out" icon={<ArrowUpward fontSize="small" />} iconPosition="start" />
          </StyledTabs>

          <StyledTabs
            value={statusFilter}
            onChange={(e, newValue) => {
              setStatusFilter(newValue);
              setTypeFilter('all'); // Reset type filter when changing status
            }}
            textColor="primary"
            indicatorColor="primary"
            variant="scrollable"
            scrollButtons="auto"
            sx={{ 
              background: 'rgba(255, 255, 255, 0.7)',
              borderRadius: '12px',
              padding: '4px',
              boxShadow: theme.shadows[1]
            }}
          >
            <Tab label="Todos estados" value="all" />
            <Tab label="Completadas" value="completed" icon={<CheckCircle fontSize="small" />} iconPosition="start" />
            <Tab label="Pendientes" value="pending" icon={<Pending fontSize="small" />} iconPosition="start" />
            <Tab label="Fallidas" value="failed" icon={<Error fontSize="small" />} iconPosition="start" />
          </StyledTabs>
        </Box>

        {filtered.length === 0 ? (
          <Box sx={{
            textAlign: 'center',
            py: 6,
            background: 'rgba(255, 255, 255, 0.7)',
            borderRadius: '24px',
            backdropFilter: 'blur(12px)',
            border: '1px solid rgba(222, 226, 230, 0.5)',
            boxShadow: theme.shadows[2]
          }}>
            <History sx={{ 
              fontSize: 48, 
              color: 'text.secondary', 
              mb: 2,
              opacity: 0.5
            }} />
            <Typography variant="h6" color="text.secondary">
              No hay transacciones registradas
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              {user ? 'Todas tus transacciones aparecerán aquí' : 'Las transacciones de créditos aparecerán aquí'}
            </Typography>
          </Box>
        ) : (
          <AnimatePresence>
            <Box
              sx={{
                display: 'grid',
                gridTemplateColumns: { xs: '1fr', sm: 'repeat(2, 1fr)', lg: 'repeat(3, 1fr)' },
                gap: 3
              }}
            >
              {filtered.map((t) => (
                <motion.div
                  key={t.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  whileHover={{ scale: 1.02 }}
                >
                  <TransactionCard>
                    <Box sx={{ 
                      display: 'flex', 
                      alignItems: 'center', 
                      gap: 2, 
                      mb: 2 
                    }}>
                      <Avatar
                        sx={{
                          bgcolor: t.amount > 0 ? 'success.main' : 'error.main',
                          color: 'white',
                          width: 48,
                          height: 48,
                          boxShadow: theme.shadows[2]
                        }}
                      >
                        {t.amount > 0 ? <ArrowDownward /> : <ArrowUpward />}
                      </Avatar>
                      <Box sx={{ overflow: 'hidden' }}>
                        <Typography 
                          variant="h6" 
                          fontWeight="bold"
                          noWrap
                          color="text.primary"
                        >
                          {t.transaction_type}
                        </Typography>
                        <Box sx={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          gap: 1,
                          mt: 0.5
                        }}>
                          <Typography 
                            variant="body2" 
                            color="text.secondary"
                            fontSize="0.75rem"
                          >
                            {new Date(t.timestamp).toLocaleString()}
                          </Typography>
                          <StatusChip 
                            label={t.payment_status} 
                            size="small"
                            color={
                              t.payment_status === 'completed' ? 'success' : 
                              t.payment_status === 'pending' ? 'warning' : 'error'
                            }
                          />
                        </Box>
                      </Box>
                    </Box>
                    <Divider sx={{ 
                      mb: 2, 
                      borderColor: 'rgba(0,0,0,0.1)' 
                    }} />
                    <Typography
                      variant="h5"
                      color={t.amount > 0 ? "success.dark" : "error.dark"}
                      fontWeight="bold"
                      sx={{ mb: 1 }}
                    >
                      {t.amount > 0 ? '+' : ''}{t.amount} créditos
                    </Typography>
                    {user && t.payment_amount && (
                      <Box sx={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 1,
                        mt: 2
                      }}>
                        <Box sx={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: 0.5,
                          color: 'text.secondary'
                        }}>
                          {getPaymentMethodIcon(t.payment_method)}
                          <Typography variant="body2">
                            ${t.payment_amount.toFixed(2)}
                          </Typography>
                        </Box>
                        {t.payment_method && (
                          <Typography 
                            variant="caption" 
                            color="text.secondary"
                            sx={{ ml: 0.5 }}
                          >
                            • {t.payment_method}
                          </Typography>
                        )}
                      </Box>
                    )}
                  </TransactionCard>
                </motion.div>
              ))}
            </Box>
          </AnimatePresence>
        )}
      </Box>
    </Box>
  );
}


##  ¿Qué necesitas?

Por favor, pideme los archivos que necesites para implantar tu solucíón.Genera el codigo de los archivos que modifiques 
y los nuevos creados de forma completo, sin obviar ninguna parte.


Aborda mi solicitud  respetando la lógica actual de la aplicación y siguiendo mis instrucciones al pie de la letra.

 Generara los códigos y ficheros siempre completos.Indicame si necesitas más archivos para ciertas implementaciones y te los proporcionaré.
 
 Si necesitas más ayuda o necesitas código adicional que ver, no dudes en decírmelo. 
 
  implementar las mejoras solicitadas de manera clara y estructurada
  Se que es muchiiiisima información, por favor leela toda con detenimiento. 
  Respeta la logica actual para no romper ningun servicio activo. 
  Es importante esta parte que salga bien, tomate tu tiempo.
 
 Ya puedes  proceder paso a paso



