
Parte 4: Unificar modelos de usuarios guest y user
Unificar los modelos de usuarios anónimos (guest) y registrados (user) en un solo modelo es un cambio importante. 
Aquí te propongo un enfoque para hacerlo sin romper la aplicación:
Estrategia

    Modelo unificado:
        Crea un modelo User con campos como:
            id (único)
            type ("guest" | "registered")
            username (opcional para guests, obligatorio para registered)
            email (opcional para guests)
            password (solo para registered)
            created_at, etc.
        Ejemplo en SQL:
        sql

        CREATE TABLE users (
          id SERIAL PRIMARY KEY,
          type VARCHAR(10) NOT NULL DEFAULT 'guest',
          username VARCHAR(50),
          email VARCHAR(255),
          password VARCHAR(255),
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );

    Migración gradual:
        Mantén las tablas actuales (guests y users) y crea una nueva tabla users_unified.
        Migra los datos existentes a la nueva tabla en lotes o al vuelo (cuando un usuario interactúe).
        Actualiza las consultas para usar la nueva tabla solo cuando esté lista.
    Actualizar lógica:
        En el frontend (Navbar.tsx), usa user.type para diferenciar entre guest y registered en lugar de depender de anonUsername.
        En el backend, ajusta las rutas para manejar un solo modelo.

Consideraciones

    No romper la aplicación: Implementa esto en paralelo, dejando la lógica actual como fallback hasta que la unificación esté completa.
    Permisos: Asegúrate de que las acciones restringidas (ej. admin) verifiquen type y otros campos relevantes.
    Archivos necesarios: Necesitaría ver cómo están definidos los modelos actuales en tu backend (ej. en TypeScript o una base de datos) y cómo se manejan en useAuth (@/lib/auth/context) para darte un plan más detallado.


Archivos que necesito:

    Modelos de usuario actuales y useAuth (@/lib/auth/context) para la unificación.

Si prefieres que desarrolle más alguna sección o me envíes los archivos, ¡avísame! ¿Qué te parece esta propuesta?

Parte 2: Unificación de modelos de usuarios

El objetivo es unificar los modelos User (usuarios registrados) y GuestsSession (usuarios anónimos) en un solo modelo User, 
manteniendo la lógica actual como respaldo hasta que la unificación esté completamente probada.

Paso 1: Modificar el modelo User
Actualizaremos backend/models/user.py para soportar ambos tipos de usuarios añadiendo un campo type 
y haciendo algunos campos opcionales para usuarios anónimos.

python

from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Enum
from sqlalchemy.orm import relationship
from core.database import Base
import enum

class UserTypeEnum(enum.Enum):
    REGISTERED = "registered"
    ANONYMOUS = "anonymous"

class SubscriptionEnum(enum.Enum):
    FREEMIUM = "freemium"
    PREMIUM = "premium"
    CORPORATE = "corporate"

class User(Base):
    __tablename__ = "usuarios"
    
    id = Column(Integer, primary_key=True, index=True)
    type = Column(Enum(UserTypeEnum), default=UserTypeEnum.REGISTERED, nullable=False)
    email = Column(String(255), unique=True, index=True, nullable=True)  # Nullable para anónimos
    username = Column(String(50), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=True)  # Nullable para anónimos
    auth_provider = Column(String(20), nullable=True)
    provider_id = Column(String(255), nullable=True)
    rol = Column(String(20), default="user")
    activo = Column(Boolean, default=True)
    subscription = Column(Enum(SubscriptionEnum), default=SubscriptionEnum.FREEMIUM)
    ciudad = Column(String(100), nullable=True)
    website = Column(String(255), nullable=True)
    credits = Column(Integer, default=100)
    create_at = Column(DateTime, default=datetime.utcnow)
    renewal = Column(DateTime, nullable=True)
    last_ip = Column(String(45), nullable=True)
    last_login = Column(DateTime, nullable=True)
    token_valid_until = Column(DateTime, nullable=True)
    session_id = Column(String(36), nullable=True, unique=True)  # Para usuarios anónimos
    
    gamification_events = relationship("GamificationEvent", back_populates="user")
    gamification = relationship("UserGamification", back_populates="user")

Cambios:

    -Añadido type para distinguir entre "registered" y "anonymous".
    -email y password_hash ahora son nullable para usuarios anónimos.
    -Añadido session_id como campo opcional para identificar a usuarios anónimos.

Paso 2: Actualizar modelos de gamificación
En backend/models/gamification.py, eliminaremos la distinción entre user_id y session_id, usando solo user_id para referenciar al modelo unificado User.
python

from sqlalchemy import Column, Integer, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime

class GamificationEvent(Base):
    __tablename__ = "gamification_events"
    id = Column(Integer, primary_key=True, index=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"))
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=False)
    timestamp = Column(DateTime, default=datetime.utcnow)

    event_type = relationship("EventType", back_populates="events")
    user = relationship("User", back_populates="gamification_events")

class UserGamification(Base):
    __tablename__ = "user_gamification"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=False)
    event_type_id = Column(Integer, ForeignKey("event_types.id"))
    points = Column(Integer, default=0)
    badge_id = Column(Integer, ForeignKey("badges.id"), nullable=True)

    user = relationship("User", back_populates="gamification")
    event_type = relationship("EventType")
    badge = relationship("Badge")

Cambios:

    Eliminado session_id de ambos modelos.
    user_id ahora referencia directamente a usuarios.id.

Paso 3: Modificar gamification_service.py para el modelo unificado
Actualizaremos las funciones en gamification_service.py para usar únicamente user.user_id como identificador, ya que ahora todos los usuarios (registrados y anónimos) tienen un id en la tabla usuarios.
Aquí está la versión actualizada de las funciones clave:
python

def register_event(db: Session, event: GamificationEventCreate, user: UserContext) -> GamificationEvent:
    """Registra un evento de gamificación y actualiza los puntos del usuario."""
    db_event = GamificationEvent(
        event_type_id=event.event_type_id,
        user_id=int(user.user_id)  # user_id es ahora universal
    )
    db.add(db_event)
    db.commit()
    db.refresh(db_event)
    
    gamification = update_user_gamification(db, user, event.event_type_id)
    
    # Notificar actualización de puntos
    asyncio.create_task(
        notify_user(
            user.user_id,
            "pointsUpdate",
            {"points": gamification.points}
        )
    )
    
    # Notificar nuevo badge si se otorgó uno
    if gamification.badge:
        badge_dict = {
            "id": gamification.badge.id,
            "name": gamification.badge.name,
            "description": gamification.badge.description,
            "event_type_id": gamification.badge.event_type_id,
            "required_points": gamification.badge.required_points,
            "user_type": gamification.badge.user_type
        }
        asyncio.create_task(
            notify_user(
                user.user_id,
                "newBadge",
                badge_dict
            )
        )
    
    return db_event

def get_user_gamification(db: Session, user: UserContext) -> List[UserGamification]:
    """Obtiene todos los registros de gamificación del usuario."""
    return db.query(UserGamification).filter(UserGamification.user_id == int(user.user_id)).all()

def get_user_events(db: Session, user: UserContext) -> List[GamificationEvent]:
    """Obtiene todos los eventos de gamificación del usuario."""
    return db.query(GamificationEvent).filter(GamificationEvent.user_id == int(user.user_id)).all()

def update_user_gamification(db: Session, user: UserContext, event_type_id: int) -> UserGamification:
    """Actualiza la gamificación del usuario para un tipo de evento específico."""
    logging.info(f"Actualizando gamificación para user_id={user.user_id}, event_type_id={event_type_id}")
    user_id = int(user.user_id)

    gamification = db.query(UserGamification).filter(
        UserGamification.user_id == user_id,
        UserGamification.event_type_id == event_type_id
    ).first()
    if not gamification:
        gamification = UserGamification(
            user_id=user_id,
            event_type_id=event_type_id,
            points=0
        )
        db.add(gamification)
        logging.info("Creado nuevo registro de UserGamification")

    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise ValueError("Event type not found")

    events_count = db.query(GamificationEvent).filter(
        GamificationEvent.event_type_id == event_type_id,
        GamificationEvent.user_id == user_id
    ).count()
    logging.info(f"Contados {events_count} eventos para event_type_id={event_type_id}")

    gamification.points = events_count * event_type.points_per_event

    badge = db.query(Badge).filter(
        Badge.event_type_id == event_type_id,
        Badge.user_type.in_([user.user_type, "both"]),
        Badge.required_points <= gamification.points
    ).order_by(Badge.required_points.desc()).first()
    logging.info(f"Badge encontrado: {badge.id if badge else 'None'}")

    gamification.badge_id = badge.id if badge else None
    db.commit()
    db.refresh(gamification)
    return gamification

Cambios:

    Eliminada la lógica condicional para user_id y session_id. Ahora solo se usa user.user_id.
    Las consultas ahora filtran únicamente por user_id, simplificando el código.


Paso 4: Consideraciones adicionales

    Migración de datos: Si ya existen registros en GuestsSession y UserGamification/GamificationEvent con session_id, necesitarás migrarlos a la nueva estructura. Por ejemplo:
        Crear entradas en usuarios con type="anonymous" para cada GuestsSession.
        Actualizar user_id en GamificationEvent y UserGamification con el nuevo id del usuario anónimo.
    Actualización de otros servicios: Revisa otros archivos como backend/dependencies/auth.py para asegurar que UserContext se construya correctamente con el modelo unificado.
    Frontend: Asegúrate de que el frontend use user.user_id consistentemente, independientemente del tipo de usuario.


Resumen

    Parte 2: Se unificaron los modelos de usuarios en User, eliminando la necesidad de GuestsSession, y se actualizó gamification_service.py para usar únicamente user_id. La implementación es compatible con la lógica existente como respaldo.

Si necesitas más detalles, ajustes o ayuda con la migración de datos, ¡avísame!

----------------------------

migracion de ids:
    
    (.venv) (.venv) vinxenxo@LAPTOP-CGBLO0V1:~/neptuno/neptuno$ PYTHONPATH=/home/vinxenxo/neptuno/neptuno/backend/ alembic upgrade head
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 59f373d5b1b3 -> 0132a7ac5c83, user
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1964, in _exec_single_context
    self.dialect.do_execute(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py", line 942, in do_execute
    cursor.execute(statement, parameters)
sqlite3.OperationalError: no such table: usuarios

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/bin/alembic", line 8, in <module>
    sys.exit(main())
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/config.py", line 636, in main
    CommandLine(prog=prog).main(argv=argv)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/config.py", line 626, in main
    self.run_cmd(cfg, options)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/config.py", line 603, in run_cmd
    fn(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/command.py", line 408, in upgrade
    script.run_env()
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/script/base.py", line 586, in run_env
    util.load_python_file(self.dir, "env.py")
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/util/pyfiles.py", line 95, in load_python_file
    module = load_module_py(module_id, path)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/util/pyfiles.py", line 113, in load_module_py
    spec.loader.exec_module(module)  # type: ignore
  File "<frozen importlib._bootstrap_external>", line 883, in exec_module
  File "<frozen importlib._bootstrap>", line 241, in _call_with_frames_removed
  File "/home/vinxenxo/neptuno/neptuno/migrations/env.py", line 81, in <module>
    run_migrations_online()
  File "/home/vinxenxo/neptuno/neptuno/migrations/env.py", line 75, in run_migrations_online
    context.run_migrations()
  File "<string>", line 8, in run_migrations
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/runtime/environment.py", line 946, in run_migrations
    self.get_context().run_migrations(**kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/runtime/migration.py", line 623, in run_migrations
    step.migration_fn(**kw)
  File "/home/vinxenxo/neptuno/neptuno/migrations/versions/0132a7ac5c83_user.py", line 24, in upgrade
    op.add_column(
  File "<string>", line 8, in add_column
  File "<string>", line 3, in add_column
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/operations/ops.py", line 2157, in add_column
    return operations.invoke(op)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/operations/base.py", line 441, in invoke
    return fn(self, operation)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/operations/toimpl.py", line 170, in add_column
    operations.impl.add_column(table_name, column, schema=schema, **kw)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/ddl/impl.py", line 373, in add_column
    self._exec(base.AddColumn(table_name, column, schema=schema))
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/alembic/ddl/impl.py", line 246, in _exec
    return conn.execute(construct, params)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1416, in execute
    return meth(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/sql/ddl.py", line 180, in _execute_on_connection
    return connection._execute_ddl(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1527, in _execute_ddl
    ret = self._execute_context(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1843, in _execute_context
    return self._exec_single_context(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1983, in _exec_single_context
    self._handle_dbapi_exception(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 2352, in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/base.py", line 1964, in _exec_single_context
    self.dialect.do_execute(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/sqlalchemy/engine/default.py", line 942, in do_execute
    cursor.execute(statement, parameters)
sqlalchemy.exc.OperationalError: (sqlite3.OperationalError) no such table: usuarios
[SQL: ALTER TABLE usuarios ADD COLUMN type VARCHAR(10) DEFAULT 'registered' NOT NULL]
(Background on this error at: https://sqlalche.me/e/20/e3q8)


--

INFO:     127.0.0.1:56547 - "GET /info HTTP/1.1" 500 Internal Server Error
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 212, in run_endpoint_function
    return await dependant.call(**values)
  File "/home/vinxenxo/neptuno/neptuno/backend/main.py", line 312, in get_info
    "session_id": user.session_id if user.user_type == "anonymous" else None
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/pydantic/main.py", line 891, in __getattr__
    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
AttributeError: 'UserContext' object has no attribute 'session_id'