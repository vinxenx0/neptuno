Excellent, implement the rest of the API in GraphQL:

# backend/api/v1/site_settings.py
from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from schemas.site_settings import SiteSettingResponse
from services.origin_service import add_allowed_origin, delete_allowed_origin
from models.user import User
from dependencies.auth import UserContext, get_user_context
from services.settings_service import get_all_settings, set_setting, update_setting, get_setting
from core.database import get_db
from core.logging import configure_logging
from pydantic import BaseModel

router = APIRouter(tags=["site_settings"])

logger = configure_logging()


class AddOriginRequest(BaseModel):
    origin: str


@router.post("/allowed-origins")
async def add_origin(request: AddOriginRequest,
                     user: UserContext = Depends(get_user_context),
                     db: Session = Depends(get_db)):
    origin = request.origin
    allowed_origins = get_setting(db, "allowed_origins") or []
    if origin in allowed_origins:
        raise HTTPException(status_code=400, detail="Origen ya existe")
    allowed_origins.append(origin)
    return set_setting(db, "allowed_origins", allowed_origins, user.user_id,
                       "Orígenes permitidos para CORS")


@router.delete("/allowed-origins/{origin}")
async def remove_origin(origin: str,
                        user: UserContext = Depends(get_user_context),
                        db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo administradores")
    return delete_allowed_origin(db, origin, user.user_id)


@router.get("/admin/config", response_model=List[SiteSettingResponse])
def get_admin_config(user=Depends(get_user_context),
                     db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo administradores")
    return get_all_settings(db, user.user_id)


class UpdateConfigRequest(BaseModel):
    key: str
    value: dict | list | int | str
    description: str | None = None


@router.post("/admin/config")
async def update_config(request: UpdateConfigRequest,
                        user: UserContext = Depends(get_user_context),
                        db: Session = Depends(get_db)):
    return set_setting(db, request.key, request.value, user.user_id,
                       request.description)


@router.put("/{key}")
def update_site_setting(key: str,
                        value: str,
                        description: str = None,
                        user: UserContext = Depends(get_user_context),
                        db: Session = Depends(get_db)):
    if user.user_type != "registered" or not db.query(User).filter(
            User.id == user.user_id, User.rol == "admin").first():
        raise HTTPException(status_code=403, detail="Solo administradores")
    return update_setting(db, user.user_id, key, value, description)


@router.get("/{key}")
def get_site_setting(key: str, db: Session = Depends(get_db)):
    return get_setting(db, key)


# backend/models/site_settings.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from datetime import datetime
from core.database import Base

class SiteSettings(Base):
    __tablename__ = "site_settings"
    
    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(50), unique=True, nullable=False)
    value = Column(String(255), nullable=False)
    description = Column(String(255), nullable=True)
    tag = Column(String(50), nullable=True) # Nuevo atributo
    updated_by = Column(Integer, nullable=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Claves esperadas (documentación):
    # - token_expiration: int (segundos)
    # - refresh_token_expiration: int (segundos)
    # - rate_limit_auth: {"times": int, "seconds": int}
    # - rate_limit_api: {"times": int, "seconds": int}
    # - rate_limit_admin: {"times": int, "seconds": int}
    # - cache_ttl: int (segundos)
    # - cache_enabled: bool
    # - allowed_origins: list[str]
    # - celery_workers: int
    # - celery_task_timeout: int (segundos)
    # - db_pool_size: int
    # - db_max_overflow: int
    # - db_pool_timeout: int (segundos)
    # - freemium_credits: int
    # - premium_credits: int
    # - credit_reset_interval: int (días)
    # - log_level: str ("DEBUG", "INFO", "WARNING", "ERROR")

# backend/schemas/site_settings.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SiteSettingBase(BaseModel):
    key: str
    value: str
    description: Optional[str] = None
    tag: Optional[str] = None

class SiteSettingCreate(SiteSettingBase):
    pass

class SiteSettingResponse(SiteSettingBase):
    id: int
    updated_by: Optional[int] = None
    updated_at: datetime

    class Config:
        orm_mode = True


# backend/services/settings_service.py
import json
from sqlalchemy.orm import Session
from models.site_settings import SiteSettings
from core.logging import configure_logging
from fastapi import HTTPException

logger = configure_logging()

def update_setting(db: Session, admin_id: str, key: str, value: str, description: str = None, tag: str = None):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden modificar ajustes")
        
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        if setting:
            setting.value = value
            setting.description = description
            setting.tag = tag
            setting.updated_by = admin_id
        else:
            setting = SiteSettings(key=key, value=value, description=description, tag=tag, updated_by=admin_id)
            db.add(setting)
        db.commit()
        logger.info(f"Ajuste {key} actualizado por admin ID {admin_id}")
        return {"key": key, "value": value, "tag": tag}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al actualizar ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al actualizar ajuste")

def get_all_settings(db: Session, admin_id: str):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden ver configuraciones")
        
        settings = db.query(SiteSettings).all()
        return settings
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al obtener ajustes para admin {admin_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener ajustes")

def get_setting(db: Session, key: str) -> dict | list | int | str | None:
    try:
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        if not setting:
            return None
        value = setting.value
        try:
            return json.loads(value)  # Intentar deserializar como JSON
        except json.JSONDecodeError:
            # Si falla, intentar limpiar comillas adicionales y devolver la cadena
            cleaned_value = value.strip('"')
            try:
                return json.loads(cleaned_value)  # Reintentar con el valor limpio
            except json.JSONDecodeError:
                return cleaned_value  # Devolver la cadena limpia si no es JSON válido
    except Exception as e:
        logger.error(f"Error al obtener ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener ajuste")

def set_setting(db: Session, key: str, value: any, admin_id: str, description: str = None):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden modificar configuraciones")
        
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        serialized_value = json.dumps(value)  # Serializar a JSON
        if setting:
            setting.value = serialized_value
            setting.description = description or setting.description
        else:
            setting = SiteSettings(key=key, value=serialized_value, description=description)
            db.add(setting)
        db.commit()
        logger.info(f"Configuración '{key}' actualizada por admin {admin_id}: {value}")
        return {"key": key, "value": value}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al establecer ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al establecer ajuste")


# backend/api/v1/payments.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from services.payment_service import add_payment_method, delete_payment_method, get_credit_transactions, get_payment_methods, purchase_credits, set_default_payment_method, update_payment_method
from core.database import get_db
from core.logging import configure_logging
from schemas.payment import CreditTransactionResponse, PurchaseRequest, PaymentMethodCreate, PaymentMethodResponse, PurchaseResponse

router = APIRouter(tags=["payments"])

logger = configure_logging()


@router.post("/purchase", response_model=PurchaseResponse)
async def buy_credits(request: PurchaseRequest,
                      user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden comprar créditos")
    return purchase_credits(db, int(user.user_id), request.credits,
                            request.payment_amount, request.payment_method)


@router.post("/methods", response_model=PaymentMethodResponse)
def add_method(method: PaymentMethodCreate,
               user: UserContext = Depends(get_user_context),
               db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden añadir métodos de pago")
    return add_payment_method(db, int(user.user_id), method.payment_type,
                              method.details, method.is_default)


@router.get("/methods", response_model=list[PaymentMethodResponse])
def list_methods(user: UserContext = Depends(get_user_context),
                 db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden ver sus métodos de pago")
    return get_payment_methods(db, int(user.user_id))


@router.put("/methods/{method_id}/default",
            response_model=PaymentMethodResponse)
def set_default(method_id: int,
                user: UserContext = Depends(get_user_context),
                db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail=
            "Solo usuarios registrados pueden establecer un método de pago por defecto"
        )
    return set_default_payment_method(db, int(user.user_id), method_id)


@router.get("/transactions", response_model=list[CreditTransactionResponse])
def list_transactions(user: UserContext = Depends(get_user_context),
                      db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden ver sus transacciones")
    return get_credit_transactions(db, int(user.user_id))


@router.put("/methods/{method_id}", response_model=PaymentMethodResponse)
def update_method(
        method_id: int,
        method: PaymentMethodCreate,
        user: UserContext = Depends(get_user_context),
        db: Session = Depends(get_db),
):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden actualizar métodos de pago"
        )
    return update_payment_method(db, int(user.user_id), method_id,
                                 method.payment_type, method.details)


@router.delete("/methods/{method_id}")
def delete_method(
        method_id: int,
        user: UserContext = Depends(get_user_context),
        db: Session = Depends(get_db),
):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden eliminar métodos de pago")
    delete_payment_method(db, int(user.user_id), method_id)
    return {"message": "Método de pago eliminado"}


# backend/api/v1/payment_providers.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.payment_provider_service import (
    create_payment_provider, get_payment_providers, update_payment_provider, delete_payment_provider
)
from schemas.payment import PaymentProviderCreate, PaymentProviderResponse
from typing import List

router = APIRouter(tags=["Payment Providers"])

@router.get("/", response_model=List[PaymentProviderResponse])
def get_providers(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.user_type != "registered" and user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Acceso no autorizado")
    return get_payment_providers(db)

@router.post("/", response_model=PaymentProviderResponse, status_code=status.HTTP_201_CREATED)
def create_provider(provider_data: PaymentProviderCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Se requieren privilegios de administrador")
    return create_payment_provider(db, provider_data)

@router.put("/{provider_id}", response_model=PaymentProviderResponse)
def update_provider(provider_id: int, provider_update: PaymentProviderCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Se requieren privilegios de administrador")
    return update_payment_provider(db, provider_id, provider_update)

@router.delete("/{provider_id}", status_code=status.HTTP_204_NO_CONTENT)
def delete_provider(provider_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Se requieren privilegios de administrador")
    delete_payment_provider(db, provider_id)
    return {"detail": "Proveedor eliminado exitosamente"}

# backend/dependencies/credits.py
from fastapi import Depends, HTTPException
from sqlalchemy.orm import Session
from models.credit_transaction import CreditTransaction
from dependencies.auth import UserContext, get_user_context
from models.user import User
from models.guests import GuestsSession
from core.database import get_db
from core.logging import configure_logging
from services.integration_service import trigger_webhook
from services.settings_service import get_setting

logger = configure_logging()

async def check_credits(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_credits = get_setting(db, "disable_credits")
    
    if disable_credits != "true":  # Solo procesar créditos si no están desactivados
        try:
            if user.user_type == "registered":
                user_db = db.query(User).filter(User.id == int(user.user_id)).first()
                if not user_db:
                    raise HTTPException(status_code=404, detail="Usuario no encontrado")
                credits = user_db.credits
            else:
                session_db = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
                if not session_db:
                    raise HTTPException(status_code=404, detail="Sesión no encontrada")
                credits = session_db.credits

            if credits <= 0:
                logger.warning(f"Usuario {user.user_type} ID {user.user_id} sin créditos suficientes")
                raise HTTPException(status_code=403, detail="No te quedan créditos disponibles.")
            
            return user  # Retorna el usuario para usarlo en el endpoint
        except HTTPException as e:
            raise e
        except Exception as e:
            logger.error(f"Error inesperado en check_credits para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")
    return user  # Si los créditos están desactivados, simplemente retorna el usuario

# backend/models/payment_provider.py
from sqlalchemy import Column, Integer, String, Boolean
from models.user import Base

class PaymentProvider(Base):
    __tablename__ = "payment_providers"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "Stripe", "Paypal"
    active = Column(Boolean, default=True)  # Si está activo o no

# backend/models/payment_method.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from models.user import Base
from datetime import datetime

class PaymentMethod(Base):
    __tablename__ = "payment_methods"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=False)  # Vinculado a un usuario
    payment_type = Column(String(20), nullable=False)  # "credit_card", "paypal", "bank_transfer"
    details = Column(String(255), nullable=False)  # Datos encriptados (ej. últimos 4 dígitos, email PayPal)
    is_default = Column(Boolean, default=False)  # Método favorito
    created_at = Column(DateTime, default=datetime.utcnow)  # Fecha de creación
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)  # Última actualización

#backend/models/credit_transaction.py
# backend/models/credit_transaction.py
from sqlalchemy import CheckConstraint, Column, Integer, String, ForeignKey, DateTime, Float
from models.user import Base
from datetime import datetime


class CreditTransaction(Base):
    __tablename__ = "credit_transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36),
                        ForeignKey("sesiones_anonimas.id"),
                        nullable=True)
    user_type = Column(String(20), nullable=False) #, default="anonymous") # "registered" o "anonymous"
    amount = Column(Integer, nullable=False)
    transaction_type = Column(String(50), nullable=False)
    description = Column(String(255), nullable=True)
    payment_amount = Column(Float, nullable=True)
    payment_method = Column(String(50), nullable=True)
    payment_status = Column(String(20), default="pending")
    timestamp = Column(DateTime, default=datetime.utcnow)

    # Restricción para asegurar que solo uno de user_id o session_id esté presente
    __table_args__ = (CheckConstraint(
        "(user_id IS NOT NULL AND session_id IS NULL AND user_type = 'registered') OR "
        "(user_id IS NULL AND session_id IS NOT NULL AND user_type = 'anonymous')",
        name="check_user_or_session"), )


#backend/schemas/payment.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional


class PurchaseRequest(BaseModel):
    credits: int
    payment_amount: float
    payment_method: Optional[str] = "stripe"

class PurchaseResponse(BaseModel):
    transaction_id: int
    credits_added: int
    new_balance: int

class PaymentMethodCreate(BaseModel):
    payment_type: str
    details: str
    is_default: bool = False

class PaymentMethodResponse(BaseModel):
    id: int
    payment_type: str
    details: str
    is_default: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class CreditTransactionResponse(BaseModel):
    id: int
    amount: int
    transaction_type: str
    payment_amount: Optional[float] = None
    payment_method: Optional[str] = None
    payment_status: Optional[str] = None
    timestamp: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class PaymentProviderBase(BaseModel):
    name: str
    active: bool = True

class PaymentProviderCreate(PaymentProviderBase):
    pass

class PaymentProviderResponse(PaymentProviderBase):
    id: int

    class Config:
        from_attributes = True

#backend/schemas/credit_transaction.py
from pydantic import BaseModel
from datetime import datetime

class CreditTransactionBase(BaseModel):
    user_id: int | None
    session_id: str | None
    amount: int
    transaction_type: str
    payment_amount: float | None
    payment_method: str | None
    payment_status: str
    timestamp: datetime

class CreditTransactionResponse(CreditTransactionBase):
    id: int

    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

# backend/services/payment_service.py
from sqlalchemy.orm import Session
from schemas.payment import PaymentMethodResponse
from models.payment_method import PaymentMethod
from models.user import User
from core.logging import configure_logging
from models.credit_transaction import CreditTransaction
from fastapi import HTTPException, status

logger = configure_logging()

class StripeSimulator:
    @staticmethod
    def create_payment_intent(amount: float, currency: str = "usd"):
        return {"id": "pi_simulated", "status": "succeeded"}

stripe = StripeSimulator()

def purchase_credits(db: Session, user_id: int, credits: int, payment_amount: float, payment_method: str = "stripe"):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")

        transaction = CreditTransaction(
            user_type="registered",  # ¡Añadimos esto explícitamente!
            user_id=user_id,
            amount=credits,
            transaction_type="purchase",
            payment_amount=payment_amount,
            payment_method=payment_method,
            payment_status="pending"
        )
        db.add(transaction)
        db.commit()
        db.refresh(transaction)

        payment_intent = stripe.create_payment_intent(payment_amount)
        if payment_intent["status"] == "succeeded":
            transaction.payment_status = "completed"
            user.credits += credits
            db.commit()
            logger.info(f"Compra de {credits} créditos completada para usuario {user_id}")
            return {"transaction_id": transaction.id, "credits_added": credits, "new_balance": user.credits}
        else:
            transaction.payment_status = "failed"
            db.commit()
            raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail="Error al procesar el pago")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al procesar compra de créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar compra")

def add_payment_method(db: Session, user_id: int, payment_type: str, details: str, is_default: bool = False):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        if is_default:
            db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id, PaymentMethod.is_default == True).update({"is_default": False})
        
        payment_method = PaymentMethod(
            user_id=user_id,
            payment_type=payment_type,
            details=details,
            is_default=is_default
        )
        db.add(payment_method)
        db.commit()
        logger.info(f"Método de pago añadido para usuario ID {user_id}: {payment_type}")
        return payment_method
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al añadir método de pago para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al añadir método de pago")

def get_payment_methods(db: Session, user_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        return db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id).all()
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al listar métodos de pago para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al listar métodos de pago")

def set_default_payment_method(db: Session, user_id: int, payment_method_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        payment_method = db.query(PaymentMethod).filter(PaymentMethod.id == payment_method_id, PaymentMethod.user_id == user_id).first()
        if not payment_method:
            raise HTTPException(status_code=404, detail="Método de pago no encontrado")
        
        db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id, PaymentMethod.is_default == True).update({"is_default": False})
        payment_method.is_default = True
        db.commit()
        logger.info(f"Método de pago ID {payment_method_id} establecido como predeterminado para usuario ID {user_id}")
        return payment_method
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al establecer método de pago predeterminado para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al establecer método de pago")

def get_credit_transactions(db: Session, user_id: int):
    try:
        return db.query(CreditTransaction).filter(CreditTransaction.user_id == user_id).all()
    except Exception as e:
        logger.error(f"Error al obtener transacciones de créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener transacciones")
    
    
def update_payment_method(db: Session, user_id: int, method_id: int, payment_type: str, details: str) -> PaymentMethodResponse:
    method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id, PaymentMethod.user_id == user_id).first()
    if not method:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado")
    method.payment_type = payment_type
    method.details = details
    db.commit()
    db.refresh(method)
    return PaymentMethodResponse.from_orm(method)

def delete_payment_method(db: Session, user_id: int, method_id: int):
    method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id, PaymentMethod.user_id == user_id).first()
    if not method:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado")
    if method.is_default:
        raise HTTPException(status_code=400, detail="No se puede eliminar el método de pago predeterminado")
    db.delete(method)
    db.commit()

# backend/services/payment_provider_service.py
from sqlalchemy.orm import Session
from models.payment_provider import PaymentProvider
from schemas.payment import PaymentProviderCreate
from fastapi import HTTPException

def create_payment_provider(db: Session, provider: PaymentProviderCreate):
    existing = db.query(PaymentProvider).filter(PaymentProvider.name == provider.name).first()
    if existing:
        raise HTTPException(status_code=400, detail="Payment provider already exists")
    db_provider = PaymentProvider(**provider.dict())
    db.add(db_provider)
    db.commit()
    db.refresh(db_provider)
    return db_provider

def get_payment_providers(db: Session):
    return db.query(PaymentProvider).all()

def update_payment_provider(db: Session, provider_id: int, provider_update: PaymentProviderCreate):
    provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()
    if not provider:
        raise HTTPException(status_code=404, detail="Payment provider not found")
    for key, value in provider_update.dict().items():
        setattr(provider, key, value)
    db.commit()
    db.refresh(provider)
    return provider

def delete_payment_provider(db: Session, provider_id: int):
    provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()
    if not provider:
        raise HTTPException(status_code=404, detail="Payment provider not found")
    db.delete(provider)
    db.commit()
    return {"message": "Payment provider deleted"}

# backend/services/credits_service.py
# Permitir la renovación automática o manual de créditos para usuarios registrados y anónimos.
from sqlalchemy.orm import Session
from models.user import User, subscriptionEnum
from models.credit_transaction import CreditTransaction
from datetime import datetime, timedelta
from fastapi import HTTPException, status
from core.logging import configure_logging

logger = configure_logging()

def reset_credits(db: Session, freemium_credits: int = 100, premium_credits: int = 1000, reset_interval: int = 30):
    try:
        users = db.query(User).filter(User.activo == True).all()
        for user in users:
            if not user.renewal or user.renewal < datetime.utcnow() - timedelta(days=reset_interval):
                user.credits = freemium_credits if user.subscription == subscriptionEnum.FREEMIUM else premium_credits
                user.renewal = datetime.utcnow()
                db.add(CreditTransaction(
                    user_id=user.id,
                    user_type='registered',  # Corrección clave
                    amount=user.credits,
                    transaction_type="reset"
                ))
        db.commit()
    except Exception as e:
        logger.error(f"Error al reiniciar créditos: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al reiniciar créditos")

def deduct_credit(db: Session, user_id: int, amount: int = 1):
    try:
        user = db.query(User).filter(User.id == user_id).with_for_update().first()
        if not user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")
        if user.credits < amount:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="No te quedan suficientes créditos")
        user.credits -= amount
        db.add(CreditTransaction(
            user_id=user_id,
            user_type='registered',  # Corrección clave
            amount=-amount,
            transaction_type="usage",
            description="Consulta realizada"  # Opcional, para consistencia con los logs
        ))
        db.commit()
        return user.credits
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al deducir créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al deducir créditos")

# backend/api/v1/coupons.py
from datetime import datetime
import uuid
from fastapi import APIRouter, Body, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from core.logging import configure_logging
from models.coupon_type import CouponType
from models.user import User
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.coupon_service import (create_coupon, create_test_coupon, get_coupon_activity,
                                     get_user_coupons, get_all_coupons,
                                     update_coupon, delete_coupon,
                                     redeem_coupon)
from schemas.coupon import CouponCreate, CouponResponse, CouponTypeCreate, CouponTypeResponse, CouponUpdate
from services.settings_service import get_setting
from typing import List

router = APIRouter(tags=["Coupons"])

logger = configure_logging()

@router.post("/test", response_model=CouponResponse)
async def create_test_coupon_route(
    coupon_type_id: int = Body(..., embed=True),
    db: Session = Depends(get_db),
    current_user: UserContext = Depends(get_user_context)
):
    try:
        # Llamar al servicio para crear el cupón
        new_coupon = create_test_coupon(db, coupon_type_id, int(current_user.user_id))
        db.commit()
        db.refresh(new_coupon)

        # Devolver el cupón creado como respuesta
        return CouponResponse.from_orm(new_coupon)
    except Exception as e:
        logger.error(f"Error al crear cupón de prueba: {e}")
        raise HTTPException(status_code=500, detail="Error al crear cupón de prueba")

@router.get("/activity", response_model=dict)
async def get_coupons_activity(
        page: int = Query(1, ge=1, description="Número de página"),
        limit: int = Query(10,
                           ge=1,
                           le=100,
                           description="Elementos por página"),
        db: Session = Depends(get_db),
        current_user: User = Depends(get_user_context)):
    """
    Obtiene la actividad de cupones con paginación. Solo accesible para administradores.
    """
    if current_user.rol != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=
            "No autorizado. Solo administradores pueden ver la actividad de cupones."
        )
    return get_coupon_activity(db, page, limit)


@router.post("/", response_model=CouponResponse)
def create_coupon_endpoint(coupon_data: CouponCreate,
                           user: UserContext = Depends(get_user_context),
                           db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403,
                            detail="Solo administradores pueden crear cupones")
    return create_coupon(db, coupon_data)


@router.get("/me", response_model=List[CouponResponse])
def get_my_coupons(user: UserContext = Depends(get_user_context),
                   db: Session = Depends(get_db)):
    enable_coupons = get_setting(db, "enable_coupons")
    if enable_coupons != "true":
        raise HTTPException(
            status_code=403,
            detail="La funcionalidad de cupones está deshabilitada")
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None
    return get_user_coupons(db, user_id, session_id)


@router.get("/", response_model=List[CouponResponse])
def get_all_coupons_endpoint(user: UserContext = Depends(get_user_context),
                             db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden ver todos los cupones")
    return get_all_coupons(db)


@router.put("/{coupon_id}", response_model=CouponResponse)
def update_coupon_endpoint(coupon_id: int,
                           coupon_update: CouponUpdate,
                           user: UserContext = Depends(get_user_context),
                           db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden actualizar cupones")
    return update_coupon(db, coupon_id, coupon_update)


@router.delete("/{coupon_id}")
def delete_coupon_endpoint(coupon_id: int,
                           user: UserContext = Depends(get_user_context),
                           db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden eliminar cupones")
    return delete_coupon(db, coupon_id)


@router.post("/redeem/{coupon_id}", response_model=CouponResponse)
def redeem_coupon_endpoint(coupon_id: int,
                           user: UserContext = Depends(get_user_context),
                           db: Session = Depends(get_db)):
    enable_coupons = get_setting(db, "enable_coupons")
    if enable_coupons != "true":
        raise HTTPException(
            status_code=403,
            detail="La funcionalidad de cupones está deshabilitada")
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None
    return redeem_coupon(db, coupon_id, user_id, session_id)


@router.post("/generate-demo-coupon", response_model=CouponResponse)
def generate_demo_coupon(credits: int,
                         db: Session = Depends(get_db),
                         current_user: UserContext = Depends(get_user_context)):

    # Determinar user_id y session_id según el tipo de usuario
    user_id = current_user.user_id if current_user.user_type == "registered" else None
    session_id = current_user.session_id if current_user.user_type == "anonymous" else None

    coupon_data = CouponCreate(
        name="Demo Coupon",
        description="Cupón de demostración",
        credits=credits,
        active=True,
        unique_identifier=str(uuid.uuid4()),
        session_id=session_id,
        user_id=user_id,
        expires_at=None,
        issued_at=datetime.utcnow(),
        redeemed_at=None,
        status="active",
        coupon_type_id=1,  # Asignar un tipo de cupón por defecto
    )

    coupon = create_coupon(db, coupon_data, user_id=user_id, session_id=session_id)
    return coupon


@router.post("/types", response_model=CouponTypeResponse)
def create_coupon_type(coupon_type_data: CouponTypeCreate,
                       user: UserContext = Depends(get_user_context),
                       db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden crear tipos de cupones")
    coupon_type = CouponType(**coupon_type_data.dict())
    db.add(coupon_type)
    db.commit()
    db.refresh(coupon_type)
    return coupon_type


@router.get("/types", response_model=List[CouponTypeResponse])
def get_coupon_types(user: UserContext = Depends(get_user_context),
                     db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(
            status_code=403,
            detail="Solo administradores pueden ver tipos de cupones")
    return db.query(CouponType).all()


# backend/models/coupon.py
from sqlalchemy import Column, Integer, String, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from models.guests import GuestsSession
from models.user import User
from core.database import Base
from datetime import datetime

class Coupon(Base):
    __tablename__ = "coupons"

    id = Column(Integer, primary_key=True, index=True)
    coupon_type_id = Column(Integer, ForeignKey("coupon_types.id"), nullable=False)
    name = Column(String(100), nullable=False)
    description = Column(String(255), nullable=True)
    unique_identifier = Column(String(50), unique=True, nullable=False)
    issued_at = Column(DateTime, default=datetime.utcnow)
    expires_at = Column(DateTime, nullable=True)
    redeemed_at = Column(DateTime, nullable=True)
    active = Column(Boolean, default=True)
    status = Column(String(20), default="active")  # "active", "redeemed", "expired", "disabled"
    credits = Column(Integer, nullable=False)

    # Relaciones con usuario registrado o sesión anónima
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String, ForeignKey("sesiones_anonimas.id"), nullable=True)

    # Quién canjeó el cupón
    redeemed_by_user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    redeemed_by_session_id = Column(String, ForeignKey("sesiones_anonimas.id"), nullable=True)

    # Relaciones ORM
    user = relationship("User", foreign_keys=[user_id], back_populates="coupons")
    session = relationship("GuestsSession", foreign_keys=[session_id], back_populates="coupons")
    redeemed_by_user = relationship("User", foreign_keys=[redeemed_by_user_id])
    redeemed_by_session = relationship("GuestsSession", foreign_keys=[redeemed_by_session_id])



# backend/models/coupon_type.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from core.database import Base
from datetime import datetime

class CouponType(Base):
    __tablename__ = "coupon_types"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ejemplo: "Bienvenida", "Demostración"
    
    description = Column(String(255), nullable=True)
    credits = Column(Integer, nullable=False)
    active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

# backend/schemas/coupon.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional
from uuid import UUID

class CouponBase(BaseModel):
    name: str
    description: Optional[str] = None
    unique_identifier: str
    expires_at: Optional[datetime] = None
    credits: int
    active: bool = True

class CouponCreate(CouponBase):
    pass
    coupon_type_id: int
    session_id: Optional[str] = None
    user_id: Optional[str] = None
    issued_at: Optional[datetime] = None
    redeemed_at: Optional[datetime] = None
    status: Optional[str] = None

class CouponUpdate(BaseModel):
    name: Optional[str] = None
    description: Optional[str] = None
    expires_at: Optional[datetime] = None
    credits: Optional[int] = None
    active: Optional[bool] = None
    status: Optional[str] = None

class CouponResponse(CouponBase):
    id: int
    issued_at: datetime
    redeemed_at: Optional[datetime] = None
    status: str
    user_id: Optional[int] = None
    session_id: Optional[str] = None
    redeemed_by_user_id: Optional[int] = None
    redeemed_by_session_id: Optional[str] = None

    class Config:
        from_attributes = True  # Reemplaza orm_mode=True, siguiendo la versión moderna de Pydantic

class CouponTypeBase(BaseModel):
    name: str
    description: Optional[str] = None
    credits: int
    active: bool = True

class CouponTypeCreate(CouponTypeBase):
    pass

class CouponTypeResponse(CouponTypeBase):
    id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# backend/services/coupon_service.py
from typing import Optional
from sqlalchemy import desc
from sqlalchemy.orm import Session
from models.coupon import Coupon
from models.user import User
from models.guests import GuestsSession
from schemas.coupon import CouponCreate, CouponResponse, CouponUpdate
from core.logging import configure_logging
from fastapi import HTTPException
import uuid
from datetime import datetime, timedelta

logger = configure_logging()

def create_test_coupon(db: Session, coupon_type_id: int, admin_user_id: int):
    unique_id = str(uuid.uuid4())
    expires_at = datetime.utcnow() + timedelta(hours=24)  # Expira en 24 horas
    new_coupon = Coupon(
        coupon_type_id=coupon_type_id,
        name="Test Coupon",  # Valor predeterminado para el campo name
        unique_identifier=unique_id,
        status="active",
        credits=1,
        issued_at=datetime.utcnow(),
        expires_at=expires_at,
        active=True,
        user_id=admin_user_id  # Asignamos el cupón al admin
    )
    db.add(new_coupon)
    db.commit()
    db.refresh(new_coupon)
    return new_coupon

def get_coupon_activity(db: Session, page: int = 1, limit: int = 10) -> dict:
    """
    Obtiene la actividad de cupones con paginación.
    """
    offset = (page - 1) * limit
    total_items = db.query(Coupon).count()
    total_pages = (total_items + limit - 1) // limit

    coupons = (
        db.query(Coupon)
        .order_by(desc(Coupon.issued_at))
        .offset(offset)
        .limit(limit)
        .all()
    )

    # Serialización manual para coincidir con el frontend
    coupons_data = [
        {
            "id": coupon.id,
            "coupon_type": coupon.coupon_type_id,
            "unique_identifier": coupon.unique_identifier,
            "user_id": coupon.user_id,
            "session_id": coupon.session_id,
            "status": coupon.status,
            "issued_at": coupon.issued_at.isoformat(),
            "redeemed_at": coupon.redeemed_at.isoformat() if coupon.redeemed_at else None,
        }
        for coupon in coupons
    ]

    return {
        "data": coupons_data,
        "total_items": total_items,
        "total_pages": total_pages,
        "current_page": page,
    }

def create_coupon(db: Session, coupon_data: CouponCreate, user_id: Optional[int] = None, session_id: Optional[str] = None) -> Coupon:
    unique_identifier = str(uuid.uuid4())
    while db.query(Coupon).filter(Coupon.unique_identifier == unique_identifier).first():
        unique_identifier = str(uuid.uuid4())

    coupon = Coupon(
        coupon_type_id=coupon_data.coupon_type_id,
        name=coupon_data.name,
        credits=coupon_data.credits,
        description=coupon_data.description,
        unique_identifier=unique_identifier,
        expires_at=coupon_data.expires_at,
        active=coupon_data.active,
        user_id=user_id,
        session_id=session_id
    )
    db.add(coupon)
    db.commit()
    db.refresh(coupon)
    logger.info(f"Cupón creado: {coupon.unique_identifier}")
    return coupon

def get_coupon_by_id(db: Session, coupon_id: int) -> Coupon:
    coupon = db.query(Coupon).filter(Coupon.id == coupon_id).first()
    if not coupon:
        raise HTTPException(status_code=404, detail="Cupón no encontrado")
    return coupon

def get_user_coupons(db: Session, user_id: Optional[int], session_id: Optional[str]) -> list[Coupon]:
    query = db.query(Coupon)
    if user_id:
        query = query.filter(Coupon.user_id == user_id)
    elif session_id:
        query = query.filter(Coupon.session_id == session_id)
    return query.all()

def get_all_coupons(db: Session) -> list[Coupon]:
    return db.query(Coupon).all()

def update_coupon(db: Session, coupon_id: int, coupon_update: CouponUpdate) -> Coupon:
    coupon = get_coupon_by_id(db, coupon_id)
    for key, value in coupon_update.dict(exclude_unset=True).items():
        setattr(coupon, key, value)
    db.commit()
    db.refresh(coupon)
    logger.info(f"Cupón actualizado: {coupon.unique_identifier}")
    return coupon

def delete_coupon(db: Session, coupon_id: int):
    coupon = get_coupon_by_id(db, coupon_id)
    db.delete(coupon)
    db.commit()
    logger.info(f"Cupón eliminado: {coupon.unique_identifier}")
    return {"message": "Cupón eliminado"}

def redeem_coupon(db: Session, coupon_id: int, user_id: Optional[int], session_id: Optional[str]) -> Coupon:
    coupon = get_coupon_by_id(db, coupon_id)
    
    if coupon.status != "active":
        raise HTTPException(status_code=400, detail="Cupón no está activo")
    if coupon.expires_at and coupon.expires_at < datetime.utcnow():
        coupon.status = "expired"
        db.commit()
        raise HTTPException(status_code=400, detail="Cupón expirado")
    if (coupon.user_id and coupon.user_id != user_id) or (coupon.session_id and coupon.session_id != session_id):
        raise HTTPException(status_code=403, detail="Cupón no pertenece a este usuario/sesión")

    coupon.redeemed_at = datetime.utcnow()
    coupon.status = "redeemed"
    
    if user_id:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        user.credits += coupon.credits
        coupon.redeemed_by_user_id = user_id
    elif session_id:
        session = db.query(GuestsSession).filter(GuestsSession.id == session_id).first()
        if not session:
            raise HTTPException(status_code=404, detail="Sesión no encontrada")
        session.credits += coupon.credits
        coupon.redeemed_by_session_id = session_id

    db.commit()
    db.refresh(coupon)
    logger.info(f"Cupón canjeado: {coupon.unique_identifier} por {user_id or session_id}")
    return coupon