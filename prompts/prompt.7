
Si por favor, continuar con la parte 2 y siguientes hasta completar todo lo solicitado.

Primero he encontrado un bug en la implantación de la parte 1.3

2025-04-10 21:17:20,285 - NeptunO - CRITICAL - Error inesperado en get_user_context desde IP 127.0.0.1: 1 validation error for CouponCreate
coupon_type_id
  Field required [type=missing, input_value={'name': 'Bienvenida', 'd...er': 'WELCOME-1a4e9f40'}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.10/v/missing
2025-04-10 21:17:20,287 - NeptunO - ERROR - HTTP Error 500 en GET http://127.0.0.1:8000/info: Error al procesar la autenticación
INFO:     127.0.0.1:53592 - "GET /info HTTP/1.1" 500 Internal Server Error
2025-04-10 21:17:20,359 - NeptunO - INFO - Procesando solicitud: token=False, session_id=None, ip=127.0.0.1
2025-04-10 21:17:20,359 - NeptunO - INFO - No hay session_id en header, creando nueva sesión anónima
2025-04-10 21:17:20,451 - NeptunO - CRITICAL - Error inesperado en get_user_context desde IP 127.0.0.1: 1 validation error for CouponCreate
coupon_type_id
  Field required [type=missing, input_value={'name': 'Bienvenida', 'd...er': 'WELCOME-b91bb90c'}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.10/v/missing
2025-04-10 21:17:20,452 - NeptunO - ERROR - HTTP Error 500 en GET http://127.0.0.1:8000/v1/gamification/me: Error al procesar la autenticación
INFO:     127.0.0.1:53592 - "GET /v1/gamification/me HTTP/1.1" 500 Internal Server Error

aqui algunos fragmentos de codigo


# backend/dependencies/auth.py


            # Crear cupón de bienvenida

            coupon_data = CouponCreate(
                name="Bienvenida",
                description="Cupón de bienvenida para usuarios anónimos",
                credits=5,
                active=True,
                unique_identifier=f"WELCOME-{session_id[:8]}"
            )
            create_coupon(db, coupon_data, session_id=session_id)
            logger.info(f"Cupón de bienvenida creado para sesión {session_id}")


el resto de archivos que puedas necesitar estan en el prompt

Otro bug en la implantación de la parte 1 es este de la pagina de ejemplos cuando genero un cupon de ejemplo 

INFO:     127.0.0.1:48092 - "OPTIONS /v1/coupons/generate-demo-coupon HTTP/1.1" 200 OK
2025-04-10 21:19:52,137 - NeptunO - CRITICAL - Error inesperado en POST http://127.0.0.1:8000/v1/coupons/generate-demo-coupon: 1 validation error for CouponCreate
coupon_type_id
  Field required [type=missing, input_value={'name': 'Demo Coupon', '...4eb9-b4b4-46e4ba474e0e'}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.10/v/missing
INFO:     127.0.0.1:48096 - "POST /v1/coupons/generate-demo-coupon HTTP/1.1" 500 Internal Server Error
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/protocols/http/h11_impl.py", line 403, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/uvicorn/middleware/proxy_headers.py", line 60, in __call__
    return await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 187, in __call__
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 93, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/cors.py", line 144, in simple_response
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/middleware/exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/routing.py", line 73, in app
    response = await f(request)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 301, in app
    raw_response = await run_endpoint_function(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/fastapi/routing.py", line 214, in run_endpoint_function
    return await run_in_threadpool(dependant.call, **values)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/starlette/concurrency.py", line 37, in run_in_threadpool
    return await anyio.to_thread.run_sync(func)
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/to_thread.py", line 56, in run_sync
    return await get_async_backend().run_sync_in_worker_thread(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 2470, in run_sync_in_worker_thread
    return await future
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/anyio/_backends/_asyncio.py", line 967, in run
    result = context.run(func, *args)
  File "/home/vinxenxo/neptuno/neptuno/backend/api/v1/coupons.py", line 123, in generate_demo_coupon
    coupon_data = CouponCreate(
  File "/home/vinxenxo/neptuno/neptuno/backend/.venv/lib/python3.10/site-packages/pydantic/main.py", line 214, in __init__
    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)
pydantic_core._pydantic_core.ValidationError: 1 validation error for CouponCreate
coupon_type_id
  Field required [type=missing, input_value={'name': 'Demo Coupon', '...4eb9-b4b4-46e4ba474e0e'}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.10/v/missing



utiliza los archivos que hay en el prompt y en nuestra conversación para solucionarlo.

Parte 2: He visto algunos fallos en el dashboard de admin que debemos corregir vamos a ello.

El codigo fuente del dashboard es el que te he pasado arriba te lo vuelvo a pasar:

// src/app/admin/dashboard/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { AnimatePresence, motion } from "framer-motion";
import {
  Tabs,
  Tab,
  Card,
  CardContent,
  TextField,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Typography,
  IconButton,
  Snackbar,
  Alert,
  Avatar,
  Chip,
  Divider,
  List,
  ListItem,
  ListItemText,
  Badge as MuiBadge,
  Paper,
  useTheme,
  styled,
  Box,
  Switch,
  FormControlLabel,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Dialog,
  DialogTitle,
  DialogContent,
} from "@mui/material";
import Grid from "@mui/material/Grid";
import {
  AddCircle,
  Delete,
  ExpandMore,
  Settings,
  Public,
  Link,
  Webhook,
  CheckCircle,
  Cancel,
  Security,
  PersonAdd,
  LockPerson,
  PeopleOutline,
  AttachMoney,
  Edit,
  EmojiEvents,
  MonetizationOn,
  LocalActivity
} from "@mui/icons-material";
import { SiteSetting, Integration, EventType, Badge, PaymentProvider, Coupon } from "@/lib/types";

const AdminGradientCard = styled(Card)(({ theme }) => ({
  background: `linear-gradient(135deg, ${theme.palette.primary.dark} 0%, ${theme.palette.secondary.dark} 100%)`,
  color: theme.palette.primary.contrastText,
  borderRadius: '16px',
  boxShadow: theme.shadows[10],
  transition: 'transform 0.3s ease',
  '&:hover': {
    transform: 'translateY(-5px)'
  }
}));

const ConfigGlassCard = styled(Card)(({ theme }) => ({
  background: 'rgba(255, 255, 255, 0.1)',
  backdropFilter: 'blur(10px)',
  border: '1px solid rgba(255, 255, 255, 0.2)',
  borderRadius: '16px',
  boxShadow: theme.shadows[5]
}));

const FeatureCard = styled(Card)(({ theme }) => ({
  borderRadius: '16px',
  boxShadow: theme.shadows[4],
  transition: 'all 0.3s ease',
  '&:hover': {
    transform: 'translateY(-5px)',
    boxShadow: theme.shadows[8]
  }
}));

export default function ConfigurePage() {
  const { user } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [activeTab, setActiveTab] = useState(0);
  const [settingsByTag, setSettingsByTag] = useState<Record<string, SiteSetting[]>>({});
  const [origins, setOrigins] = useState<string[]>([]);
  const [integrations, setIntegrations] = useState<Integration[]>([]);
  const [newOrigin, setNewOrigin] = useState("");
  const [newIntegration, setNewIntegration] = useState({ name: "", webhook_url: "", event_type: "" });
  const [features, setFeatures] = useState({
    enable_registration: true,
    enable_social_login: true,
    disable_anonymous_users: false,
    disable_credits: false,
    enable_payment_methods: true,
    enable_points: true,
    enable_badges: true,
    enable_coupons: true,
  });

  const [eventTypes, setEventTypes] = useState<EventType[]>([]);
  const [badges, setBadges] = useState<Badge[]>([]);
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>([]);
  const [editEventType, setEditEventType] = useState<EventType | null>(null);
  const [editBadge, setEditBadge] = useState<Badge | null>(null);
  const [editPaymentProvider, setEditPaymentProvider] = useState<PaymentProvider | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [expandedSettings, setExpandedSettings] = useState<Record<string, boolean>>({});
  const [allSettingsExpanded, setAllSettingsExpanded] = useState(false);
  const [coupons, setCoupons] = useState<Coupon[]>([]);
  const [editCoupon, setEditCoupon] = useState<Coupon | null>(null);

  useEffect(() => {
    if (!user || user.rol !== "admin") {
      router.push("/");
      return;
    }

    const fetchData = async () => {
      try {
        const settingsRes = await fetchAPI<SiteSetting[]>("/v1/settings/admin/config");
        const grouped = settingsRes.data?.reduce((acc, setting) => {
          const tag = setting.tag || "General";
          if (!acc[tag]) acc[tag] = [];
          acc[tag].push(setting);
          return acc;
        }, {} as Record<string, SiteSetting[]>);
        setSettingsByTag(grouped || {});

        // Initialize expanded state for settings
        if (grouped) {
          const initialExpandedState = Object.keys(grouped).reduce((acc, tag) => {
            acc[tag] = false;
            return acc;
          }, {} as Record<string, boolean>);
          setExpandedSettings(initialExpandedState);
        }

        const originsRes = await fetchAPI<string[]>("/v1/settings/allowed_origins");
        setOrigins(originsRes.data || []);

        const integrationsRes = await fetchAPI<Integration[]>("/v1/integrations/");
        setIntegrations(integrationsRes.data || []);

        const eventTypesRes = await fetchAPI<EventType[]>("/v1/gamification/event-types");
        setEventTypes(eventTypesRes.data || []);

        const badgesRes = await fetchAPI<Badge[]>("/v1/gamification/badges");
        setBadges(badgesRes.data || []);

        const paymentProvidersRes = await fetchAPI<PaymentProvider[]>("/v1/payment-providers");
        setPaymentProviders(paymentProvidersRes.data || []);

        const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/");
        setCoupons(couponsRes.data || []);

        const featuresRes = await Promise.all([
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_social_login"),
          fetchAPI("/v1/settings/disable_anonymous_users"),
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_payment_methods"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_badges"),
          fetchAPI("/v1/settings/enable_coupons"),
        ]);
        setFeatures({
          enable_registration: featuresRes[0].data === "true",
          enable_social_login: featuresRes[1].data === "true",
          disable_anonymous_users: featuresRes[2].data === "true",
          disable_credits: featuresRes[3].data === "true",
          enable_payment_methods: featuresRes[4].data === "true",
          enable_points: featuresRes[5].data === "true",
          enable_badges: featuresRes[6].data === "true",
          enable_coupons: featuresRes[7].data === "true",
        });
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [user, router]);

  const groupedBadges = badges.reduce((acc, badge) => {
    const key = badge.event_type_id;
    if (!acc[key]) acc[key] = [];
    acc[key].push(badge);
    return acc;
  }, {} as Record<number, Badge[]>);

  const toggleAllSettings = () => {
    const newState = !allSettingsExpanded;
    setAllSettingsExpanded(newState);
    const updatedExpandedSettings = Object.keys(expandedSettings).reduce((acc, tag) => {
      acc[tag] = newState;
      return acc;
    }, {} as Record<string, boolean>);
    setExpandedSettings(updatedExpandedSettings);
  };

  const handleSaveSetting = async (key: string, newValue: string) => {
    try {
      await fetchAPI("/v1/settings/admin/config", { method: "POST", data: { key, value: newValue } });
      setSettingsByTag((prev) => {
        const updated = { ...prev };
        for (const tag in updated) {
          updated[tag] = updated[tag].map((s) => (s.key === key ? { ...s, value: newValue } : s));
        }
        return updated;
      });
      setSuccess("Configuración actualizada");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al guardar configuración");
    }
  };

  const handleAddOrigin = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await fetchAPI("/v1/settings/allowed-origins", { method: "POST", data: { origin: newOrigin } });
      setOrigins([...origins, newOrigin]);
      setNewOrigin("");
      setSuccess("Origen añadido con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir origen");
    }
  };

  const handleAddIntegration = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Integration>("/v1/integrations/", {
        method: "POST",
        data: { name: newIntegration.name, webhook_url: newIntegration.webhook_url, event_type: newIntegration.event_type },
      });
      setIntegrations([...integrations, data!]);
      setNewIntegration({ name: "", webhook_url: "", event_type: "" });
      setSuccess("Integración creada con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear integración");
    }
  };

  const handleToggleFeature = async (feature: string, enabled: boolean) => {
    try {
      await fetchAPI("/v1/settings/admin/config", { method: "POST", data: { key: feature, value: enabled.toString() } });
      setFeatures((prev) => ({ ...prev, [feature]: enabled }));
      setSuccess(`Funcionalidad ${enabled ? "activada" : "desactivada"} con éxito`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar funcionalidad");
    }
  };

  const handleCreateEventType = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<EventType>("/v1/gamification/event-types", { method: "POST", data: editEventType });
      setEventTypes([...eventTypes, data!]);
      setEditEventType(null);
      setSuccess("Tipo de evento creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear tipo de evento");
    }
  };

  const handleUpdateEventType = async (e: React.FormEvent) => {
    if (!editEventType?.id) return;
    try {
      const { data } = await fetchAPI<EventType>(`/v1/gamification/event-types/${editEventType.id}`, { method: "PUT", data: editEventType });
      setEventTypes(eventTypes.map((et) => (et.id === data!.id ? data! : et)));
      setEditEventType(null);
      setSuccess("Tipo de evento actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar tipo de evento");
    }
  };

  const handleDeleteEventType = async (id: number) => {
    try {
      await fetchAPI(`/v1/gamification/event-types/${id}`, { method: "DELETE" });
      setEventTypes(eventTypes.filter((et) => et.id !== id));
      setSuccess("Tipo de evento eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar tipo de evento");
    }
  };

  const handleCreateBadge = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Badge>("/v1/gamification/badges", { method: "POST", data: editBadge });
      setBadges([...badges, data!]);
      setEditBadge(null);
      setSuccess("Badge creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear badge");
    }
  };

  const handleUpdateBadge = async (e: React.FormEvent) => {
    if (!editBadge?.id) return;
    try {
      const { data } = await fetchAPI<Badge>(`/v1/gamification/badges/${editBadge.id}`, { method: "PUT", data: editBadge });
      setBadges(badges.map((b) => (b.id === data!.id ? data! : b)));
      setEditBadge(null);
      setSuccess("Badge actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar badge");
    }
  };

  const handleDeleteBadge = async (id: number) => {
    try {
      await fetchAPI(`/v1/gamification/badges/${id}`, { method: "DELETE" });
      setBadges(badges.filter((b) => b.id !== id));
      setSuccess("Badge eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar badge");
    }
  };

  const handleTogglePaymentProvider = async (id: number, active: boolean) => {
    try {
      const { data } = await fetchAPI<PaymentProvider>(`/v1/payment-providers/${id}`, {
        method: "PUT",
        data: { active },
      });
      setPaymentProviders(paymentProviders.map((p) => (p.id === id ? data! : p)));
      setSuccess(`Proveedor ${active ? "activado" : "desactivado"}`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar proveedor");
    }
  };

  const handleCreatePaymentProvider = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentProvider>("/v1/payment-providers", { method: "POST", data: editPaymentProvider });
      setPaymentProviders([...paymentProviders, data!]);
      setEditPaymentProvider(null);
      setSuccess("Proveedor creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear proveedor");
    }
  };

  const handleUpdatePaymentProvider = async (e: React.FormEvent) => {
    if (!editPaymentProvider?.id) return;
    try {
      const { data } = await fetchAPI<PaymentProvider>(`/v1/payment-providers/${editPaymentProvider.id}`, {
        method: "PUT",
        data: editPaymentProvider,
      });
      setPaymentProviders(paymentProviders.map((p) => (p.id === data!.id ? data! : p)));
      setEditPaymentProvider(null);
      setSuccess("Proveedor actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar proveedor");
    }
  };

  const handleDeletePaymentProvider = async (id: number) => {
    try {
      await fetchAPI(`/v1/payment-providers/${id}`, { method: "DELETE" });
      setPaymentProviders(paymentProviders.filter((p) => p.id !== id));
      setSuccess("Proveedor eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar proveedor");
    }
  };

  // Funciones para manejar cupones
  const handleSubmitCoupon = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editCoupon) return;
    try {
      if (editCoupon.id) {
        const { data } = await fetchAPI<Coupon>(`/v1/coupons/${editCoupon.id}`, {
          method: "PUT",
          data: {
            name: editCoupon.name,
            description: editCoupon.description,
            credits: editCoupon.credits,
            active: editCoupon.active,
          },
        });
        setCoupons(coupons.map((c) => (c.id === data!.id ? data! : c)));
      } else {
        const { data } = await fetchAPI<Coupon>("/v1/coupons/", {
          method: "POST",
          data: {
            name: editCoupon.name,
            description: editCoupon.description,
            credits: editCoupon.credits,
            active: editCoupon.active,
            unique_identifier: `CUPON-${Date.now()}`,
          },
        });
        setCoupons([...coupons, data!]);
      }
      setEditCoupon(null);
      setSuccess("Cupón guardado con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al guardar cupón");
    }
  };

  const handleDeleteCoupon = async (id: number) => {
    try {
      await fetchAPI(`/v1/coupons/${id}`, { method: "DELETE" });
      setCoupons(coupons.filter((c) => c.id !== id));
      setSuccess("Cupón eliminado con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar cupón");
    }
  };

  if (loading) return (
    <Box sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h6" color="textSecondary">Cargando panel de administración...</Typography>
      </motion.div>
    </Box>
  );


  return (
    <Box sx={{
      p: { xs: 2, md: 4 },
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <Box sx={{ maxWidth: '1400px', mx: 'auto' }}>
        {/* Header Section */}
        <Box sx={{
          display: 'flex',
          flexDirection: { xs: 'column', md: 'row' },
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 4,
          gap: 2
        }}>
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                display: 'inline-block'
              }}
            >
              Panel de Administración
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Gestiona la configuración del sistema
            </Typography>
          </motion.div>

          <MuiBadge
            overlap="circular"
            badgeContent={
              <Chip
                label="Admin"
                size="small"
                color="primary"
                sx={{
                  position: 'absolute',
                  top: -10,
                  right: -10,
                  fontWeight: 'bold'
                }}
              />
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.error.main,
                fontSize: '2rem',
                boxShadow: theme.shadows[6]
              }}
            >
              {user?.username?.charAt(0).toUpperCase()}
            </Avatar>
          </MuiBadge>
        </Box>

        {/* Stats Cards */}
        <Box sx={{ display: 'flex', gap: 3, mb: 4, flexWrap: 'wrap' }}>
          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Configuraciones
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {Object.values(settingsByTag).flat().length}
                  </Typography>
                </Box>
                <Settings sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Orígenes Permitidos
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {origins.length}
                  </Typography>
                </Box>
                <Public sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Integraciones
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {integrations.length}
                  </Typography>
                </Box>
                <Webhook sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Gamificación
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {eventTypes.length}
                  </Typography>
                </Box>
                <EmojiEvents sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Pagos
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {paymentProviders.length}
                  </Typography>
                </Box>
                <MonetizationOn sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>
        </Box>

        {/* Tabs Navigation */}
        <Paper sx={{ mb: 3, borderRadius: '12px', overflow: 'hidden' }}>
          <Tabs
            value={activeTab}
            onChange={(_, newValue) => setActiveTab(newValue)}
            variant="scrollable"
            scrollButtons="auto"
            indicatorColor="primary"
            textColor="primary"
          >
            <Tab label="Funcionalidades" icon={<LockPerson />} iconPosition="start" />
            <Tab label="Orígenes" icon={<Security />} iconPosition="start" />
            <Tab label="Integraciones" icon={<Link />} iconPosition="start" />
            <Tab label="Gamificación" icon={<EmojiEvents />} iconPosition="start" />
            <Tab label="Cupones" icon={<LocalActivity />} iconPosition="start" />
            <Tab label="Pagos" icon={<MonetizationOn />} iconPosition="start" />
            <Tab label="Configuraciones" icon={<Settings />} iconPosition="start" />
          </Tabs>
        </Paper>

        {/* Tab Content */}
        <motion.div
          key={activeTab}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* Funcionalidades Tab */}
          {activeTab === 0 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <LockPerson sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Control de Funcionalidades del Sistema
                  </Typography>

                  <Grid container spacing={3}>
                    {/* Tarjeta para Registro */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_registration ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PersonAdd sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_registration ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Registro de Usuarios</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Controla si los nuevos usuarios pueden registrarse
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_registration ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_registration ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_registration}
                              onChange={(e) => handleToggleFeature('enable_registration', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_registration')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Login Social */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_social_login ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PeopleOutline sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_social_login ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Login Social</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Permite inicio de sesión con redes sociales
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_social_login ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_social_login ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_social_login}
                              onChange={(e) => handleToggleFeature('enable_social_login', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_social_login')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Usuarios Anónimos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.disable_anonymous_users ? theme.palette.error.main : theme.palette.success.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <Security sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.disable_anonymous_users ? theme.palette.error.main : theme.palette.success.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Usuarios Anónimos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Controla el acceso de usuarios no registrados
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.disable_anonymous_users ? "Bloqueados" : "Permitidos"}
                                size="small"
                                color={features.disable_anonymous_users ? "error" : "success"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.disable_anonymous_users}
                              onChange={(e) => handleToggleFeature('disable_anonymous_users', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('disable_anonymous_users')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Sistema de Créditos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.disable_credits ? theme.palette.error.main : theme.palette.success.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <AttachMoney sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.disable_credits ? theme.palette.error.main : theme.palette.success.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Créditos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita/deshabilita el uso de créditos
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.disable_credits ? "Desactivado" : "Activado"}
                                size="small"
                                color={features.disable_credits ? "error" : "success"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={!features.disable_credits}
                              onChange={(e) => handleToggleFeature('disable_credits', !e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('disable_credits')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Métodos de Pago */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_payment_methods ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <MonetizationOn sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_payment_methods ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Métodos de Pago</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita diferentes opciones de pago
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_payment_methods ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_payment_methods ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_payment_methods}
                              onChange={(e) => handleToggleFeature('enable_payment_methods', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_payment_methods')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Sistema de Puntos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_points ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_points ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Puntos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Activa puntos por actividades
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_points ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_points ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_points}
                              onChange={(e) => handleToggleFeature('enable_points', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_points')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Insignias */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_badges ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_badges ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Insignias</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Permite la obtención de insignias
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_badges ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_badges ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_badges}
                              onChange={(e) => handleToggleFeature('enable_badges', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_badges')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Cupones */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_coupons ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_coupons ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Cupones</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita el sistema de cupones
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_coupons ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_coupons ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_coupons}
                              onChange={(e) => handleToggleFeature('enable_coupons', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_coupons')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                  </Grid>
                </CardContent>
              </ConfigGlassCard>
            </Box>
          )}

          {/* Orígenes Permitidos Tab */}
          {activeTab === 1 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Box component="form" onSubmit={handleAddOrigin} sx={{ display: 'flex', gap: 2 }}>
                    <TextField
                      label="Nuevo Origen Permitido"
                      value={newOrigin}
                      onChange={(e) => setNewOrigin(e.target.value)}
                      fullWidth
                      variant="outlined"
                      size="small"
                      placeholder="https://example.com"
                      InputProps={{ startAdornment: <Public color="action" sx={{ mr: 1 }} /> }}
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      startIcon={<AddCircle />}
                      sx={{ minWidth: '120px' }}
                    >
                      Añadir
                    </Button>
                  </Box>
                </CardContent>
              </ConfigGlassCard>

              {origins.length > 0 ? (
                <Grid container spacing={2}>
                  {origins.map((origin, index) => (
                    <Grid item xs={12} sm={6} md={4} key={index}>
                      <ConfigGlassCard>
                        <CardContent sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <Public color="primary" />
                            <Typography noWrap sx={{ maxWidth: '200px' }}>{origin}</Typography>
                          </Box>
                          <IconButton color="error"><Delete /></IconButton>
                        </CardContent>
                      </ConfigGlassCard>
                    </Grid>
                  ))}
                </Grid>
              ) : (
                <ConfigGlassCard>
                  <CardContent sx={{ textAlign: 'center', py: 4 }}>
                    <Public sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
                    <Typography variant="h6" color="textSecondary">
                      No hay orígenes permitidos
                    </Typography>
                  </CardContent>
                </ConfigGlassCard>
              )}
            </Box>
          )}

          {/* Integraciones Tab */}
          {activeTab === 2 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Box component="form" onSubmit={handleAddIntegration} sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    <TextField
                      label="Nombre de la Integración"
                      value={newIntegration.name}
                      onChange={(e) => setNewIntegration({ ...newIntegration, name: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                      InputProps={{ startAdornment: <Link color="action" sx={{ mr: 1 }} /> }}
                    />
                    <TextField
                      label="Webhook URL"
                      value={newIntegration.webhook_url}
                      onChange={(e) => setNewIntegration({ ...newIntegration, webhook_url: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                      InputProps={{ startAdornment: <Webhook color="action" sx={{ mr: 1 }} /> }}
                    />
                    <TextField
                      label="Tipo de Evento"
                      value={newIntegration.event_type}
                      onChange={(e) => setNewIntegration({ ...newIntegration, event_type: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                      InputProps={{ startAdornment: <Settings color="action" sx={{ mr: 1 }} /> }}
                    />
                    <Button type="submit" variant="contained" color="primary" startIcon={<AddCircle />} sx={{ mt: 1 }}>
                      Crear Integración
                    </Button>
                  </Box>
                </CardContent>
              </ConfigGlassCard>

              {integrations.length > 0 ? (
                <Grid container spacing={2}>
                  {integrations.map((integration) => (
                    <Grid item xs={12} md={6} key={integration.id}>
                      <ConfigGlassCard>
                        <CardContent>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                            <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Webhook color="primary" />
                              {integration.name}
                            </Typography>
                            <Chip
                              label={integration.active ? "Activo" : "Inactivo"}
                              color={integration.active ? "success" : "error"}
                              size="small"
                              icon={integration.active ? <CheckCircle /> : <Cancel />}
                            />
                          </Box>
                          <Typography variant="body2" color="textSecondary" sx={{ mb: 1 }}>
                            <strong>Webhook:</strong> {integration.webhook_url}
                          </Typography>
                          <Typography variant="body2" color="textSecondary">
                            <strong>Evento:</strong> {integration.event_type}
                          </Typography>
                        </CardContent>
                      </ConfigGlassCard>
                    </Grid>
                  ))}
                </Grid>
              ) : (
                <ConfigGlassCard>
                  <CardContent sx={{ textAlign: 'center', py: 4 }}>
                    <Webhook sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
                    <Typography variant="h6" color="textSecondary">
                      No hay integraciones configuradas
                    </Typography>
                  </CardContent>
                </ConfigGlassCard>
              )}
            </Box>
          )}

          {/* Gamificación Tab */}
          {activeTab === 3 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <EmojiEvents sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Gamificación
                  </Typography>

                  {/* Event Types Section */}
                  <ConfigGlassCard sx={{ mb: 4, p: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6">Tipos de Evento</Typography>
                      <Button
                        variant="contained"
                        startIcon={<AddCircle />}
                        onClick={() => setEditEventType({ id: 0, name: '', description: '', points_per_event: 0 })}
                      >
                        Nuevo Tipo
                      </Button>
                    </Box>

                    <Table>
                      <TableHead>
                        <TableRow>
                          <TableCell>Nombre</TableCell>
                          <TableCell>Descripción</TableCell>
                          <TableCell>Puntos</TableCell>
                          <TableCell>Acciones</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {eventTypes.map((et) => (
                          <TableRow key={et.id}>
                            <TableCell>{et.name}</TableCell>
                            <TableCell>{et.description}</TableCell>
                            <TableCell>{et.points_per_event}</TableCell>
                            <TableCell>
                              <IconButton onClick={() => setEditEventType(et)} color="primary">
                                <Edit />
                              </IconButton>
                              <IconButton onClick={() => handleDeleteEventType(et.id)} color="error">
                                <Delete />
                              </IconButton>
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </ConfigGlassCard>

                  {/* Badges Section */}
                  <ConfigGlassCard sx={{ p: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6">Insignias</Typography>
                      <Button
                        variant="contained"
                        startIcon={<AddCircle />}
                        onClick={() => setEditBadge({
                          id: 0,
                          name: '',
                          description: '',
                          event_type_id: eventTypes[0]?.id || 0,
                          required_points: 0,
                          user_type: 'both'
                        })}
                        disabled={eventTypes.length === 0}
                      >
                        Nueva Insignia
                      </Button>
                    </Box>

                    {eventTypes.map((eventType) => (
                      <Accordion key={eventType.id} sx={{ background: 'transparent', boxShadow: 'none' }}>
                        <AccordionSummary expandIcon={<ExpandMore />}>
                          <Typography>{eventType.name} (ID: {eventType.id})</Typography>
                        </AccordionSummary>
                        <AccordionDetails>
                          <Table>
                            <TableHead>
                              <TableRow>
                                <TableCell>Nombre</TableCell>
                                <TableCell>Puntos Requeridos</TableCell>
                                <TableCell>Tipo Usuario</TableCell>
                                <TableCell>Acciones</TableCell>
                              </TableRow>
                            </TableHead>
                            <TableBody>
                              {(groupedBadges[eventType.id] || []).map((badge) => (
                                <TableRow key={badge.id}>
                                  <TableCell>{badge.name}</TableCell>
                                  <TableCell>{badge.required_points}</TableCell>
                                  <TableCell>{badge.user_type}</TableCell>
                                  <TableCell>
                                    <IconButton onClick={() => setEditBadge(badge)} color="primary">
                                      <Edit />
                                    </IconButton>
                                    <IconButton onClick={() => handleDeleteBadge(badge.id)} color="error">
                                      <Delete />
                                    </IconButton>
                                  </TableCell>
                                </TableRow>
                              ))}
                            </TableBody>
                          </Table>
                        </AccordionDetails>
                      </Accordion>
                    ))}
                  </ConfigGlassCard>
                </CardContent>
              </ConfigGlassCard>

              {/* Event Type Dialog */}
              <Dialog open={!!editEventType} onClose={() => setEditEventType(null)}>
                <DialogTitle>{editEventType?.id ? 'Editar Tipo de Evento' : 'Nuevo Tipo de Evento'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editEventType?.id ? handleUpdateEventType : handleCreateEventType} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editEventType?.name || ''}
                      onChange={(e) => setEditEventType({ ...editEventType!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editEventType?.description || ''}
                      onChange={(e) => setEditEventType({ ...editEventType!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Puntos por evento"
                      type="number"
                      fullWidth
                      value={editEventType?.points_per_event || 0}
                      onChange={(e) => setEditEventType({ ...editEventType!, points_per_event: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editEventType?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Badge Dialog */}
              <Dialog open={!!editBadge} onClose={() => setEditBadge(null)}>
                <DialogTitle>{editBadge?.id ? 'Editar Insignia' : 'Nueva Insignia'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editBadge?.id ? handleUpdateBadge : handleCreateBadge} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editBadge?.name || ''}
                      onChange={(e) => setEditBadge({ ...editBadge!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editBadge?.description || ''}
                      onChange={(e) => setEditBadge({ ...editBadge!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Puntos Requeridos"
                      type="number"
                      fullWidth
                      value={editBadge?.required_points || 0}
                      onChange={(e) => setEditBadge({ ...editBadge!, required_points: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <TextField
                      label="Tipo de Evento"
                      select
                      fullWidth
                      value={editBadge?.event_type_id || 0}
                      onChange={(e) => setEditBadge({ ...editBadge!, event_type_id: parseInt(e.target.value) })}
                      margin="normal"
                      SelectProps={{ native: true }}
                    >
                      {eventTypes.map((et) => (
                        <option key={et.id} value={et.id}>{et.name}</option>
                      ))}
                    </TextField>
                    <TextField
                      label="Tipo de Usuario"
                      select
                      fullWidth
                      value={editBadge?.user_type || 'both'}
                      onChange={(e) => setEditBadge({ ...editBadge!, user_type: e.target.value as any })}
                      margin="normal"
                      SelectProps={{ native: true }}
                    >
                      <option value="anonymous">Anónimo</option>
                      <option value="registered">Registrado</option>
                      <option value="both">Ambos</option>
                    </TextField>
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editBadge?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* CUpones Tab */}
          {activeTab === 4 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <LocalActivity sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Cupones
                  </Typography>

                  {/* Botón para crear cupón */}
                  <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                    <Button
                      variant="contained"
                      startIcon={<AddCircle />}
                      onClick={() => setEditCoupon({ id: 0, name: '', description: '', credits: 0, active: true, unique_identifier: '', status: 'active', issued_at: new Date().toISOString() })}
                    >
                      Nuevo Cupón
                    </Button>
                  </Box>

                  {/* Tabla de cupones */}
                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>Nombre</TableCell>
                        <TableCell>Descripción</TableCell>
                        <TableCell>Créditos</TableCell>
                        <TableCell>Estado</TableCell>
                        <TableCell>Acciones</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {coupons.map((coupon) => (
                        <TableRow key={coupon.id}>
                          <TableCell>{coupon.name}</TableCell>
                          <TableCell>{coupon.description || 'Sin descripción'}</TableCell>
                          <TableCell>{coupon.credits}</TableCell>
                          <TableCell>
                            <Chip
                              label={coupon.status}
                              color={coupon.status === "active" ? "success" : "error"}
                            />
                          </TableCell>
                          <TableCell>
                            <IconButton onClick={() => setEditCoupon(coupon)} color="primary">
                              <Edit />
                            </IconButton>
                            <IconButton onClick={() => handleDeleteCoupon(coupon.id)} color="error">
                              <Delete />
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </CardContent>
              </ConfigGlassCard>

              {/* Diálogo para crear/editar cupón */}
              <Dialog open={!!editCoupon} onClose={() => setEditCoupon(null)}>
                <DialogTitle>{editCoupon?.id ? 'Editar Cupón' : 'Nuevo Cupón'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={handleSubmitCoupon} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editCoupon?.name || ''}
                      onChange={(e) => setEditCoupon({ ...editCoupon!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editCoupon?.description || ''}
                      onChange={(e) => setEditCoupon({ ...editCoupon!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Créditos"
                      type="number"
                      fullWidth
                      value={editCoupon?.credits || 0}
                      onChange={(e) => setEditCoupon({ ...editCoupon!, credits: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <FormControlLabel
                      control={
                        <Switch
                          checked={editCoupon?.active || false}
                          onChange={(e) => setEditCoupon({ ...editCoupon!, active: e.target.checked })}
                          color="primary"
                        />
                      }
                      label="Activo"
                      sx={{ mt: 2 }}
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editCoupon?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* Pagos Tab */}
          {activeTab === 5 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <MonetizationOn sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Pagos
                  </Typography>

                  <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                    <Button
                      variant="contained"
                      startIcon={<AddCircle />}
                      onClick={() => setEditPaymentProvider({ id: 0, name: '', active: true })}
                    >
                      Nuevo Proveedor
                    </Button>
                  </Box>

                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>Nombre</TableCell>
                        <TableCell>Estado</TableCell>
                        <TableCell>Acciones</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {paymentProviders.map((provider) => (
                        <TableRow key={provider.id}>
                          <TableCell>{provider.name}</TableCell>
                          <TableCell>
                            <Switch
                              checked={provider.active}
                              onChange={(e) => handleTogglePaymentProvider(provider.id, e.target.checked)}
                              color="primary"
                            />
                          </TableCell>
                          <TableCell>
                            <IconButton onClick={() => setEditPaymentProvider(provider)} color="primary">
                              <Edit />
                            </IconButton>
                            <IconButton onClick={() => handleDeletePaymentProvider(provider.id)} color="error">
                              <Delete />
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </CardContent>
              </ConfigGlassCard>

              {/* Payment Provider Dialog */}
              <Dialog open={!!editPaymentProvider} onClose={() => setEditPaymentProvider(null)}>
                <DialogTitle>{editPaymentProvider?.id ? 'Editar Proveedor' : 'Nuevo Proveedor'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editPaymentProvider?.id ? handleUpdatePaymentProvider : handleCreatePaymentProvider} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editPaymentProvider?.name || ''}
                      onChange={(e) => setEditPaymentProvider({ ...editPaymentProvider!, name: e.target.value })}
                      margin="normal"
                    />
                    <FormControlLabel
                      control={
                        <Switch
                          checked={editPaymentProvider?.active || false}
                          onChange={(e) => setEditPaymentProvider({ ...editPaymentProvider!, active: e.target.checked })}
                          color="primary"
                        />
                      }
                      label="Activo"
                      sx={{ mt: 2 }}
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editPaymentProvider?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* Configuraciones Tab */}
          {activeTab === 6 && (
            <Box sx={{ mb: 4 }}>
              <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                <Button
                  variant="outlined"
                  onClick={toggleAllSettings}
                  startIcon={<ExpandMore />}
                  sx={{ borderRadius: '12px' }}
                >
                  {allSettingsExpanded ? 'Contraer Todo' : 'Expandir Todo'}
                </Button>
              </Box>

              {Object.entries(settingsByTag).map(([tag, settings]) => (
                <ConfigGlassCard key={tag} sx={{ mb: 2 }}>
                  <Accordion
                    sx={{ background: 'transparent', boxShadow: 'none' }}
                    expanded={expandedSettings[tag] || false}
                    onChange={() => setExpandedSettings(prev => ({ ...prev, [tag]: !prev[tag] }))}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar sx={{ bgcolor: theme.palette.primary.main, width: 32, height: 32 }}>
                          <Settings sx={{ fontSize: 16 }} />
                        </Avatar>
                        <Typography variant="h6">{tag}</Typography>
                        <Chip label={`${settings.length} configs`} size="small" color="primary" variant="outlined" />
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Grid container spacing={2}>
                        {settings.map((setting) => (
                          <Grid item xs={12} md={6} key={setting.key}>
                            <TextField
                              label={setting.key}
                              defaultValue={setting.value}
                              onBlur={(e) => handleSaveSetting(setting.key, e.target.value)}
                              fullWidth
                              variant="outlined"
                              size="small"
                              helperText={setting.description}
                              InputProps={{ sx: { borderRadius: '12px' } }}
                            />
                          </Grid>
                        ))}
                      </Grid>
                    </AccordionDetails>
                  </Accordion>
                </ConfigGlassCard>
              ))}
            </Box>
          )}
        </motion.div>
      </Box>

      {/* Notificaciones */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box>
  );
}

// Función auxiliar para descripciones de características
const getFeatureDescription = (key: string) => {
  const descriptions: Record<string, string> = {
    enable_registration: 'Permite a nuevos usuarios registrarse en la plataforma. Si se desactiva, solo los administradores podrán crear cuentas.',
    enable_social_login: 'Permite el inicio de sesión con proveedores sociales como Google, Facebook, etc. Requiere configuración previa de las APIs.',
    disable_anonymous_users: 'Impide el acceso a usuarios no registrados. Todos los visitantes deberán iniciar sesión para usar la plataforma.',
    disable_credits: 'Deshabilita el sistema de créditos en la plataforma. Los usuarios no podrán comprar ni gastar créditos.',
    enable_payment_methods: 'Habilita diferentes métodos de pago como tarjetas, PayPal, etc. Requiere configuración previa de cada proveedor.',
    enable_points: 'Activa el sistema de puntos por actividades. Los usuarios ganarán puntos por completar acciones en la plataforma.',
    enable_badges: 'Permite la obtención de insignias al alcanzar ciertos logros. Configura los requisitos en la pestaña de Gamificación.',
    enable_coupons: 'Permite la creación y uso de cupones de descuento. Los usuarios podrán canjear cupones para obtener descuentos en compras.'
  };
  return descriptions[key] || 'Funcionalidad del sistema';
};

 y ahora te paso los bugs que hay en este archivo tras la implantación y otros que he viesto en el dashboard de admin:



2.1 En la pestaña origenes hay un error en la logica:

Ahora mismo el dashboard de admin coge los origines permitidos de la site_settings allowed_origins:

esta es la entrada en la db:

10|allowed_origins|["http://localhost:3000", "https://neptuno.app", "test", "https://nuevoorigen.com"]|Orígenes permitidos para CORS|cors||2025-04-10 10:26:42.688850

y ahi es donde actualiza los origenes permitidos, como ves es un json. Vamos a cambiar esa logica actual por la siguiente:

- el site_settings allowed_origins pasara a ser true o false, para activar o desactivar los origines de CORS
- cuando añadimos, modificamos o borramos un origen nuevo debe hacerse con persistencia (existe un modelo)
-crea o modifica los archivos necesarios para este nuevo funcionamiento

te paso los archivos existentes ahora de este tema:

#backend/models/allowed_origin.py
from sqlalchemy import Column, Integer, String
from models.user import Base

class AllowedOrigin(Base):
    __tablename__ = "allowed_origins"
    id = Column(Integer, primary_key=True, index=True)
    origin = Column(String(255), unique=True, nullable=False)  # Ejemplo: "https://thirdparty.com"


# backend/services/origin_service.py
from sqlalchemy.orm import Session
from models.user import User
from models.allowed_origin import AllowedOrigin
from core.logging import configure_logging
from fastapi import HTTPException

logger = configure_logging()

def get_allowed_origins(db: Session) -> list[str]:
    try:
        origins = db.query(AllowedOrigin).all()
        return [origin.origin for origin in origins]
    except Exception as e:
        logger.error(f"Error al obtener orígenes permitidos: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener orígenes")

def add_allowed_origin(db: Session, origin: str, admin_id: int):
    try:
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores")
        if db.query(AllowedOrigin).filter(AllowedOrigin.origin == origin).first():
            raise HTTPException(status_code=400, detail="Origen ya existe")
        new_origin = AllowedOrigin(origin=origin)
        db.add(new_origin)
        db.commit()
        logger.info(f"Origen permitido añadido: {origin} por admin {admin_id}")
        return {"origin": origin}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al añadir origen permitido {origin}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al añadir origen")

# backend/api/v1/site_settings.py
from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from schemas.site_settings import SiteSettingResponse
from services.origin_service import add_allowed_origin
from models.user import User
from dependencies.auth import UserContext, get_user_context
from services.settings_service import get_all_settings, set_setting, update_setting, get_setting
from core.database import get_db
from core.logging import configure_logging
from pydantic import BaseModel

router = APIRouter(tags=["site_settings"])

logger = configure_logging()

class AddOriginRequest(BaseModel):
    origin: str

@router.post("/allowed-origins")
async def add_origin(
    request: AddOriginRequest,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    origin = request.origin
    allowed_origins = get_setting(db, "allowed_origins") or []
    if origin in allowed_origins:
        raise HTTPException(status_code=400, detail="Origen ya existe")
    allowed_origins.append(origin)
    return set_setting(db, "allowed_origins", allowed_origins, user.user_id, "Orígenes permitidos para CORS")

@router.get("/admin/config", response_model=List[SiteSettingResponse])
def get_admin_config(user=Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo administradores")
    return get_all_settings(db, user.user_id)



class UpdateConfigRequest(BaseModel):
    key: str
    value: dict | list | int | str
    description: str | None = None

@router.post("/admin/config")
async def update_config(
    request: UpdateConfigRequest,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    return set_setting(db, request.key, request.value, user.user_id, request.description)

@router.put("/{key}")
def update_site_setting(
    key: str,
    value: str,
    description: str = None,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.user_type != "registered" or not db.query(User).filter(User.id == user.user_id, User.rol == "admin").first():
        raise HTTPException(status_code=403, detail="Solo administradores")
    return update_setting(db, user.user_id, key, value, description)

@router.get("/{key}")
def get_site_setting(key: str, db: Session = Depends(get_db)):
    return get_setting(db, key)







2.2 Las integraciones tienen un bug: ahora mismo la pestaña integraciones SOLO te muestra las integraciones del usuario que esta viendo
esa pestaña (por lo que solo y siempre mostrará las integraciones creadas por admin) pero aqui debe mostrarlas integraciones de todos los usuarios,
asi como activarlas, desactivarlas, borrarlas, o editarlas. Las integraciones de cada usuario en el futuro podrá meterlas en su dashboard,
pero NO podrán activarlas, será el admin quien desde su dashboard al ver todas las integraciones pueda activarla.


Mas cosas de integraciones: 

Al añadir una nueva integración en el codigo actual me da este errror:

Console Error

Each child in a list should have a unique "key" prop.

Check the render method of `MuiGridRoot`. It was passed a child from ConfigurePage. See https://react.dev/link/warning-keys for more information.

src/app/admin/dashboard/page.tsx (1130:21) @ ConfigurePage/<.children<.children<.children<.children<.children<

  1128 |                 <Grid container spacing={2}>
  1129 |                   {integrations.map((integration) => (
> 1130 |                     <Grid item xs={12} md={6} key={integration.id}>
       |                     ^
  1131 |                       <ConfigGlassCard>
  1132 |                         <CardContent>
  1133 |                           <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>

Call Stack 22
Show 20 ignore-listed frame(s)
ConfigurePage/<.children<.children<.children<.children<.children<
src/app/admin/dashboard/page.tsx (1130:21)
ConfigurePage
src/app/admin/dashboard/page.tsx (1129:33).


aqui tienes los archivos que te pueden hacer falta

# backend/api/v1/integrations.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from models.integration import Integration
from dependencies.auth import UserContext, get_user_context
from services.integration_service import add_integration
from core.database import get_db
from pydantic import BaseModel

router = APIRouter(tags=["integrations"])

class CreateIntegrationRequest(BaseModel):
    name: str
    webhook_url: str
    event_type: str

@router.post("/")
def create_integration(
    request: CreateIntegrationRequest,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.user_type != "registered":
        raise HTTPException(status_code=403, detail="Solo usuarios registrados")
    return add_integration(db, user.user_id, request.name, request.webhook_url, request.event_type)

@router.get("/")
def list_integrations(
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.user_type != "registered":
        raise HTTPException(status_code=403, detail="Solo usuarios registrados")
    integrations = db.query(Integration).filter(Integration.user_id == user.user_id).all()
    return [
        {
            "id": i.id,
            "name": i.name,
            "webhook_url": i.webhook_url,
            "event_type": i.event_type,
            "active": i.active,
            "created_at": i.created_at,
            "last_triggered": i.last_triggered,
        }
        for i in integrations
    ]

# backend/models/integration.py
from sqlalchemy import Column, Integer, String, Boolean, DateTime, ForeignKey
from models.user import Base
from datetime import datetime

class Integration(Base):
    __tablename__ = "integrations"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=False)  # Vinculado a un usuario
    name = Column(String(50), nullable=False)  # "slack", "zapier", "crm_custom"
    webhook_url = Column(String(255), nullable=False)  # URL del webhook externo
    event_type = Column(String(50), nullable=False)  # "credit_usage", "user_login", "payment_added"
    active = Column(Boolean, default=True)  # Estado de la integración
    created_at = Column(DateTime, default=datetime.utcnow)
    last_triggered = Column(DateTime, nullable=True)  # Última vez que se disparó

# // backend/schemas/integration.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class IntegrationBase(BaseModel):
    name: str
    webhook_url: str
    event_type: str

class IntegrationCreate(IntegrationBase):
    pass

class IntegrationResponse(IntegrationBase):
    id: int
    user_id: int
    active: bool
    created_at: datetime
    last_triggered: Optional[datetime] = None

    class Config:
        from_attributes = True  # Para mapear desde objetos SQLAlchemy

# backend/services/integration_service.py
from datetime import datetime
from sqlalchemy.orm import Session
from models.integration import Integration
from core.logging import configure_logging
from fastapi import HTTPException
import requests

logger = configure_logging()

def add_integration(db: Session, user_id: str, name: str, webhook_url: str, event_type: str):
    try:
        integration = Integration(
            user_id=user_id,
            name=name,
            webhook_url=webhook_url,
            event_type=event_type
        )
        db.add(integration)
        db.commit()
        logger.info(f"Integración {name} añadida para usuario ID {user_id}")
        return integration
    except Exception as e:
        logger.error(f"Error al añadir integración {name} para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al añadir integración")

def trigger_webhook(db: Session, event_type: str, payload: dict):
    try:
        integrations = db.query(Integration).filter(Integration.event_type == event_type, Integration.active == True).all()
        for integration in integrations:
            try:
                response = requests.post(integration.webhook_url, json=payload, timeout=5)
                if response.status_code == 200:
                    integration.last_triggered = datetime.utcnow()
                    db.commit()
                    logger.info(f"Webhook disparado para integración ID {integration.id}")
                else:
                    logger.warning(f"Webhook falló para integración ID {integration.id}: {response.status_code}")
            except Exception as e:
                logger.error(f"Error al disparar webhook ID {integration.id}: {str(e)}")
    except Exception as e:
        logger.error(f"Error al procesar webhooks para event_type {event_type}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar webhooks")

En este punto que ya has dejado las integraciones bien realizadas, es momento de que añadas
la pestaña integración en el dashboard de user, el user puede añadir integraciones pero no puede
activarlas, eso lo hace el admin

// src/app/user/dashboard/page.tsx
// src/app/user/dashboard/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { Dialog, DialogTitle, DialogContent, DialogActions, Table, TableBody, TableCell, TableHead, TableRow } from "@mui/material";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box, Grid, Card, CardContent, CardHeader, TextField, Button, Accordion, AccordionSummary, AccordionDetails, Typography, IconButton,
  Snackbar, Alert, MenuItem, Avatar, Chip, Divider, List, ListItem, ListItemAvatar, ListItemText, Badge, Paper, Tabs, Tab, useTheme, styled
} from "@mui/material";
import {
  AccountCircle, Lock, Payment, CreditCard, AddCircle, Delete, ExpandMore, Edit, History, AttachMoney, Security, Logout, Person,
  LocationOn, Language, Star, StarBorder,
  LocalActivity
} from "@mui/icons-material";

// Styled Components
const GradientCard = styled(Card)(({ theme }) => ({
  background: `linear-gradient(135deg, var(--primary) 0%, var(--primary-hover) 100%)`,
  color: 'white',
  borderRadius: '16px',
  boxShadow: theme.shadows[4]
}));

const GlassCard = styled(Card)(({ theme }) => ({
  background: 'rgba(248, 249, 250, 0.8)',
  backdropFilter: 'blur(10px)',
  border: '1px solid rgba(222, 226, 230, 0.5)',
  borderRadius: '16px',
  boxShadow: theme.shadows[2]
}));

interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
}

interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string;
}

interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}

export default function UserDashboard() {
  const { user, logout, updateProfile } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState({ email: "", username: "", ciudad: "", website: "" });
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [methods, setMethods] = useState<PaymentMethod[]>([]);
  const [newMethod, setNewMethod] = useState({ payment_type: "", details: "", is_default: false });
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>([]);
  const [credits, setCredits] = useState("");
  const [paymentAmount, setPaymentAmount] = useState("");
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [tabValue, setTabValue] = useState(0);
  const [editMethod, setEditMethod] = useState<PaymentMethod | null>(null);
  const [deleteMethodId, setDeleteMethodId] = useState<number | null>(null);
  const { coupons, setCoupons } = useAuth();

  const handleRedeem = async (couponId: number) => {
    const { data } = await fetchAPI<any>(`/v1/coupons/redeem/${couponId}`, {
      method: "POST",
    });
    setCoupons(coupons.map((c) => (c.id === couponId ? data : c)));
    const { data: info } = await fetchAPI<any>("/info");
    setCredits(info.credits);
  };

  useEffect(() => {
    if (!user) {
      router.push("/");
      return;
    }
    setFormData({
      email: user.email || "",
      username: user.username || "",
      ciudad: user.ciudad || "",
      website: user.website || "",
    });

    const fetchData = async () => {
      try {
        const [transRes, methRes, providersRes] = await Promise.all([
          fetchAPI<CreditTransaction[]>("/v1/payments/transactions"),
          fetchAPI<PaymentMethod[]>("/v1/payments/methods"),
          fetchAPI<PaymentProvider[]>("/v1/payment-providers"),
        ]);
        setTransactions(transRes.data || []);
        setMethods(methRes.data || []);
        setPaymentProviders(providersRes.data?.filter(p => p.active) || []);
        if (providersRes.data && providersRes.data.length > 0) {
          setNewMethod(prev => ({ ...prev, payment_type: providersRes.data.find(p => p.active)?.name || "" }));
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      }
    };
    fetchData();
  }, [user, router]);

  const handleEditMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editMethod) return;
    try {
      const { data } = await fetchAPI<PaymentMethod>(`/v1/payments/methods/${editMethod.id}`, {
        method: "PUT",
        data: editMethod,
      });
      setMethods(methods.map((m) => (m.id === data!.id ? data! : m)));
      setEditMethod(null);
      setSuccess("Método actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar método");
    }
  };

  const handleDeleteMethod = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}`, { method: "DELETE" });
      setMethods(methods.filter((m) => m.id !== id));
      setDeleteMethodId(null);
      setSuccess("Método eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar método");
    }
  };

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateProfile(formData);
      setSuccess("Perfil actualizado");
      setEditMode(false);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar perfil");
    }
  };

  const handleChangePassword = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<{ message: string }>("/v1/auth/me/password", {
        method: "PUT",
        data: { current_password: currentPassword, new_password: newPassword },
      });
      setSuccess(data?.message || "Contraseña actualizada");
      setCurrentPassword("");
      setNewPassword("");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al cambiar contraseña");
    }
  };

  const handlePurchase = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<CreditTransaction>("/v1/payments/purchase", {
        method: "POST",
        data: { credits: parseInt(credits), payment_amount: parseFloat(paymentAmount), payment_method: "stripe" },
      });
      setTransactions([data!, ...transactions]);
      setCredits("");
      setPaymentAmount("");
      setSuccess("Créditos comprados");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al comprar créditos");
    }
  };

  const handleAddMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentMethod>("/v1/payments/methods", {
        method: "POST",
        data: newMethod,
      });
      setMethods([...methods, data!]);
      setNewMethod({ payment_type: paymentProviders[0]?.name || "", details: "", is_default: false });
      setSuccess("Método añadido");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir método");
    }
  };

  const handleSetDefault = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}/default`, { method: "PUT" });
      setMethods(methods.map((m) => ({ ...m, is_default: m.id === id })));
      setSuccess("Método predeterminado actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al establecer predeterminado");
    }
  };

  const handleDeleteAccount = async () => {
    if (confirm("¿Estás seguro de eliminar tu cuenta? Esta acción es irreversible.")) {
      try {
        await fetchAPI("/v1/users/me", { method: "DELETE" });
        await logout();
        router.push("/user/auth/#login");
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al eliminar cuenta");
      }
    }
  };

  if (!user) return (
    <Box sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h6" color="textSecondary">Cargando tu perfil...</Typography>
      </motion.div>
    </Box>
  );

  return (
    <Box sx={{
      p: { xs: 2, md: 4 },
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <Box sx={{ maxWidth: '1400px', mx: 'auto' }}>
        {/* Header Section */}
        <Box sx={{
          display: 'flex',
          flexDirection: { xs: 'column', md: 'row' },
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 4,
          gap: 2
        }}>
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                display: 'inline-block'
              }}
            >
              Hola, {user.username}!
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Bienvenido a tu panel de control
            </Typography>
          </motion.div>

          <Badge
            overlap="circular"
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            badgeContent={
              <IconButton onClick={() => setEditMode(true)} size="small" sx={{ bgcolor: 'primary.main', color: 'white' }}>
                <Edit fontSize="small" />
              </IconButton>
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.primary.main,
                fontSize: '2rem',
                boxShadow: theme.shadows[6]
              }}
            >
              {user.username.charAt(0).toUpperCase()}
            </Avatar>
          </Badge>
        </Box>

        {/* Stats Cards */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.1 }}
        >
          <Grid container spacing={3} sx={{ mb: 4 }}>
            {/* Credits Card */}
            <Grid item xs={12} md={4}>
              <GradientCard>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Tus Créditos
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {user.credits ?? 0}
                      </Typography>
                    </Box>
                    <AttachMoney sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Transactions Card */}
            <Grid item xs={12} md={4}>
              <GradientCard sx={{ background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)' }}>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Transacciones
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {transactions.length}
                      </Typography>
                    </Box>
                    <History sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Payment Methods Card */}
            <Grid item xs={12} md={4}>
              <GradientCard sx={{ background: 'linear-gradient(135deg, #a6c1ee 0%, #fbc2eb 100%)' }}>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Métodos de Pago
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {methods.length}
                      </Typography>
                    </Box>
                    <Payment sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Tabs Navigation */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <Paper sx={{ mb: 3, borderRadius: '12px', overflow: 'hidden' }}>
            <Tabs
              value={tabValue}
              onChange={(_, newValue) => setTabValue(newValue)}
              variant="scrollable"
              scrollButtons="auto"
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label="Perfil" icon={<Person />} iconPosition="start" />
              <Tab label="Seguridad" icon={<Security />} iconPosition="start" />
              <Tab label="Cupones" icon={<LocalActivity />} iconPosition="start" />
              <Tab label="Transacciones" icon={<History />} iconPosition="start" />
              <Tab label="Métodos de Pago" icon={<Payment />} iconPosition="start" />
              <Tab label="Comprar Créditos" icon={<CreditCard />} iconPosition="start" />
            </Tabs>
          </Paper>
        </motion.div>

        {/* Tab Content */}
        <Box sx={{ mb: 4 }}>
          {/* Profile Tab */}
          {tabValue === 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Información Personal"
                      avatar={<AccountCircle color="primary" />}
                      action={
                        <IconButton onClick={() => setEditMode(!editMode)}>
                          <Edit color="primary" />
                        </IconButton>
                      }
                    />
                    <CardContent>
                      <AnimatePresence mode="wait">
                        {editMode ? (
                          <Box
                            component={motion.form}
                            key="edit"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                            onSubmit={handleUpdate}
                            sx={{ display: "flex", flexDirection: "column", gap: 2 }}
                          >
                            <TextField
                              label="Email"
                              type="email"
                              value={formData.email}
                              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Username"
                              type="text"
                              value={formData.username}
                              onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Ciudad"
                              type="text"
                              value={formData.ciudad}
                              onChange={(e) => setFormData({ ...formData, ciudad: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: <LocationOn color="action" sx={{ mr: 1 }} />
                              }}
                            />
                            <TextField
                              label="Website"
                              type="text"
                              value={formData.website}
                              onChange={(e) => setFormData({ ...formData, website: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: <Language color="action" sx={{ mr: 1 }} />
                              }}
                            />
                            <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
                              <Button
                                type="submit"
                                variant="contained"
                                color="primary"
                                sx={{ flex: 1 }}
                              >
                                Guardar Cambios
                              </Button>
                              <Button
                                onClick={() => setEditMode(false)}
                                variant="outlined"
                                sx={{ flex: 1 }}
                              >
                                Cancelar
                              </Button>
                            </Box>
                          </Box>
                        ) : (
                          <Box
                            component={motion.div}
                            key="view"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                          >
                            <List>
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.primary.light }}>
                                    <Person />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Username"
                                  secondary={user.username || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                                    <AccountCircle />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Email"
                                  secondary={user.email || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.success.light }}>
                                    <LocationOn />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Ciudad"
                                  secondary={user.ciudad || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.warning.light }}>
                                    <Language />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Website"
                                  secondary={user.website || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                            </List>
                          </Box>
                        )}
                      </AnimatePresence>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Actividad Reciente"
                      avatar={<History color="primary" />}
                    />
                    <CardContent>
                      {transactions.slice(0, 3).length > 0 ? (
                        <List>
                          {transactions.slice(0, 3).map((t) => (
                            <motion.div
                              key={t.id}
                              initial={{ opacity: 0 }}
                              animate={{ opacity: 1 }}
                              transition={{ duration: 0.3 }}
                            >
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{
                                    bgcolor: t.amount > 0 ? theme.palette.success.light : theme.palette.error.light
                                  }}>
                                    {t.amount > 0 ? "+" : "-"}
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary={`${t.transaction_type}`}
                                  secondary={`${new Date(t.timestamp).toLocaleString()} • ${t.payment_status}`}
                                />
                                <Typography variant="body2" color={t.amount > 0 ? "success.main" : "error.main"}>
                                  {t.amount > 0 ? "+" : ""}{t.amount} créditos
                                </Typography>
                              </ListItem>
                              <Divider variant="inset" component="li" />
                            </motion.div>
                          ))}
                        </List>
                      ) : (
                        <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 2 }}>
                          No hay actividad reciente
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(2)}
                      >
                        Ver todas las transacciones
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>

              {/* Danger Zone moved to Profile Tab */}
              <GlassCard sx={{ mt: 3 }}>
                <CardHeader
                  title="Zona Peligrosa"
                  avatar={<Security color="error" />}
                />
                <CardContent>
                  <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                    Estas acciones son irreversibles. Por favor, procede con precaución.
                  </Typography>
                  <Box sx={{ display: 'flex', gap: 2 }}>
                    <Button
                      onClick={logout}
                      variant="outlined"
                      color="secondary"
                      startIcon={<Logout />}
                      sx={{ flex: 1 }}
                    >
                      Cerrar Sesión
                    </Button>
                    <Button
                      onClick={handleDeleteAccount}
                      variant="contained"
                      color="error"
                      startIcon={<Delete />}
                      sx={{ flex: 1 }}
                    >
                      Eliminar Cuenta
                    </Button>
                  </Box>
                </CardContent>
              </GlassCard>
            </motion.div>
          )}

          {/* Security Tab */}
          {tabValue === 1 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Cambiar Contraseña"
                      avatar={<Lock color="primary" />}
                    />
                    <CardContent>
                      <Box
                        component="form"
                        onSubmit={handleChangePassword}
                        sx={{ display: "flex", flexDirection: "column", gap: 2 }}
                      >
                        <TextField
                          label="Contraseña Actual"
                          type="password"
                          value={currentPassword}
                          onChange={(e) => setCurrentPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: <Lock color="action" sx={{ mr: 1 }} />
                          }}
                        />
                        <TextField
                          label="Nueva Contraseña"
                          type="password"
                          value={newPassword}
                          onChange={(e) => setNewPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: <Security color="action" sx={{ mr: 1 }} />
                          }}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          sx={{ mt: 1 }}
                        >
                          Actualizar Contraseña
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Métodos de Pago"
                      subheader={`${methods.length} configurados`}
                      avatar={<Payment color="primary" />}
                    />
                    <CardContent>
                      {methods.length > 0 ? (
                        <List>
                          {methods.slice(0, 2).map((m) => (
                            <ListItem key={m.id}>
                              <ListItemAvatar>
                                <Avatar sx={{ bgcolor: m.is_default ? theme.palette.success.light : theme.palette.grey[300] }}>
                                  {m.is_default ? <Star /> : <StarBorder />}
                                </Avatar>
                              </ListItemAvatar>
                              <ListItemText
                                primary={m.payment_type}
                                secondary={m.details}
                              />
                            </ListItem>
                          ))}
                        </List>
                      ) : (
                        <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 2 }}>
                          No hay métodos de pago configurados
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(3)}
                      >
                        {methods.length > 0 ? 'Gestionar métodos' : 'Añadir método'}
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}

          {/* Coupons Tab */}
          {tabValue === 2 && (
            <Box>
              <Typography variant="h6">Mis Cupones</Typography>
              {coupons.length === 0 ? (
                <Typography>No tienes cupones</Typography>
              ) : (
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Nombre</TableCell>
                      <TableCell>Créditos</TableCell>
                      <TableCell>Estado</TableCell>
                      <TableCell>Acciones</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {coupons.map((coupon) => (
                      <TableRow key={coupon.id}>
                        <TableCell>{coupon.name}</TableCell>
                        <TableCell>{coupon.credits}</TableCell>
                        <TableCell>
                          <Chip
                            label={coupon.status}
                            color={coupon.status === "active" ? "success" : "error"}
                          />
                        </TableCell>
                        <TableCell>
                          {coupon.status === "active" && (
                            <Button
                              variant="contained"
                              onClick={() => handleRedeem(coupon.id)}
                            >
                              Canjear
                            </Button>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
            </Box>
          )}


          {/* Transactions Tab */}
          {tabValue === 3 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <GlassCard>
                <CardHeader
                  title="Historial de Transacciones"
                  avatar={<History color="primary" />}
                  action={
                    <Chip
                      label={`${transactions.length} transacciones`}
                      color="primary"
                      variant="outlined"
                    />
                  }
                />
                <CardContent>
                  {transactions.length === 0 ? (
                    <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 4 }}>
                      No hay transacciones registradas
                    </Typography>
                  ) : (
                    <List sx={{ maxHeight: '500px', overflow: 'auto' }}>
                      {transactions.map((t) => (
                        <motion.div
                          key={t.id}
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          transition={{ duration: 0.2 }}
                        >
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{
                                bgcolor: t.amount > 0 ? theme.palette.success.light : theme.palette.error.light
                              }}>
                                {t.amount > 0 ? "+" : "-"}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={t.transaction_type}
                              secondary={`${new Date(t.timestamp).toLocaleString()} • ${t.payment_status}`}
                            />
                            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                              <Typography
                                variant="subtitle1"
                                color={t.amount > 0 ? "success.main" : "error.main"}
                                fontWeight="bold"
                              >
                                {t.amount > 0 ? "+" : ""}{t.amount} créditos
                              </Typography>
                              <Typography variant="caption" color="textSecondary">
                                {t.payment_amount ? `$${t.payment_amount.toFixed(2)}` : 'N/A'} via {t.payment_method || 'N/A'}
                              </Typography>
                            </Box>
                          </ListItem>
                          <Divider variant="inset" component="li" />
                        </motion.div>
                      ))}
                    </List>
                  )}
                </CardContent>
              </GlassCard>
            </motion.div>
          )}

          {/* Payment Methods Tab */}
          {tabValue === 4 && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
              <GlassCard>
                <CardHeader
                  title="Métodos de Pago"
                  avatar={<Payment color="primary" />}
                  subheader="Gestiona tus métodos de pago asociados"
                />
                <CardContent>
                  {methods.length > 0 && (
                    <List sx={{ mb: 3 }}>
                      {methods.map((m) => (
                        <Paper key={m.id} elevation={2} sx={{ mb: 2, borderRadius: "8px", overflow: "hidden" }}>
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{ bgcolor: m.is_default ? theme.palette.success.main : theme.palette.grey[300] }}>
                                {m.is_default ? <Star /> : <CreditCard />}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={
                                <Box sx={{ display: "flex", alignItems: "center" }}>
                                  <Typography sx={{ mr: 1 }}>{m.payment_type}</Typography>
                                  {m.is_default && (
                                    <Chip label="Predeterminado" size="small" color="success" variant="outlined" />
                                  )}
                                </Box>
                              }
                              secondary={m.details}
                            />
                            <Box sx={{ display: "flex", gap: 1 }}>
                              <IconButton onClick={() => setEditMethod(m)} color="primary">
                                <Edit />
                              </IconButton>
                              <IconButton onClick={() => setDeleteMethodId(m.id)} color="error">
                                <Delete />
                              </IconButton>
                              {!m.is_default && (
                                <Button
                                  onClick={() => handleSetDefault(m.id)}
                                  variant="outlined"
                                  size="small"
                                >
                                  Hacer Predeterminado
                                </Button>
                              )}
                            </Box>
                          </ListItem>
                        </Paper>
                      ))}
                    </List>
                  )}

                  {/* Formulario para añadir método */}
                  <Accordion
                    sx={{
                      background: "rgba(255, 255, 255, 0.05)",
                      boxShadow: "none",
                      border: "1px solid rgba(255, 255, 255, 0.2)",
                    }}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Typography>Añadir nuevo método de pago</Typography>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Box component="form" onSubmit={handleAddMethod} sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <TextField
                          label="Tipo"
                          select
                          value={newMethod.payment_type}
                          onChange={(e) => setNewMethod({ ...newMethod, payment_type: e.target.value })}
                          fullWidth
                          variant="outlined"
                          size="small"
                        >
                          {paymentProviders.map((provider) => (
                            <MenuItem key={provider.id} value={provider.name}>
                              {provider.name}
                            </MenuItem>
                          ))}
                        </TextField>
                        <TextField
                          label="Detalles"
                          value={newMethod.details}
                          onChange={(e) => setNewMethod({ ...newMethod, details: e.target.value })}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          multiline
                          rows={3}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          startIcon={<AddCircle />}
                          sx={{ mt: 1 }}
                        >
                          Añadir Método
                        </Button>
                      </Box>
                    </AccordionDetails>
                  </Accordion>
                </CardContent>
              </GlassCard>

              {/* Diálogo para editar método */}
              <Dialog open={!!editMethod} onClose={() => setEditMethod(null)}>
                <DialogTitle>Editar Método de Pago</DialogTitle>
                <DialogContent>
                  <Box
                    component="form"
                    onSubmit={handleEditMethod}
                    sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}
                  >
                    <TextField
                      label="Tipo"
                      select
                      value={editMethod?.payment_type || ""}
                      onChange={(e) => setEditMethod({ ...editMethod!, payment_type: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                    >
                      {paymentProviders.map((provider) => (
                        <MenuItem key={provider.id} value={provider.name}>
                          {provider.name}
                        </MenuItem>
                      ))}
                    </TextField>
                    <TextField
                      label="Detalles"
                      value={editMethod?.details || ""}
                      onChange={(e) => setEditMethod({ ...editMethod!, details: e.target.value })}
                      fullWidth
                      required
                      variant="outlined"
                      size="small"
                      multiline
                      rows={3}
                    />
                    <DialogActions>
                      <Button onClick={() => setEditMethod(null)} variant="outlined">
                        Cancelar
                      </Button>
                      <Button type="submit" variant="contained" color="primary">
                        Guardar
                      </Button>
                    </DialogActions>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Diálogo para confirmar eliminación */}
              <Dialog open={!!deleteMethodId} onClose={() => setDeleteMethodId(null)}>
                <DialogTitle>¿Eliminar Método de Pago?</DialogTitle>
                <DialogContent>
                  <Typography>Esta acción es irreversible. ¿Estás seguro de eliminar este método?</Typography>
                </DialogContent>
                <DialogActions>
                  <Button onClick={() => setDeleteMethodId(null)} variant="outlined">
                    Cancelar
                  </Button>
                  <Button
                    onClick={() => handleDeleteMethod(deleteMethodId!)}
                    variant="contained"
                    color="error"
                  >
                    Eliminar
                  </Button>
                </DialogActions>
              </Dialog>
            </motion.div>
          )}

          {/* Buy Credits Tab */}
          {tabValue === 5 && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader title="Comprar Créditos" avatar={<AttachMoney color="primary" />} subheader="Recarga tu saldo de créditos" />
                    <CardContent>
                      <Box component="form" onSubmit={handlePurchase} sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <TextField
                          label="Cantidad de Créditos"
                          type="number"
                          value={credits}
                          onChange={(e) => setCredits(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{ startAdornment: <AttachMoney color="action" sx={{ mr: 1 }} /> }}
                        />
                        <TextField
                          label="Monto a Pagar (USD)"
                          type="number"
                          inputProps={{ step: "0.01" }}
                          value={paymentAmount}
                          onChange={(e) => setPaymentAmount(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{ startAdornment: <Typography sx={{ mr: 1 }}>$</Typography> }}
                        />
                        <TextField
                          label="Método de Pago"
                          select
                          value={methods.find((m) => m.is_default)?.id || methods[0]?.id || ""}
                          onChange={(e) => {
                            const selectedMethod = methods.find((m) => m.id === parseInt(e.target.value));
                            if (selectedMethod) {
                              handleSetDefault(selectedMethod.id);
                            }
                          }}
                          fullWidth
                          variant="outlined"
                          size="small"
                          disabled={methods.length === 0}
                          helperText={methods.length === 0 ? "No hay métodos de pago disponibles" : "Selecciona un método de pago"}
                        >
                          {methods.map((method) => (
                            <MenuItem key={method.id} value={method.id}>
                              {method.payment_type} - {method.details} {method.is_default ? "(Predeterminado)" : ""}
                            </MenuItem>
                          ))}
                        </TextField>
                        <Button type="submit" variant="contained" color="primary" size="large" sx={{ mt: 2 }} disabled={methods.length === 0}>
                          Comprar Créditos
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader title="Tarifas y Beneficios" avatar={<CreditCard color="primary" />} />
                    <CardContent>
                      <List>
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.success.light }}>
                              <Star />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="1 crédito = $1 USD" secondary="Tasa de cambio fija" />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                              <Payment />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="Múltiples métodos de pago" secondary="Tarjetas, PayPal y más" />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.warning.light }}>
                              <Security />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="Transacciones seguras" secondary="Encriptación SSL" />
                        </ListItem>
                      </List>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}
        </Box>
      </Box>

      {/* Notifications */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box >
  );
}

2.3 En la pestaña gamificación del panel de admin tambien he encontrado bugs:

Si borro un evento de gamificación no persiste ese cambio, vuelve aparecer
Cuando edito un evento de gammificación me vuelve de nuevo el dashboard y no me refleja los cambios. Al editar el evento
no debe cambiar ni recargar la pagina y por supesto deberia actualizar ese evento de gamificación.

CUando creo insignias tampoco funciona como espero: si creo una insignia nueva si se graba, correcto, pero si la edito
me recarga la pagina y no guarda los cambios, debe permanecer la vista en la pestaña gamificación y guardar los cambios.

La eliminacion de badges si funciona.

He visto este error en consola, por si te ayuda: 

Navega a http://localhost:3000/admin/dashboard/?
Iniciando fetchAPI para /v1/gamification/event-types/6 api.ts:47:13
XHRPUT
http://127.0.0.1:8000/v1/gamification/event-types/6
NS_BINDING_ABORTED

[PUT] /v1/gamification/event-types/6 - Status: 500 <empty string> api.ts:43:13
GET
http://localhost:3000/admin/dashboard/?

aqui te paso los archivos que te pueden hacer falta

# backend/api/v1/gamification.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.gamification_service import (
    create_event_type, get_badges_for_event, get_event_details, get_event_types, get_rankings, get_user_events, get_user_gamification, get_user_progress_for_event, register_event, update_event_type, delete_event_type,
    create_badge, get_badges, update_badge, delete_badge
)
from schemas.gamification import (
    EventTypeCreate, EventTypeResponse, BadgeCreate, BadgeResponse,
    GamificationEventCreate, GamificationEventResponse, UserGamificationResponse, RankingResponse
)
from typing import List

router = APIRouter(tags=["Gamification"])

# Endpoints existentes
@router.get("/rankings", response_model=List[RankingResponse])
def get_rankings_endpoint(db: Session = Depends(get_db)):
    return get_rankings(db)

@router.post("/events")
async def create_event(event: GamificationEventCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    return register_event(db, event, user)

@router.get("/me", response_model=List[UserGamificationResponse])
def get_my_gamification(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    return get_user_gamification(db, user)

@router.get("/events", response_model=List[GamificationEventResponse])
def get_my_events(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    return get_user_events(db, user)

@router.get("/events/{event_id}", response_model=GamificationEventResponse)
def get_event_details_endpoint(event_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    event = get_event_details(db, event_id, user)
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    return event

@router.get("/event-types/{event_type_id}/badges", response_model=List[BadgeResponse])
def get_badges_for_event_endpoint(event_type_id: int, db: Session = Depends(get_db)):
    badges = get_badges_for_event(db, event_type_id)
    if not badges:
        raise HTTPException(status_code=404, detail="No badges found for this event type")
    return badges

@router.get("/progress/{event_type_id}", response_model=UserGamificationResponse)
def get_user_progress_for_event_endpoint(event_type_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    progress = get_user_progress_for_event(db, user, event_type_id)
    if not progress:
        raise HTTPException(status_code=404, detail="Progress not found for this event")
    return progress

# Nuevos endpoints para administración
@router.post("/event-types", response_model=EventTypeResponse)
def create_event_type_endpoint(event_type: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_event_type(db, event_type)

@router.get("/event-types", response_model=List[EventTypeResponse])
def get_event_types_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_event_types(db)

@router.put("/event-types/{event_type_id}", response_model=EventTypeResponse)
def update_event_type_endpoint(event_type_id: int, event_type_update: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_event_type(db, event_type_id, event_type_update)

@router.delete("/event-types/{event_type_id}")
def delete_event_type_endpoint(event_type_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_event_type(db, event_type_id)

@router.post("/badges", response_model=BadgeResponse)
def create_badge_endpoint(badge: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_badge(db, badge)

@router.get("/badges", response_model=List[BadgeResponse])
def get_badges_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_badges(db)

@router.put("/badges/{badge_id}", response_model=BadgeResponse)
def update_badge_endpoint(badge_id: int, badge_update: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_badge(db, badge_id, badge_update)

@router.delete("/badges/{badge_id}")
def delete_badge_endpoint(badge_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_badge(db, badge_id)


@router.post("/event-types", response_model=EventTypeResponse)
def create_event_type_endpoint(event_type: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_event_type(db, event_type)

@router.get("/event-types", response_model=List[EventTypeResponse])
def get_event_types_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_event_types(db)

@router.put("/event-types/{event_type_id}", response_model=EventTypeResponse)
def update_event_type_endpoint(event_type_id: int, event_type_update: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_event_type(db, event_type_id, event_type_update)

@router.delete("/event-types/{event_type_id}")
def delete_event_type_endpoint(event_type_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_event_type(db, event_type_id)

# Endpoints para Badge
@router.post("/badges", response_model=BadgeResponse)
def create_badge_endpoint(badge: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_badge(db, badge)

@router.get("/badges", response_model=List[BadgeResponse])
def get_badges_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_badges(db)

@router.put("/badges/{badge_id}", response_model=BadgeResponse)
def update_badge_endpoint(badge_id: int, badge_update: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_badge(db, badge_id, badge_update)

@router.delete("/badges/{badge_id}")
def delete_badge_endpoint(badge_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_badge(db, badge_id)

# backend/middleware/gamification.py
from fastapi import Depends
from functools import wraps
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.gamification_service import register_event
from schemas.gamification import GamificationEventCreate
from models.gamification import EventType


def track_gamification_event(event_type_name: str):
    def decorator(func):
        @wraps(func)
        async def wrapper(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db), *args, **kwargs):
            event_type = db.query(EventType).filter(EventType.name == event_type_name).first()
            if not event_type:
                raise ValueError(f"Event type '{event_type_name}' not found")

            event = GamificationEventCreate(event_type_id=event_type.id)
            register_event(db, event, user)

            return await func(user=user, db=db, *args, **kwargs)
        return wrapper
    return decorator

# backend/models/gamification.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime
from models.user import User
from models.guests import GuestsSession


# backend/models/gamification.py
class EventType(Base):
    __tablename__ = "event_types"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "api_usage"
    description = Column(String(255), nullable=True)
    points_per_event = Column(Integer, default=0)  # Puntos por ocurrencia del evento

    badges = relationship("Badge", back_populates="event_type")
    gamification_events = relationship("GamificationEvent", back_populates="event_type")
    user_gamification = relationship("UserGamification", back_populates="event_type")

class Badge(Base):
    __tablename__ = "badges"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "Novato", "Becario"
    description = Column(String(255), nullable=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    required_points = Column(Integer, nullable=False)  # Puntos necesarios para el badge
    user_type = Column(String(20), default="both")  # "anonymous", "registered", "both"

    event_type = relationship("EventType", back_populates="badges")
    user_gamification = relationship("UserGamification", back_populates="badge")

class GamificationEvent(Base):
    __tablename__ = "gamification_events"
    
    id = Column(Integer, primary_key=True, index=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36), ForeignKey("sesiones_anonimas.id"), nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    event_type = relationship("EventType", back_populates="gamification_events")
    user = relationship("User", back_populates="gamification_events")
    session = relationship("GuestsSession", back_populates="gamification_events")

class UserGamification(Base):
    __tablename__ = "user_gamification"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36), ForeignKey("sesiones_anonimas.id"), nullable=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    points = Column(Integer, default=0)
    badge_id = Column(Integer, ForeignKey("badges.id"), nullable=True)
    
    event_type = relationship("EventType", back_populates="user_gamification")
    badge = relationship("Badge", back_populates="user_gamification")
    user = relationship("User", back_populates="gamification")
    session = relationship("GuestsSession", back_populates="gamification")

# backend/schemas/gamification.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List

class EventTypeBase(BaseModel):
    name: str
    description: Optional[str] = None
    points_per_event: int = 0

class EventTypeCreate(EventTypeBase):
    pass

class EventTypeResponse(EventTypeBase):
    id: int

    class Config:
        from_attributes = True

class BadgeBase(BaseModel):
    name: str
    description: Optional[str] = None
    event_type_id: int
    required_points: int
    user_type: str = "both"

class BadgeCreate(BadgeBase):
    pass

class BadgeResponse(BadgeBase):
    id: int

    class Config:
        from_attributes = True

class GamificationEventBase(BaseModel):
    event_type_id: int

class GamificationEventCreate(GamificationEventBase):
    pass

class GamificationEventResponse(GamificationEventBase):
    id: int
    user_id: Optional[int]
    session_id: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

class UserGamificationBase(BaseModel):
    points: int
    badge_id: Optional[int]

class UserGamificationResponse(UserGamificationBase):
    event_type_id: int
    user_id: Optional[int]
    session_id: Optional[str]
    event_type: EventTypeResponse
    badge: Optional[BadgeResponse]

    class Config:
        from_attributes = True
        
        
class RankingResponse(BaseModel):
    username: str
    points: int
    badges_count: int
    user_type: str

    class Config:
        from_attributes = True

# backend/services/gamification_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from models.guests import GuestsSession
from models.gamification import GamificationEvent, UserGamification, EventType, Badge
from schemas.gamification import GamificationEventCreate, EventTypeCreate, BadgeCreate, RankingResponse
from dependencies.auth import UserContext
from sqlalchemy import func
from models.gamification import EventType, Badge, GamificationEvent, UserGamification
from schemas.gamification import EventTypeCreate, BadgeCreate
from fastapi import HTTPException
from models.user import User
import logging
from typing import List, Optional
from sqlalchemy.orm import Session
from models.gamification import GamificationEvent, UserGamification, EventType, Badge
from schemas.gamification import GamificationEventCreate
from dependencies.auth import UserContext


# backend/services/gamification_service.py

def register_event(db: Session, event: GamificationEventCreate, user: UserContext) -> GamificationEvent:
    """Registra un evento de gamificación y actualiza los puntos del usuario."""
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None

    db_event = GamificationEvent(
        event_type_id=event.event_type_id,
        user_id=user_id,
        session_id=session_id
    )
    db.add(db_event)
    db.commit()
    db.refresh(db_event)
    update_user_gamification(db, user, event.event_type_id)
    return db_event

def get_user_gamification(db: Session, user: UserContext) -> List[UserGamification]:
    """Obtiene todos los registros de gamificación del usuario."""
    if user.user_type == "registered":
        return db.query(UserGamification).filter(UserGamification.user_id == int(user.user_id)).all()
    return db.query(UserGamification).filter(UserGamification.session_id == user.session_id).all()

def get_user_events(db: Session, user: UserContext) -> List[GamificationEvent]:
    """Obtiene todos los eventos de gamificación del usuario."""
    if user.user_type == "registered":
        return db.query(GamificationEvent).filter(GamificationEvent.user_id == int(user.user_id)).all()
    return db.query(GamificationEvent).filter(GamificationEvent.session_id == user.session_id).all()

def get_event_details(db: Session, event_id: int, user: UserContext) -> Optional[GamificationEvent]:
    """Obtiene los detalles de un evento específico si pertenece al usuario."""
    event = db.query(GamificationEvent).filter(GamificationEvent.id == event_id).first()
    if not event:
        return None
    if (user.user_type == "registered" and event.user_id == int(user.user_id)) or \
       (user.user_type == "anonymous" and event.session_id == user.session_id):
        return event
    return None

def get_badges_for_event(db: Session, event_type_id: int) -> List[Badge]:
    """Obtiene todos los badges asociados a un tipo de evento."""
    return db.query(Badge).filter(Badge.event_type_id == event_type_id).all()

def get_user_progress_for_event(db: Session, user: UserContext, event_type_id: int) -> Optional[UserGamification]:
    """Obtiene el progreso del usuario para un tipo de evento específico."""
    if user.user_type == "registered":
        return db.query(UserGamification).filter(
            UserGamification.user_id == int(user.user_id),
            UserGamification.event_type_id == event_type_id
        ).first()
    return db.query(UserGamification).filter(
        UserGamification.session_id == user.session_id,
        UserGamification.event_type_id == event_type_id
    ).first()



def update_user_gamification(db: Session, user: UserContext, event_type_id: int) -> UserGamification:
    logging.info(f"Actualizando gamificación para user_type={user.user_type}, user_id={user.user_id}, session_id={user.session_id}, event_type_id={event_type_id}")
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None

    gamification = get_user_progress_for_event(db, user, event_type_id)
    if not gamification:
        gamification = UserGamification(
            user_id=user_id,
            session_id=session_id,
            event_type_id=event_type_id,
            points=0
        )
        db.add(gamification)
        logging.info("Creado nuevo registro de UserGamification")

    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise ValueError("Event type not found")

    events_count = db.query(GamificationEvent).filter(
        GamificationEvent.event_type_id == event_type_id,
        (GamificationEvent.user_id == user_id) if user_id else (GamificationEvent.session_id == session_id)
    ).count()
    logging.info(f"Contados {events_count} eventos para event_type_id={event_type_id}")

    gamification.points = events_count * event_type.points_per_event

    badge = db.query(Badge).filter(
        Badge.event_type_id == event_type_id,
        Badge.user_type.in_([user.user_type, "both"]),
        Badge.required_points <= gamification.points
    ).order_by(Badge.required_points.desc()).first()
    logging.info(f"Badge encontrado: {badge.id if badge else 'None'}")

    gamification.badge_id = badge.id if badge else None
    db.commit()
    db.refresh(gamification)
    return gamification
# Funciones para EventType
def create_event_type(db: Session, event_type: EventTypeCreate):
    db_event_type = EventType(**event_type.dict())
    db.add(db_event_type)
    db.commit()
    db.refresh(db_event_type)
    return db_event_type

def get_event_types(db: Session) -> List[EventType]:
    return db.query(EventType).all()

def update_event_type(db: Session, event_type_id: int, event_type_update: EventTypeCreate):
    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type not found")
    for key, value in event_type_update.dict().items():
        setattr(event_type, key, value)
    db.commit()
    db.refresh(event_type)
    return event_type

def delete_event_type(db: Session, event_type_id: int):
    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type not found")
    db.delete(event_type)
    db.commit()
    return {"message": "Event type deleted"}

# Funciones para Badge
def create_badge(db: Session, badge: BadgeCreate):
    db_badge = Badge(**badge.dict())
    db.add(db_badge)
    db.commit()
    db.refresh(db_badge)
    return db_badge

def get_badges(db: Session) -> List[Badge]:
    return db.query(Badge).all()

def update_badge(db: Session, badge_id: int, badge_update: BadgeCreate):
    badge = db.query(Badge).filter(Badge.id == badge_id).first()
    if not badge:
        raise HTTPException(status_code=404, detail="Badge not found")
    for key, value in badge_update.dict().items():
        setattr(badge, key, value)
    db.commit()
    db.refresh(badge)
    return badge

def delete_badge(db: Session, badge_id: int):
    badge = db.query(Badge).filter(Badge.id == badge_id).first()
    if not badge:
        raise HTTPException(status_code=404, detail="Badge not found")
    db.delete(badge)
    db.commit()
    return {"message": "Badge deleted"}

#def calculate_points(api_usages: int) -> int:
#    """Calcula los puntos según el número de usos de la API."""
#    if api_usages >= 30:
#        return 1000
#    elif api_usages >= 20:
#        return 500
#    elif api_usages >= 10:
#        return 100
#    elif api_usages >= 1:
#        return 5
#    return 0



def get_rankings(db: Session) -> List[RankingResponse]:
    # Rankings para usuarios registrados
    registered = db.query(
        User.username,
        func.sum(UserGamification.points).label("total_points"),
        func.count(UserGamification.badge_id).label("badges_count")
    ).join(UserGamification, User.id == UserGamification.user_id
    ).group_by(User.id).all()

    # Rankings para usuarios anónimos
    anonymous = db.query(
        GuestsSession.username,
        func.sum(UserGamification.points).label("total_points"),
        func.count(UserGamification.badge_id).label("badges_count")
    ).join(UserGamification, GuestsSession.id == UserGamification.session_id
    ).group_by(GuestsSession.id).all()

    all_rankings = [
        RankingResponse(
            username=r.username,
            points=r.total_points,
            badges_count=r.badges_count,
            user_type="registered" if r in registered else "anonymous"
        ) for r in registered + anonymous
    ]
    return sorted(all_rankings, key=lambda x: x.points, reverse=True)


def get_event_types(db: Session) -> List[EventType]:
    return db.query(EventType).all()

def update_event_type(db: Session, event_type_id: int, event_type_update: EventTypeCreate):
    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type not found")
    for key, value in event_type_update.dict().items():
        setattr(event_type, key, value)
    db.commit()
    db.refresh(event_type)
    return event_type

def delete_event_type(db: Session, event_type_id: int):
    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type not found")
    db.delete(event_type)
    db.commit()
    return {"message": "Event type deleted"}

def get_badges(db: Session) -> List[Badge]:
    return db.query(Badge).all()

def update_badge(db: Session, badge_id: int, badge_update: BadgeCreate):
    badge = db.query(Badge).filter(Badge.id == badge_id).first()
    if not badge:
        raise HTTPException(status_code=404, detail="Badge not found")
    for key, value in badge_update.dict().items():
        setattr(badge, key, value)
    db.commit()
    db.refresh(badge)
    return badge

def delete_badge(db: Session, badge_id: int):
    badge = db.query(Badge).filter(Badge.id == badge_id).first()
    if not badge:
        raise HTTPException(status_code=404, detail="Badge not found")
    db.delete(badge)
    db.commit()
    return {"message": "Badge deleted"}



2.4 En la pestaña de pagos: Si creo un nuevo proveedor de pago funciona bien, borrarlo tambien, pero si lo edito la pagina
recarga y no me guarda los cambios.

Obtengo este error 

Iniciando fetchAPI para /v1/payment-providers/1 api.ts:47:13
[PUT] /v1/payment-providers/1 - Status: 500 <empty string> api.ts:43:13
XHRPUT
http://127.0.0.1:8000/v1/payment-providers/1
NS_BINDING_ABORTED

aqui tienes los archivos que puedes necesitar

# backend/api/v1/payment_providers.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.payment_provider_service import (
    create_payment_provider, 
    get_payment_providers, 
    update_payment_provider, 
    delete_payment_provider
)
from schemas.payment import PaymentProviderCreate, PaymentProviderResponse
from typing import List

router = APIRouter(tags=["Payment Providers"])

@router.get(
    "/",
    response_model=List[PaymentProviderResponse],
    summary="Obtener proveedores de pago",
    description="Obtiene la lista de proveedores de pago disponibles"
)
def get_providers(
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    # Acceso permitido para usuarios registrados y administradores
    if user.user_type != "registered" and user.rol != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Acceso no autorizado"
        )
    return get_payment_providers(db)

@router.post(
    "/",
    response_model=PaymentProviderResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Crear nuevo proveedor",
    description="Crea un nuevo proveedor de pagos (solo administradores)"
)
def create_provider(
    provider_data: PaymentProviderCreate,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Se requieren privilegios de administrador"
        )
    return create_payment_provider(db, provider_data)

@router.put(
    "/{provider_id}",
    response_model=PaymentProviderResponse,
    summary="Actualizar proveedor",
    description="Actualiza un proveedor de pagos existente (solo administradores)"
)
def update_provider(
    provider_id: int, 
    provider_update: PaymentProviderCreate,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Se requieren privilegios de administrador"
        )
    return update_payment_provider(db, provider_id, provider_update)

@router.delete(
    "/{provider_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Eliminar proveedor",
    description="Elimina un proveedor de pagos (solo administradores)"
)
def delete_provider(
    provider_id: int,
    user: UserContext = Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Se requieren privilegios de administrador"
        )
    delete_payment_provider(db, provider_id)
    return {"detail": "Proveedor eliminado exitosamente"}


# backend/models/payment_provider.py
from sqlalchemy import Column, Integer, String, Boolean
from models.user import Base

class PaymentProvider(Base):
    __tablename__ = "payment_providers"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "Stripe", "Paypal"
    active = Column(Boolean, default=True)  # Si está activo o no

#backend/schemas/payment.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional


class PurchaseRequest(BaseModel):
    credits: int
    payment_amount: float
    payment_method: Optional[str] = "stripe"

class PurchaseResponse(BaseModel):
    transaction_id: int
    credits_added: int
    new_balance: int

class PaymentMethodCreate(BaseModel):
    payment_type: str
    details: str
    is_default: bool = False

class PaymentMethodResponse(BaseModel):
    id: int
    payment_type: str
    details: str
    is_default: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class CreditTransactionResponse(BaseModel):
    id: int
    amount: int
    transaction_type: str
    payment_amount: Optional[float] = None
    payment_method: Optional[str] = None
    payment_status: Optional[str] = None
    timestamp: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class PaymentProviderBase(BaseModel):
    name: str
    active: bool = True

class PaymentProviderCreate(PaymentProviderBase):
    pass

class PaymentProviderResponse(PaymentProviderBase):
    id: int

    class Config:
        from_attributes = True

# backend/services/payment_provider_service.py
from sqlalchemy.orm import Session
from models.payment_provider import PaymentProvider
from schemas.payment import PaymentProviderCreate
from fastapi import HTTPException

def create_payment_provider(db: Session, provider: PaymentProviderCreate):
    existing = db.query(PaymentProvider).filter(PaymentProvider.name == provider.name).first()
    if existing:
        raise HTTPException(status_code=400, detail="Payment provider already exists")
    db_provider = PaymentProvider(**provider.dict())
    db.add(db_provider)
    db.commit()
    db.refresh(db_provider)
    return db_provider

def get_payment_providers(db: Session):
    return db.query(PaymentProvider).all()

def update_payment_provider(db: Session, provider_id: int, provider_update: PaymentProviderCreate):
    provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()
    if not provider:
        raise HTTPException(status_code=404, detail="Payment provider not found")
    for key, value in provider_update.dict().items():
        setattr(provider, key, value)
    db.commit()
    db.refresh(provider)
    return provider

def delete_payment_provider(db: Session, provider_id: int):
    provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()
    if not provider:
        raise HTTPException(status_code=404, detail="Payment provider not found")
    db.delete(provider)
    db.commit()
    return {"message": "Payment provider deleted"}


// frontend/src/lib/payments.ts
export interface PaymentProvider {
    name: string;
    processPayment(amount: number, currency: string, description: string): Promise<PaymentResult>;
  }
  
  export interface PaymentResult {
    success: boolean;
    transactionId?: string;
    error?: string;
  }


Parte 3: Subopcion registry en panel de admin

Vamos a modificar y completar la pagina donde se visualizan los registros de la app.

quiero que hagas lo siguiente:

- Dentro de la pagina de registry, vamos añadir un submenu, debajo de  la navegación principal vamos añadir 
"Vaciar Logs" que vaciara los logs de la pestaña que estemos visualizando

- Añadiremos una pestaña mas: cupones, que mostrará toda la actividad de los cupones

- Cambia el color de los headings de la tabla que muestra los resultados porque aparece en fondo blanco con color muy claro 

Aqui tienes los archivos implicados

# backend/api/v1/api_logs.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
from core.logging import configure_logging
from models.log import APILog
from schemas.api_log import APILogResponse  # Asegúrate de que este esquema existe
from dependencies.auth import get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Logs"])
logger = configure_logging()

@router.get("/", response_model=dict)
def get_api_logs(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(APILog)
    total_items = query.count()
    logs = query.offset(offset).limit(limit).all()
    
    # Convertir los modelos SQLAlchemy a esquemas Pydantic
    logs_data = [APILogResponse.from_orm(log) for log in logs]
    
    logger.info(f"Logs encontrados: {len(logs)} para page={page}, limit={limit}")
    
    return {
        "data": logs_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

# backend/api/v1/credit_transactions.py
# backend/api/v1/credit_transactions.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
from models.credit_transaction import CreditTransaction
from schemas.credit_transaction import CreditTransactionResponse
from dependencies.auth import get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Transactions"])

@router.get("/", response_model=dict)
def get_credit_transactions(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(CreditTransaction)
    total_items = query.count()
    transactions = query.offset(offset).limit(limit).all()
    
    # Convertir los modelos SQLAlchemy a esquemas Pydantic
    transactions_data = [CreditTransactionResponse.from_orm(t) for t in transactions]
    
    return {
        "data": transactions_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

# backend/api/v1/anonymous_sessions.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
from models.guests import GuestsSession
from schemas.anonymous_session import GuestsSessionResponse  # Asegúrate de que este esquema existe
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Sessions"])

@router.get("/", response_model=dict)
def get_anonymous_sessions(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(GuestsSession)
    total_items = query.count()
    sessions = query.offset(offset).limit(limit).all()
    
    # Convertir los modelos SQLAlchemy a esquemas Pydantic
    sessions_data = [GuestsSessionResponse.from_orm(session) for session in sessions]
    
    return {
        "data": sessions_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

@router.get("/credits", response_model=dict)
async def get_anonymous_credits(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.user_type != "anonymous":
        raise HTTPException(status_code=403, detail="Solo para usuarios anónimos")
    session = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Sesión no encontrada")
    return {"credits": session.credits}.

# backend/api/v1/error_logs.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
from core.logging import configure_logging
from models.error_log import ErrorLog
from schemas.error_log import ErrorLogResponse  # Asegúrate de que este esquema existe
from dependencies.auth import get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Errors"])
logger = configure_logging()

@router.get("/", response_model=dict)
def get_error_logs(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(ErrorLog)
    total_items = query.count()
    logs = query.offset(offset).limit(limit).all()
    
    # Convertir los modelos SQLAlchemy a esquemas Pydantic
    logs_data = [ErrorLogResponse.from_orm(log) for log in logs]
    
    logger.info(f"Logs encontrados: {len(logs)} para page={page}, limit={limit}")
    
    return {
        "data": logs_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

# backend/api/v1/anonymous_sessions.py
from pydantic import BaseModel
from datetime import datetime

class GuestsSessionBase(BaseModel):
    id: str
    username: str  # Nuevo campo
    credits: int
    create_at: datetime
    ultima_actividad: datetime | None
    last_ip: str | None

class GuestsSessionResponse(GuestsSessionBase):
    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

# backend/schemas/api_log.py
from pydantic import BaseModel
from datetime import datetime

class APILogBase(BaseModel):
    user_id: int | None
    endpoint: str
    method: str
    status_code: int
    request_data: str | None
    response_data: str | None
    timestamp: datetime

class APILogResponse(APILogBase):
    id: int

    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

#backend/schemas/credit_transaction.py
from pydantic import BaseModel
from datetime import datetime

class CreditTransactionBase(BaseModel):
    user_id: int | None
    session_id: str | None
    amount: int
    transaction_type: str
    payment_amount: float | None
    payment_method: str | None
    payment_status: str
    timestamp: datetime

class CreditTransactionResponse(CreditTransactionBase):
    id: int

    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

# // backend/schemas/error_log.py
from pydantic import BaseModel
from datetime import datetime

class ErrorLogBase(BaseModel):
    user_id: int | None
    session_id: str | None
    error_code: int
    message: str
    details: str | None
    url: str | None
    method: str | None
    ip_address: str | None
    created_at: datetime

class ErrorLogResponse(ErrorLogBase):
    id: int

    class Config:
        from_attributes = True  # Reemplaza orm_mode = True



Por ultimo te paso archivos que debemos tener presente por su importancia

// src/lib/auth/context.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge, Coupon  } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // Añadimos gamificación al contexto
  coupons: Coupon[];
  setCredits: (credits: number) => void; // Añadido
  setCoupons: (coupons: Coupon[]) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  setGamification: (gamification: Gamification) => void; // Añadido
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}



const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(10); // Valor por defecto para anónimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificación
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const [coupons, setCoupons] = useState<Coupon[]>([]);


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<UserInfo>("/info");
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
            localStorage.setItem("anonUsername", data.username!);
          } else {
            setUser(null);
            setCredits(0);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          }
  
          // Procesar datos de gamificación
          const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
          if (gamificationData && Array.isArray(gamificationData)) {
            const totalPoints = gamificationData.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationData.map(g => g.badge).filter(b => b !== null) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }

          // Obtener cupones del usuario
          const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/me");
          setCoupons(couponsRes.data || []);

        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        setCoupons([]);
        localStorage.removeItem("session_id");
        localStorage.removeItem("anonUsername");
      } finally {
        setLoading(false);
      }
    };
  
    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesión
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesión
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operación
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits,gamification, coupons, setCoupons, setGamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// src/lib/api.ts
import axios, { AxiosRequestConfig, AxiosResponse, AxiosError, AxiosInstance } from "axios";
import { HTTPValidationError, FetchResponse, RegisterRequest, TokenResponse, UpdateProfileRequest, User, ValidationError } from "./types";

// Extender AxiosRequestConfig para incluir _retry
interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  _retry?: boolean;
}

// Crear una instancia personalizada de Axios
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Variables para manejar el estado de refresco
let isRefreshing = false;
let failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

// Agregar el interceptor de solicitudes
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("accessToken");
  const sessionId = localStorage.getItem("session_id");
  if (token) {
    config.headers["Authorization"] = `Bearer ${token}`;
  } else if (sessionId) {
    config.headers["X-Session-ID"] = sessionId;
  }
  return config;
});

const logRequest = (method: string, url: string, status: number, data?: unknown) => {
  console.log(`[${method}] ${url} - Status: ${status}`, data ?? "");
};

const fetchAPI = async <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  contentType: string = "application/json"
): Promise<FetchResponse<T>> => {
  console.log(`Iniciando fetchAPI para ${endpoint}`);

  const config: CustomAxiosRequestConfig = {
    ...options,
    url: endpoint, // baseURL ya está configurado en la instancia
    headers: {
      "Content-Type": contentType,
      ...options.headers,
    },
    data: options.data,
  };

  // Convertir datos a formato x-www-form-urlencoded si es necesario
  if (contentType === "application/x-www-form-urlencoded" && config.data) {
    const formData = new URLSearchParams();
    Object.entries(config.data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });
    config.data = formData;
  }

  const normalizeResponse = (
    response: AxiosResponse<T> | undefined,
    error: unknown
  ): FetchResponse<T> => {
    if (response && response.status >= 200 && response.status < 300) {
      return { data: response.data, error: null };
    }

    if (axios.isAxiosError(error)) {
      const errorData = error.response?.data;
      if (errorData && errorData.detail) {
        if (typeof errorData.detail === "string") {
          return { data: null, error: errorData.detail };
        } else if (Array.isArray(errorData.detail)) {
          const messages = errorData.detail
            .map((err: ValidationError) => err.msg)
            .join(", ");
          return { data: null, error: messages };
        }
      }
    }

    return { data: null, error: "Error desconocido" };
  };

  try {
    const response: AxiosResponse<T> = await api(config); // Usar la instancia 'api'
    logRequest(config.method || "GET", config.url!, response.status, response.data);

    if (response.data && (response.data as any).session_id) {
      localStorage.setItem("session_id", (response.data as any).session_id);
    }

    return normalizeResponse(response, null);
  } catch (err: unknown) {
    const axiosError = err as AxiosError;
    logRequest(
      config.method || "GET",
      config.url!,
      axiosError.response?.status || 500,
      axiosError.response?.data
    );

    if (axiosError.response?.status === 401 && !config._retry) {
      const originalRequest: CustomAxiosRequestConfig = config;
      originalRequest._retry = true;

      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");

      if (accessToken && refreshToken) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token) => {
                originalRequest.headers.Authorization = `Bearer ${token}`;
                api(originalRequest)
                  .then(response => resolve(normalizeResponse(response, null)))
                  .catch(error => reject(normalizeResponse(undefined, error)));
              },
              reject: (error) => reject(normalizeResponse(undefined, error)),
            });
          });
        }

        isRefreshing = true;

        try {
          console.log("Intentando refrescar token de acceso");
          const refreshResponse = await api.post<TokenResponse>(
            "/v1/auth/refresh",
            { refresh_token: refreshToken },
            {
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`,
              },
            }
          );

          localStorage.setItem("accessToken", refreshResponse.data.access_token);
          localStorage.setItem("refreshToken", refreshResponse.data.refresh_token);

          originalRequest.headers.Authorization = `Bearer ${refreshResponse.data.access_token}`;
          processQueue(null, refreshResponse.data.access_token);

          const retryResponse = await api(originalRequest);
          return normalizeResponse(retryResponse, null);
        } catch (refreshError) {
          console.error("Error al refrescar token:", refreshError);
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          localStorage.removeItem("session_id");
          processQueue(refreshError, null);
          window.location.href = "/user/auth/#login";
          return normalizeResponse(undefined, {
            message: "Sesión expirada, por favor inicia sesión nuevamente",
          });
        } finally {
          isRefreshing = false;
        }
      } else {
        return normalizeResponse(undefined, { message: "No autorizado" });
      }
    }

    return normalizeResponse(undefined, err);
  }
};

// Funciones específicas de la API
export const getAllUsers = async (
  page: number = 1,
  limit: number = 10
): Promise<FetchResponse<{
  data: User[],
  total_items: number,
  total_pages: number,
  current_page: number
}>> => {
  return fetchAPI(`/v1/users/admin/users?page=${page}&limit=${limit}`, {
    method: "GET"
  });
};

export const getUserById = async (
  userId: number
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "GET"
  });
};

export const updateUser = async (
  userId: number,
  data: UpdateProfileRequest
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "PUT",
    data
  });
};

export const deleteUser = async (
  userId: number
): Promise<FetchResponse<void>> => {
  return fetchAPI<void>(`/v1/users/${userId}`, {
    method: "DELETE"
  });
};

export const createUser = async (
  data: RegisterRequest
): Promise<FetchResponse<TokenResponse>> => {
  return fetchAPI<TokenResponse>("/v1/auth/register", {
    method: "POST",
    data
  });
};

export default fetchAPI;

// src/lib/types.ts
export interface User {
  id: number;
  email: string;
  username: string;
  rol: string;
  activo: boolean;
  subscription: string;
  ciudad?: string;
  website?: string;
  credits: number;
  create_at: string;  // ISO string (e.g., "2023-10-01T12:00:00Z")
  last_ip?: string;
  last_login: string;
  user_type: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}



export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  ciudad?: string;
  website?: string;
}

export interface UpdateProfileRequest {
  email?: string;
  username?: string;
  ciudad?: string;
  website?: string;
}

export interface PurchaseRequest {
  credits: number;
  payment_amount: number;
  payment_method?: string;
}

export interface PurchaseResponse {
  transaction_id: string;
  credits_added: number;
  new_balance: number;
}

export interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
  created_at: string;  // ISO string
  updated_at: string;  // ISO string
}

export interface HTTPValidationError {
  detail: ValidationError[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status?: string;
  timestamp: string; // ISO string
}

export interface Integration {
  id: number;
  name: string;
  webhook_url: string;
  event_type: string;
  active: boolean;
  created_at: string;
  last_triggered: string | null;
}

export interface SiteSetting {
    id: number;
    key: string;
    value: string;
    description?: string;
    tag?: string;
    updated_by?: number;
    updated_at: string; // ISO string
}

export interface FetchResponse<T> {
  data: T | null;
  error: string | HTTPValidationError | null;
  total_pages?: number;
}

// src/lib/types.ts
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string;
  gamification: UserGamificationResponse[]; // Actualizado para reflejar /info
}

export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[];
}

export interface GamificationEventCreate {
  event_type_id: number;
}

export interface GamificationEventResponse {
  id: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  timestamp: string; // ISO string
}

export interface UserGamificationResponse {
  points: number;
  badge_id?: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  event_type: EventType;
  badge?: Badge;
}
export interface RankingResponse {
  username: string;
  points: number;
  badges_count: number;
  user_type: string;
}

export interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}



export interface InfoResponse {
  credits: number;
  gamification: { points: number; badge: Badge | null }[];
}


export interface BadgeWithEventType extends Badge {
  event_type: EventType;
}


// src/lib/types.ts

// Nuevo tipo para cupones
export interface Coupon {
  id: number;
  name: string;
  description?: string;
  unique_identifier: string;
  issued_at: string; // ISO string
  expires_at?: string; // ISO string, opcional
  redeemed_at?: string; // ISO string, opcional
  active: boolean;
  status: "active" | "redeemed" | "expired" | "disabled";
  credits: number;
  user_id?: number; // Opcional, para usuarios registrados
  session_id?: string; // Opcional, para usuarios anónimos
  redeemed_by_user_id?: number; // Quién lo canjeó, si aplica
  redeemed_by_session_id?: string; // Quién lo canjeó (anónimo), si aplica
}

# backend/core/security.py
# Usar OAuth2 con Password Flow para autenticación segur

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from oauthlib.oauth2 import WebApplicationClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jwt import encode, decode, PyJWTError
from os import getenv
from datetime import datetime, timedelta
from typing import Optional
from core.logging import configure_logging
from core.database import get_db
from services.settings_service import get_setting

logger = configure_logging()

# Configuración de OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/v1/auth/token")
google_client = WebApplicationClient(getenv("GOOGLE_CLIENT_ID"))
meta_client = WebApplicationClient(getenv("META_CLIENT_ID"))

# Configuración de hash de contraseñas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_token(user_id: str, user_type: str = "registered"):
    payload = {
        "sub": str(user_id),
        "type": user_type,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, getenv("SECRET_KEY"), algorithm="HS256")

def decode_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, getenv("SECRET_KEY"), algorithms=["HS256"])
        # Validación adicional del payload
        if not payload.get("sub") or not payload.get("type"):
            logger.warning(f"Token inválido: falta sub o type en el payload")
            return None
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token expirado")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Token inválido: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Error inesperado al decodificar token: {str(e)}")
        return None

def create_access_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "token_expiration") or "3600")
        if expiration < 300:  # Mínimo 5 minutos
            expiration = 3600
            logger.warning("Token expiration too low, using default 1h")
    except Exception as e:
        logger.error(f"Error token_expiration: {str(e)}")
        expiration = 3600
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

def create_refresh_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "refresh_token_expiration") or "604800")
        if expiration < 86400:  # Mínimo 1 día
            expiration = 604800
            logger.warning("Refresh token expiration too low, using default 7d")
    except Exception as e:
        logger.error(f"Error refresh_token_expiration: {str(e)}")
        expiration = 604800
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")


def create_refresh_token(data: dict):
    db = next(get_db())
    expiration_str = get_setting(db, "refresh_token_expiration") or "604800"  # Valor por defecto: 7 días
    try:
        expiration = int(str(expiration_str))  # Convertir a cadena primero y luego a entero
    except ValueError:
        logger.error(f"Valor inválido para refresh_token_expiration: {expiration_str}")
        expiration = 604800  # Valor por defecto si falla
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

    
def get_oauth2_redirect_url(provider: str) -> str:
    if provider == "google":
        return google_client.prepare_request_uri(
            "https://accounts.google.com/o/oauth2/v2/auth",
            redirect_uri=getenv("GOOGLE_REDIRECT_URI"),
            scope=["openid", "email", "profile"]
        )
    elif provider == "meta":
        return meta_client.prepare_request_uri(
            "https://www.facebook.com/v13.0/dialog/oauth",
            redirect_uri=getenv("META_REDIRECT_URI"),
            scope=["email"]
        )
    raise ValueError("Proveedor no soportado")

# backend/services/auth_service.py
# Módulo de servicio de autenticación.
from os import getenv
from uuid import uuid4
from sqlalchemy.orm import Session
from models.user import User, subscriptionEnum
from models.token import PasswordResetToken, RevokedToken
from core.security import (
    get_password_hash, verify_password, create_access_token, 
    create_refresh_token, decode_token
)
from core.logging import configure_logging
from core.security import google_client, meta_client

from datetime import datetime, timedelta
from fastapi import HTTPException
import requests
from threading import Lock
from threading import Lock
from datetime import datetime, timedelta
from fastapi import HTTPException
from threading import Lock
import jwt

refresh_lock = Lock()

logger = configure_logging()

def register_user(
    db: Session, 
    email: str, 
    username: str, 
    password: str, 
    ciudad: str = None, 
    website: str = None, 
    subscription: str = "freemium"
):
    try:
        if db.query(User).filter(User.email == email).first():
            logger.warning(f"Intento de registro con email duplicado: {email}")
            raise HTTPException(status_code=400, detail="El email ya está registrado")
        if db.query(User).filter(User.username == username).first():
            logger.warning(f"Intento de registro con username duplicado: {username}")
            raise HTTPException(status_code=400, detail="El username ya está registrado")
        
        hashed_password = get_password_hash(password)
        user = User(
            email=email,
            username=username,
            password_hash=hashed_password,
            ciudad=ciudad,
            website=website,
            subscription=subscriptionEnum(subscription),
            credits=100, 
            renewal=datetime.utcnow(),
            create_at=datetime.utcnow()
        )
        db.add(user)
        db.commit()
        db.refresh(user)
        
        access_token = create_access_token({"sub": str(user.id), "type": "registered"})
        refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
        logger.info(f"Usuario registrado ID {user.id} con subscription {subscription}")
        return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en registro de usuario {email}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al registrar usuario")

def login_user(db: Session, email: str, password: str, ip: str):
    try:
        user = db.query(User).filter(User.email == email).first()
        if not user or not verify_password(password, user.password_hash):
            logger.error(f"Intento de login fallido para email {email} desde IP {ip}")
            raise HTTPException(status_code=401, detail="Credenciales inválidas")
        if not user.activo:
            logger.warning(f"Intento de login con usuario inactivo ID {user.id} desde IP {ip}")
            raise HTTPException(status_code=403, detail="Usuario inactivo")
        
        user.last_ip = ip
        db.commit()
        
        # Añadir log para inspeccionar los datos del usuario
        logger.debug(f"Usuario encontrado: ID={user.id}, email={user.email}, subscription={user.subscription}, type={type(user.subscription)}")
        
        # Generar el token
        access_token = create_access_token({"sub": str(user.id), "type": "registered"})
        refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
        logger.info(f"Login exitoso para usuario ID {user.id} desde IP {ip}")
        return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}
    except Exception as e:
        logger.critical(f"Error inesperado en login para {email} desde IP {ip}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Error al iniciar sesión")





def refresh_access_token(db: Session, refresh_token: str):
    if not refresh_token or len(refresh_token) < 10:
        raise HTTPException(status_code=401, detail="Refresh token inválido")

    with refresh_lock:
        try:
            # 1. Decodificar primero sin verificar revocación
            try:
                payload = jwt.decode(
                    refresh_token,
                    getenv("SECRET_KEY"),
                    algorithms=["HS256"],
                    options={"verify_exp": True}
                )
            except jwt.ExpiredSignatureError:
                logger.warning("Refresh token expirado")
                raise HTTPException(status_code=401, detail="Refresh token expirado")
            except Exception as e:
                logger.warning(f"Error decodificando token: {str(e)}")
                raise HTTPException(status_code=401, detail="Token inválido")

            # 2. Verificar si el token fue revocado DESPUÉS de decodificar
            if db.query(RevokedToken).filter(RevokedToken.token == refresh_token).first():
                logger.warning("Refresh token ya revocado")
                raise HTTPException(status_code=401, detail="Refresh token revocado")

            # 3. Validar claims
            if payload.get("type") != "refresh":
                raise HTTPException(status_code=401, detail="Tipo de token incorrecto")

            user_id = payload.get("sub")
            if not user_id:
                raise HTTPException(status_code=401, detail="Falta sub claim")

            # 4. Verificar usuario
            user = db.query(User).filter(User.id == int(user_id)).first()
            if not user or not user.activo:
                raise HTTPException(status_code=403, detail="Usuario inválido")

            # 5. Revocar el token actual
            db.add(RevokedToken(token=refresh_token, user_id=user.id))
            
            # 6. Crear nuevos tokens
            new_access_token = create_access_token({"sub": str(user.id), "type": "registered"})
            new_refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
            
            db.commit()  # Hacer commit después de crear los nuevos tokens
            
            return {
                "access_token": new_access_token,
                "refresh_token": new_refresh_token,
                "token_type": "bearer"
            }

        except HTTPException:
            db.rollback()
            raise
        except Exception as e:
            db.rollback()
            logger.error(f"Error crítico: {str(e)}")
            raise HTTPException(status_code=500, detail="Error interno")

        
def logout_user(db: Session, token: str): #_estimate ?
    payload = decode_token(token)
    if not payload:
        raise HTTPException(status_code=401, detail="Token inválido")
    
    revoked_token = RevokedToken(token=token)
    db.add(revoked_token)
    db.commit()
    return {"message": "Sesión cerrada"}

def request_password_reset(db: Session, email: str):
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise HTTPException(status_code=404, detail="Email no encontrado")
    
    token = str(uuid4())
    reset_token = PasswordResetToken(user_id=user.id, token=token)
    db.add(reset_token)
    db.commit()
    
    logger.info(f"Token de reseteo generado para usuario ID {user.id}: {token}")
    return {"message": "Solicitud de recuperación enviada", "token": token}

def confirm_password_reset(db: Session, token: str, new_password: str):
    reset_token = db.query(PasswordResetToken).filter(PasswordResetToken.token == token).first()
    if not reset_token:
        raise HTTPException(status_code=400, detail="Token inválido")
    if reset_token.expires_at < datetime.utcnow():
        raise HTTPException(status_code=400, detail="Token expirado")
    
    user = db.query(User).filter(User.id == reset_token.user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    user.password_hash = get_password_hash(new_password)
    db.delete(reset_token)
    db.commit()
    return {"message": "Contraseña actualizada con éxito"}

def change_user_password(db: Session, user_id: int, current_password: str, new_password: str):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    if not verify_password(current_password, user.password_hash):
        raise HTTPException(status_code=400, detail="Contraseña actual incorrecta")
    
    user.password_hash = get_password_hash(new_password)
    db.commit()
    return {"message": "Contraseña actualizada con éxito"}

def login_with_provider(db: Session, provider: str, code: str, ip: str):
    if provider == "google":
        token_url = "https://oauth2.googleapis.com/token"
        client_id = getenv("GOOGLE_CLIENT_ID")
        client_secret = getenv("GOOGLE_CLIENT_SECRET")
        redirect_uri = getenv("GOOGLE_REDIRECT_URI")
    elif provider == "meta":
        token_url = "https://graph.facebook.com/v13.0/oauth/access_token"
        client_id = getenv("META_CLIENT_ID")
        client_secret = getenv("META_CLIENT_SECRET")
        redirect_uri = getenv("META_REDIRECT_URI")
    else:
        raise HTTPException(status_code=400, detail="Proveedor no soportado")

    token_data = {
        "code": code,
        "client_id": client_id,
        "client_secret": client_secret,
        "redirect_uri": redirect_uri,
        "grant_type": "authorization_code"
    }
    response = requests.post(token_url, data=token_data)
    if response.status_code != 200:
        logger.error(f"Error al obtener token de {provider}: {response.text}")
        raise HTTPException(status_code=400, detail="Error al autenticar con el proveedor")

    token_info = response.json()
    user_info_url = "https://www.googleapis.com/oauth2/v3/userinfo" if provider == "google" else "https://graph.facebook.com/me?fields=id,email"
    user_response = requests.get(user_info_url, headers={"Authorization": f"Bearer {token_info['access_token']}"})
    user_data = user_response.json()

    email = user_data.get("email")
    provider_id = user_data.get("id") or user_data.get("sub")
    user = db.query(User).filter(User.email == email).first()

    if not user:
        user = User(
            email=email,
            username=email.split("@")[0],
            auth_provider=provider,
            provider_id=provider_id,
            credits= 200, # Comprobar si es cuando hace login o cuando se registra por primera vez con otro proveedor
            create_at=datetime.utcnow()
        )
        db.add(user)
        db.commit()
        db.refresh(user)
    else:
        if user.auth_provider != provider or user.provider_id != provider_id:
            logger.warning(f"Conflicto de proveedor para email {email}")
            raise HTTPException(status_code=400, detail="Email ya registrado con otro proveedor")

    user.last_ip = ip
    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token({"sub": str(user.id), "type": "registered"})
    refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
    logger.info(f"Login con {provider} exitoso para usuario ID {user.id}")
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}

Por ultimo, parte 4: inicialización de la base de datos y datos de prueba.

Este tema lo llevo hecho un desastre, porque tengo varios frentes abiertos con ello y ninguno terminado, a ver si pones tu orden.

Por un lado tengo este script que dejo de usarse porque era muy tedioso actualizarlo y actualmente esta en deshuso

#backend/initial_data.py
import uuid
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from core.database import SessionLocal, Base, engine
from models.site_settings import SiteSettings
from models.user import User, subscriptionEnum
from models.allowed_origin import AllowedOrigin
from models.credit_transaction import CreditTransaction
from models.error_log import ErrorLog
from models.integration import Integration
from models.log import APILog
from models.payment_method import PaymentMethod
from models.gamification import EventType, Badge, GamificationEvent, UserGamification
from models.guests import GuestsSession
from models.token import RevokedToken, PasswordResetToken
from core.security import hash_password
import json

def init_db():
    """Crea todas las tablas en la base de datos"""
    Base.metadata.create_all(bind=engine)

def init_settings_and_users():
    db = SessionLocal()
    try:
        # Configuraciones iniciales con tags
        settings_data = [
            {"key": "token_expiration", "value": 60, "description": "Tiempo de vida del access token (segundos)", "tag": "auth"},
            {"key": "refresh_token_expiration", "value": 604800, "description": "Tiempo de vida del refresh token (7 días)", "tag": "auth"},
            {"key": "max_login_attempts", "value": 5, "description": "Máximo de intentos de login antes de bloqueo", "tag": "auth"},
            {"key": "rate_limit_auth", "value": {"times": 20, "seconds": 60}, "description": "Límite de peticiones para auth", "tag": "rate_limit"},
            {"key": "rate_limit_api", "value": {"times": 100, "seconds": 60}, "description": "Límite de peticiones para API", "tag": "rate_limit"},
            {"key": "rate_limit_admin", "value": {"times": 50, "seconds": 60}, "description": "Límite de peticiones para admin", "tag": "rate_limit"},
            {"key": "cache_ttl", "value": 300, "description": "Tiempo de vida del caché en Redis (segundos)", "tag": "cache"},
            {"key": "cache_enabled", "value": True, "description": "Habilitar/deshabilitar el caché", "tag": "cache"},
            {"key": "cache_max_size", "value": 10000, "description": "Tamaño máximo del caché en entradas", "tag": "cache"},
            {"key": "allowed_origins", "value": ["http://localhost:3000", "https://neptuno.app"], "description": "Orígenes permitidos para CORS", "tag": "cors"},
            {"key": "cors_enabled", "value": True, "description": "Habilitar/deshabilitar CORS", "tag": "cors"},
            {"key": "celery_workers", "value": 4, "description": "Número de workers de Celery", "tag": "celery"},
            {"key": "celery_task_timeout", "value": 300, "description": "Tiempo máximo de ejecución de tareas Celery (segundos)", "tag": "celery"},
            {"key": "celery_max_retries", "value": 3, "description": "Máximo de reintentos para tareas Celery", "tag": "celery"},
            {"key": "db_pool_size", "value": 20, "description": "Tamaño del pool de conexiones a la DB", "tag": "database"},
            {"key": "db_max_overflow", "value": 10, "description": "Conexiones adicionales permitidas en el pool", "tag": "database"},
            {"key": "db_pool_timeout", "value": 30, "description": "Tiempo de espera para una conexión del pool (segundos)", "tag": "database"},
            {"key": "freemium_credits", "value": 100, "description": "Créditos iniciales para suscripción freemium", "tag": "credits"},
            {"key": "premium_credits", "value": 1000, "description": "Créditos iniciales para suscripción premium", "tag": "credits"},
            {"key": "corporate_credits", "value": 5000, "description": "Créditos iniciales para suscripción corporativa", "tag": "credits"},
            {"key": "credit_reset_interval", "value": 30, "description": "Intervalo de reinicio de créditos (días)", "tag": "credits"},
            {"key": "log_level", "value": "INFO", "description": "Nivel de logging", "tag": "logging"},
            {"key": "log_retention_days", "value": 90, "description": "Días de retención de logs", "tag": "logging"},
            {"key": "maintenance_mode", "value": False, "description": "Activar/desactivar modo mantenimiento", "tag": "system"},
            {"key": "api_version", "value": "1.0.0", "description": "Versión actual de la API", "tag": "system"},
        ]

        for setting in settings_data:
            if not db.query(SiteSettings).filter(SiteSettings.key == setting["key"]).first():
                db.add(SiteSettings(
                    key=setting["key"],
                    value=json.dumps(setting["value"]),
                    description=setting["description"],
                    tag=setting["tag"]
                ))

        # Usuarios iniciales
        users_data = [
            {
                "email": "freemium@example.com",
                "username": "freemium_user",
                "password_hash": hash_password("password123"),
                "subscription": subscriptionEnum.FREEMIUM,
                "credits": 100,
                "rol": "user",
                "create_at": datetime.utcnow(),
                "activo": True
            },
            {
                "email": "premium@example.com",
                "username": "premium_user",
                "password_hash": hash_password("password123"),
                "subscription": subscriptionEnum.PREMIUM,
                "credits": 1000,
                "rol": "user",
                "create_at": datetime.utcnow(),
                "activo": True
            },
            {
                "email": "corporate@example.com",
                "username": "corporate_user",
                "password_hash": hash_password("password123"),
                "subscription": subscriptionEnum.CORPORATE,
                "credits": 5000,
                "rol": "user",
                "create_at": datetime.utcnow(),
                "activo": True
            },
            {
                "email": "admin@example.com",
                "username": "admin_user",
                "password_hash": hash_password("admin123"),
                "subscription": subscriptionEnum.PREMIUM,
                "credits": 1000,
                "rol": "admin",
                "create_at": datetime.utcnow(),
                "activo": True
            },
            {
                "email": "testuser1@example.com",
                "username": "test_user1",
                "password_hash": hash_password("test123"),
                "subscription": subscriptionEnum.FREEMIUM,
                "credits": 100,
                "rol": "user",
                "create_at": datetime.utcnow(),
                "activo": True
            },
            {
                "email": "testadmin@example.com",
                "username": "test_admin",
                "password_hash": hash_password("admin456"),
                "subscription": subscriptionEnum.CORPORATE,
                "credits": 5000,
                "rol": "admin",
                "create_at": datetime.utcnow(),
                "activo": True
            }
        ]

        users = []
        for user_data in users_data:
            if not db.query(User).filter(User.email == user_data["email"]).first():
                user = User(**user_data)
                db.add(user)
                users.append(user)

        db.commit()  # Necesario para obtener los IDs de los usuarios

        # Orígenes permitidos
        origins = [
            "http://localhost:3000",
            "https://neptuno.app",
            "https://api.example.com",
            "https://app.example.com"
        ]
        
        for origin in origins:
            if not db.query(AllowedOrigin).filter(AllowedOrigin.origin == origin).first():
                db.add(AllowedOrigin(origin=origin))

        # Sesiones anónimas
        anonymous_sessions = []
        for i in range(3):
            session_id = str(uuid.uuid4())
            session = GuestsSession(
                id=session_id,
                username=f"anon_user_{i+1}",
                credits=100 - (i * 10),
                create_at=datetime.utcnow() - timedelta(days=i),
                ultima_actividad=datetime.utcnow() - timedelta(hours=i),
                last_ip=f"192.168.1.{i+1}"
            )
            db.add(session)
            anonymous_sessions.append(session)

        # Transacciones de créditos
        transactions = [
            # Transacciones para usuarios registrados
            {
                "user_id": users[0].id,
                "user_type": "registered",
                "amount": -10,
                "transaction_type": "api_call",
                "description": "Llamada a API de procesamiento"
            },
            {
                "user_id": users[1].id,
                "user_type": "registered",
                "amount": 500,
                "transaction_type": "purchase",
                "description": "Compra de créditos",
                "payment_amount": 9.99,
                "payment_method": "credit_card",
                "payment_status": "completed"
            },
            # Transacciones para sesiones anónimas
            {
                "session_id": anonymous_sessions[0].id,
                "user_type": "anonymous",
                "amount": -5,
                "transaction_type": "api_call",
                "description": "Llamada a API demo"
            },
            {
                "session_id": anonymous_sessions[1].id,
                "user_type": "anonymous",
                "amount": -15,
                "transaction_type": "api_call",
                "description": "Procesamiento de datos"
            }
        ]

        for transaction in transactions:
            db.add(CreditTransaction(**transaction))

        # Logs de errores
        error_logs = [
            {
                "user_id": users[0].id,
                "user_type": "registered",
                "error_code": 400,
                "message": "Invalid request parameters",
                "details": "Missing required field 'email'",
                "url": "/api/v1/users",
                "method": "POST",
                "ip_address": "192.168.1.100"
            },
            {
                "session_id": anonymous_sessions[0].id,
                "user_type": "anonymous",
                "error_code": 429,
                "message": "Rate limit exceeded",
                "details": "Too many requests from this IP",
                "url": "/api/v1/process",
                "method": "POST",
                "ip_address": "192.168.1.101"
            },
            {
                "user_id": users[2].id,
                "user_type": "registered",
                "error_code": 500,
                "message": "Internal server error",
                "details": "Database connection timeout",
                "url": "/api/v1/credits",
                "method": "GET",
                "ip_address": "192.168.1.102"
            }
        ]

        for error in error_logs:
            db.add(ErrorLog(**error))

        # Integraciones
        integrations = [
            {
                "user_id": users[1].id,
                "name": "slack",
                "webhook_url": "https://hooks.slack.com/services/TXXXXX/BXXXXX/XXXXX",
                "event_type": "credit_usage",
                "active": True,
                "last_triggered": datetime.utcnow() - timedelta(hours=2)
            },
            {
                "user_id": users[3].id,
                "name": "zapier",
                "webhook_url": "https://hooks.zapier.com/hooks/catch/XXXXX/XXXXX",
                "event_type": "user_login",
                "active": True
            },
            {
                "user_id": users[2].id,
                "name": "crm_custom",
                "webhook_url": "https://api.crm.com/webhook/XXXXX",
                "event_type": "payment_added",
                "active": False
            }
        ]

        for integration in integrations:
            db.add(Integration(**integration))

        # Logs de API
        api_logs = [
            {
                "user_id": users[0].id,
                "endpoint": "/api/v1/auth/login",
                "method": "POST",
                "status_code": 200,
                "request_data": json.dumps({"email": "user@example.com", "password": "****"}),
                "response_data": json.dumps({"token": "xxxx.yyyy.zzzz"})
            },
            {
                "endpoint": "/api/v1/process",
                "method": "POST",
                "status_code": 201,
                "request_data": json.dumps({"data": "sample data"}),
                "response_data": json.dumps({"result": "processed", "credits_used": 5})
            },
            {
                "user_id": users[3].id,
                "endpoint": "/api/v1/admin/users",
                "method": "GET",
                "status_code": 200,
                "response_data": json.dumps({"count": 42, "users": []})
            }
        ]

        for log in api_logs:
            db.add(APILog(**log))

        # Métodos de pago
        payment_methods = [
            {
                "user_id": users[1].id,
                "payment_type": "credit_card",
                "details": "VISA ending in 4242",
                "is_default": True
            },
            {
                "user_id": users[1].id,
                "payment_type": "paypal",
                "details": "user@example.com",
                "is_default": False
            },
            {
                "user_id": users[2].id,
                "payment_type": "bank_transfer",
                "details": "IBAN: ESXX XXXX XXXX XXXX XXXX",
                "is_default": True
            }
        ]

        for method in payment_methods:
            db.add(PaymentMethod(**method))

        # Tokens revocados
        revoked_tokens = [
            {"token": "expired.token.xxxx", "revoked_at": datetime.utcnow() - timedelta(days=30), "user_id": users[0].id},
            {"token": "compromised.token.yyyy", "revoked_at": datetime.utcnow() - timedelta(hours=2), "user_id": users[1].id}
        ]

        for token in revoked_tokens:
            db.add(RevokedToken(**token))

        # Tokens de reseteo de contraseña
        reset_tokens = [
            {
                "user_id": users[0].id,
                "token": "reset_token_123",
                "expires_at": datetime.utcnow() + timedelta(hours=1)
            },
            {
                "user_id": users[3].id,
                "token": "reset_token_456",
                "expires_at": datetime.utcnow() + timedelta(hours=1)
            }
        ]

        for token in reset_tokens:
            db.add(PasswordResetToken(**token))


        # Inicializar eventos de gamificación
        event_types = [
            {"name": "api_usage", "description": "Uso de la API", "points_per_event": 10},
            {"name": "login", "description": "Inicio de sesión exitoso", "points_per_event": 5},
            {"name": "purchase", "description": "Compra de créditos", "points_per_event": 50},
        ]

        event_type_objects = []
        for event in event_types:
            if not db.query(EventType).filter(EventType.name == event["name"]).first():
                event_type = EventType(**event)
                db.add(event_type)
                event_type_objects.append(event_type)

        db.commit()

        # Inicializar insignias (badges)
        badges = [
            {"name": "Novato", "description": "Primer uso de la API", "event_type_id": event_type_objects[0].id, "required_points": 10, "user_type": "both"},
            {"name": "Experto", "description": "Más de 100 usos de la API", "event_type_id": event_type_objects[0].id, "required_points": 100, "user_type": "both"},
            {"name": "Comprador", "description": "Primera compra de créditos", "event_type_id": event_type_objects[2].id, "required_points": 50, "user_type": "registered"},
        ]

        for badge in badges:
            if not db.query(Badge).filter(Badge.name == badge["name"]).first():
                db.add(Badge(**badge))

        db.commit()

        # Agregar eventos de gamificación
        gamification_events = [
            {"event_type_id": event_type_objects[0].id, "user_id": users[0].id, "timestamp": datetime.utcnow()},
            {"event_type_id": event_type_objects[1].id, "user_id": users[1].id, "timestamp": datetime.utcnow()},
            {"event_type_id": event_type_objects[2].id, "user_id": users[1].id, "timestamp": datetime.utcnow()},
        ]

        for event in gamification_events:
            db.add(GamificationEvent(**event))

        # Asignar puntos a usuarios
        user_gamification_data = [
            {"user_id": users[0].id, "event_type_id": event_type_objects[0].id, "points": 10, "badge_id": None},
            {"user_id": users[1].id, "event_type_id": event_type_objects[1].id, "points": 5, "badge_id": None},
        ]

        for ug in user_gamification_data:
            db.add(UserGamification(**ug))

        db.commit()
        print("✅ Base de datos inicializada con datos de ejemplo en todas las tablas.")
    except Exception as e:
        db.rollback()
        print(f"❌ Error al cargar datos iniciales: {str(e)}")
        raise
    finally:
        db.close()

if __name__ == "__main__":
    print("Creando tablas en la base de datos...")
    init_db()
    print("Cargando datos iniciales...")
    init_settings_and_users()


Por otro lado tengo un guion en sql para volcar datos de prueba que también se ha quedado desactualizado


-- Script universal para SQLite, MySQL/MariaDB y PostgreSQL

-- psql -U tu_usuario -h localhost -d neptuno_db -f ruta/al/script.sql
-- sqlite3 dev.db < create_db.sql
-- mysql -u tu_usuario -p neptuno_db < ruta/al/script.sql

-- Script adaptado exclusivamente para SQLite3

-- Tabla de usuarios
CREATE TABLE IF NOT EXISTS usuarios (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT NOT NULL UNIQUE,
    username TEXT NOT NULL UNIQUE,
    password_hash TEXT,
    auth_provider TEXT,
    provider_id TEXT,
    rol TEXT DEFAULT 'user',
    activo INTEGER DEFAULT 1,
    subscription TEXT CHECK(subscription IN ('freemium', 'premium', 'corporate')) DEFAULT 'freemium',
    ciudad TEXT,
    website TEXT,
    credits INTEGER DEFAULT 100,
    create_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    renewal DATETIME,
    last_ip TEXT,
    last_login DATETIME,
    token_valid_until DATETIME
);

-- Tabla de sesiones anónimas
CREATE TABLE IF NOT EXISTS sesiones_anonimas (
    id TEXT PRIMARY KEY,
    username TEXT NOT NULL UNIQUE,
    credits INTEGER DEFAULT 100,
    create_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    ultima_actividad DATETIME,
    last_ip TEXT
);

-- Tabla de configuraciones del sitio
CREATE TABLE IF NOT EXISTS site_settings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    key TEXT NOT NULL UNIQUE,
    value TEXT NOT NULL,
    description TEXT,
    tag TEXT,
    updated_by INTEGER,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Tabla de tokens revocados
CREATE TABLE IF NOT EXISTS revoked_tokens (
    token TEXT PRIMARY KEY,
    revoked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    user_id INTEGER
);

-- Tabla de tokens de reseteo de contraseña
CREATE TABLE IF NOT EXISTS password_reset_tokens (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    token TEXT NOT NULL UNIQUE,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME,
    FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- Tabla de transacciones de créditos
CREATE TABLE IF NOT EXISTS credit_transactions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    session_id TEXT,
    user_type TEXT NOT NULL,
    amount INTEGER NOT NULL,
    transaction_type TEXT NOT NULL,
    description TEXT,
    payment_amount REAL,
    payment_method TEXT,
    payment_status TEXT DEFAULT 'pending',
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES usuarios(id),
    FOREIGN KEY (session_id) REFERENCES sesiones_anonimas(id),
    CHECK (
        (user_id IS NOT NULL AND session_id IS NULL AND user_type = 'registered') OR 
        (user_id IS NULL AND session_id IS NOT NULL AND user_type = 'anonymous')
    )
);

-- Tabla de logs de errores
CREATE TABLE IF NOT EXISTS error_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    session_id TEXT,
    user_type TEXT NOT NULL DEFAULT 'anonymous',
    error_code INTEGER NOT NULL,
    message TEXT NOT NULL,
    details TEXT,
    url TEXT,
    method TEXT,
    ip_address TEXT,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES usuarios(id),
    FOREIGN KEY (session_id) REFERENCES sesiones_anonimas(id)
);

-- Tabla de integraciones
CREATE TABLE IF NOT EXISTS integrations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    webhook_url TEXT NOT NULL,
    event_type TEXT NOT NULL,
    active INTEGER DEFAULT 1,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    last_triggered DATETIME,
    FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- Tabla de logs de API
CREATE TABLE IF NOT EXISTS api_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    endpoint TEXT NOT NULL,
    method TEXT NOT NULL,
    status_code INTEGER NOT NULL,
    request_data TEXT,
    response_data TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- Tabla de métodos de pago
CREATE TABLE IF NOT EXISTS payment_methods (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER NOT NULL,
    payment_type TEXT NOT NULL,
    details TEXT NOT NULL,
    is_default INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES usuarios(id)
);

-- Tabla de orígenes permitidos
CREATE TABLE IF NOT EXISTS allowed_origins (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    origin TEXT NOT NULL UNIQUE
);

-- Tabla de tipos de eventos (adaptada para SQLite)
CREATE TABLE IF NOT EXISTS event_types (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    points_per_event INTEGER DEFAULT 0
);

-- Tabla de badges
CREATE TABLE IF NOT EXISTS badges (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    event_type_id INTEGER NOT NULL,
    required_points INTEGER NOT NULL,
    user_type TEXT DEFAULT 'both',
    FOREIGN KEY (event_type_id) REFERENCES event_types(id)
);

-- Tabla de eventos de gamificación
CREATE TABLE IF NOT EXISTS gamification_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_type_id INTEGER NOT NULL,
    user_id INTEGER,
    session_id TEXT,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (event_type_id) REFERENCES event_types(id),
    FOREIGN KEY (user_id) REFERENCES usuarios(id),
    FOREIGN KEY (session_id) REFERENCES sesiones_anonimas(id)
);

-- Tabla de gamificación del usuario
CREATE TABLE IF NOT EXISTS user_gamification (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id INTEGER,
    session_id TEXT,
    event_type_id INTEGER NOT NULL,
    points INTEGER DEFAULT 0,
    badge_id INTEGER,
    FOREIGN KEY (user_id) REFERENCES usuarios(id),
    FOREIGN KEY (session_id) REFERENCES sesiones_anonimas(id),
    FOREIGN KEY (event_type_id) REFERENCES event_types(id),
    FOREIGN KEY (badge_id) REFERENCES badges(id)
);

---------------------------------------------------------------------
-- Insertar datos iniciales
---------------------------------------------------------------------

-- Configuraciones iniciales con tags
INSERT OR IGNORE INTO site_settings (key, value, description, tag) VALUES
('token_expiration', '60', 'Tiempo de vida del access token (segundos)', 'auth'),
('refresh_token_expiration', '604800', 'Tiempo de vida del refresh token (7 días)', 'auth'),
('max_login_attempts', '5', 'Máximo de intentos de login antes de bloqueo', 'auth'),
('rate_limit_auth', '{"times": 20, "seconds": 60}', 'Límite de peticiones para auth', 'rate_limit'),
('rate_limit_api', '{"times": 100, "seconds": 60}', 'Límite de peticiones para API', 'rate_limit'),
('rate_limit_admin', '{"times": 50, "seconds": 60}', 'Límite de peticiones para admin', 'rate_limit'),
('cache_ttl', '300', 'Tiempo de vida del caché en Redis (segundos)', 'cache'),
('cache_enabled', 'true', 'Habilitar/deshabilitar el caché', 'cache'),
('cache_max_size', '10000', 'Tamaño máximo del caché en entradas', 'cache'),
('allowed_origins', '["http://localhost:3000", "https://neptuno.app"]', 'Orígenes permitidos para CORS', 'cors'),
('cors_enabled', 'true', 'Habilitar/deshabilitar CORS', 'cors'),
('celery_workers', '4', 'Número de workers de Celery', 'celery'),
('celery_task_timeout', '300', 'Tiempo máximo de ejecución de tareas Celery (segundos)', 'celery'),
('celery_max_retries', '3', 'Máximo de reintentos para tareas Celery', 'celery'),
('db_pool_size', '20', 'Tamaño del pool de conexiones a la DB', 'database'),
('db_max_overflow', '10', 'Conexiones adicionales permitidas en el pool', 'database'),
('db_pool_timeout', '30', 'Tiempo de espera para una conexión del pool (segundos)', 'database'),
('freemium_credits', '100', 'Créditos iniciales para suscripción freemium', 'credits'),
('premium_credits', '1000', 'Créditos iniciales para suscripción premium', 'credits'),
('corporate_credits', '5000', 'Créditos iniciales para suscripción corporativa', 'credits'),
('credit_reset_interval', '30', 'Intervalo de reinicio de créditos (días)', 'credits'),
('log_level', '"INFO"', 'Nivel de logging', 'logging'),
('log_retention_days', '90', 'Días de retención de logs', 'logging'),
('maintenance_mode', 'false', 'Activar/desactivar modo mantenimiento', 'system'),
('api_version', '"1.0.0"', 'Versión actual de la API', 'system');

INSERT OR IGNORE INTO  site_settings (key, value, description, tag) VALUES
('enable_payment_methods', 'true', 'Activar o desactivar medios de pago', 'Funcionalidades'),
('enable_gamification', 'true', 'Activar o desactivar gamificación', 'Funcionalidades');



-- Usuarios iniciales
INSERT OR IGNORE INTO usuarios (email, username, password_hash, subscription, credits, rol, create_at, activo) VALUES
('freemium@example.com', 'freemium_user', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'FREEMIUM', 100, 'user', datetime('now'), 1),
('premium@example.com', 'premium_user', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'PREMIUM', 1000, 'user', datetime('now'), 1),
('corporate@example.com', 'corporate_user', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'CORPORATE', 5000, 'user', datetime('now'), 1),
('admin@example.com', 'admin_user', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'PREMIUM', 1000, 'admin', datetime('now'), 1),
('testuser1@example.com', 'test_user1', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'FREEMIUM', 100, 'user', datetime('now'), 1),
('testadmin@example.com', 'test_admin', '$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW', 'CORPORATE', 5000, 'admin', datetime('now'), 1);

-- Orígenes permitidos
INSERT OR IGNORE INTO allowed_origins (origin) VALUES
('http://localhost:3000'),
('https://neptuno.app'),
('https://api.example.com'),

-- Sesiones anónimas
INSERT OR IGNORE INTO sesiones_anonimas (id, username, credits, create_at, ultima_actividad, last_ip) VALUES
(hex(randomblob(16)), 'anon_user_1', 100, datetime('now'), datetime('now'), '192.168.1.1'),
(hex(randomblob(16)), 'anon_user_2', 90, datetime('now', '-1 day'), datetime('now', '-1 hour'), '192.168.1.2'),
(hex(randomblob(16)), 'anon_user_3', 80, datetime('now', '-2 days'), datetime('now', '-2 hours'), '192.168.1.3');

-- Transacciones de créditos (usuarios registrados)
INSERT OR IGNORE INTO credit_transactions (user_id, user_type, amount, transaction_type, description, timestamp) VALUES
((SELECT id FROM usuarios WHERE email = 'freemium@example.com'), 'registered', -10, 'api_call', 'Llamada a API de procesamiento', datetime('now')),
((SELECT id FROM usuarios WHERE email = 'premium@example.com'), 'registered', 500, 'purchase', 'Compra de créditos', datetime('now'));

-- Transacciones de créditos (sesiones anónimas)
INSERT OR IGNORE INTO credit_transactions (session_id, user_type, amount, transaction_type, description, timestamp) VALUES
((SELECT id FROM sesiones_anonimas WHERE username = 'anon_user_1'), 'anonymous', -5, 'api_call', 'Llamada a API demo', datetime('now')),
((SELECT id FROM sesiones_anonimas WHERE username = 'anon_user_2'), 'anonymous', -15, 'api_call', 'Procesamiento de datos', datetime('now'));

-- Logs de errores
INSERT OR IGNORE INTO error_logs (user_id, user_type, error_code, message, details, url, method, ip_address, created_at) VALUES
((SELECT id FROM usuarios WHERE email = 'freemium@example.com'), 'registered', 400, 'Invalid request parameters', 'Missing required field ''email''', '/api/v1/users', 'POST', '192.168.1.100', datetime('now')),
((SELECT id FROM sesiones_anonimas WHERE username = 'anon_user_1'), 'anonymous', 429, 'Rate limit exceeded', 'Too many requests from this IP', '/api/v1/process', 'POST', '192.168.1.101', datetime('now')),
((SELECT id FROM usuarios WHERE email = 'corporate@example.com'), 'registered', 500, 'Internal server error', 'Database connection timeout', '/api/v1/credits', 'GET', '192.168.1.102', datetime('now'));

-- Integraciones
INSERT OR IGNORE INTO integrations (user_id, name, webhook_url, event_type, active, created_at, last_triggered) VALUES
((SELECT id FROM usuarios WHERE email = 'premium@example.com'), 'slack', 'https://hooks.slack.com/services/TXXXXX/BXXXXX/XXXXX', 'credit_usage', 1, datetime('now'), datetime('now', '-2 hours')),
((SELECT id FROM usuarios WHERE email = 'admin@example.com'), 'zapier', 'https://hooks.zapier.com/hooks/catch/XXXXX/XXXXX', 'user_login', 1, datetime('now'), NULL),
((SELECT id FROM usuarios WHERE email = 'corporate@example.com'), 'crm_custom', 'https://api.crm.com/webhook/XXXXX', 'payment_added', 0, datetime('now'), NULL);

-- Logs de API
INSERT OR IGNORE INTO api_logs (user_id, endpoint, method, status_code, request_data, response_data, timestamp) VALUES
((SELECT id FROM usuarios WHERE email = 'freemium@example.com'), '/api/v1/auth/login', 'POST', 200, '{"email": "user@example.com", "password": "****"}', '{"token": "xxxx.yyyy.zzzz"}', datetime('now')),
(NULL, '/api/v1/process', 'POST', 201, '{"data": "sample data"}', '{"result": "processed", "credits_used": 5}', datetime('now')),
((SELECT id FROM usuarios WHERE email = 'admin@example.com'), '/api/v1/admin/users', 'GET', 200, NULL, '{"count": 42, "users": []}', datetime('now'));

-- Métodos de pago
INSERT OR IGNORE INTO payment_methods (user_id, payment_type, details, is_default, created_at, updated_at) VALUES
((SELECT id FROM usuarios WHERE email = 'premium@example.com'), 'credit_card', 'VISA ending in 4242', 1, datetime('now'), datetime('now')),
((SELECT id FROM usuarios WHERE email = 'premium@example.com'), 'paypal', 'user@example.com', 0, datetime('now'), datetime('now')),
((SELECT id FROM usuarios WHERE email = 'corporate@example.com'), 'bank_transfer', 'IBAN: ESXX XXXX XXXX XXXX XXXX', 1, datetime('now'), datetime('now'));

-- Tokens revocados
INSERT OR IGNORE INTO revoked_tokens (token, revoked_at, user_id) VALUES
('expired.token.xxxx', datetime('now', '-30 days'), (SELECT id FROM usuarios WHERE email = 'freemium@example.com')),
('compromised.token.yyyy', datetime('now', '-2 hours'), (SELECT id FROM usuarios WHERE email = 'premium@example.com'));

-- Tokens de reseteo de contraseña
INSERT OR IGNORE INTO password_reset_tokens (user_id, token, created_at, expires_at) VALUES
((SELECT id FROM usuarios WHERE email = 'freemium@example.com'), 'reset_token_123', datetime('now'), datetime('now', '+1 hour')),
((SELECT id FROM usuarios WHERE email = 'admin@example.com'), 'reset_token_456', datetime('now'), datetime('now', '+1 hour'));

---------------------------------------------------------------------
-- Datos iniciales para gamificación
---------------------------------------------------------------------

-- Insertar tipos de eventos
INSERT OR IGNORE INTO event_types (name, description, points_per_event) VALUES
('api_usage', 'Eventos por uso de la API', 5),
('test_api', 'Eventos de prueba', 10);

-- Insertar badges
INSERT OR IGNORE INTO badges (name, description, event_type_id, required_points, user_type) VALUES
('Novato', 'Primeros pasos en la API', 1, 5, 'both'),
('Becario', 'Uso intermedio de la API', 1, 100, 'both'),
('Junior', 'Uso avanzado de la API', 1, 500, 'registered'),
('Senior', 'Maestro de la API', 1, 1000, 'registered'),
('Tester', 'Participante en pruebas', 2, 10, 'both');

-- Insertar eventos de gamificación sin variables ni NOW()
INSERT OR IGNORE INTO gamification_events (event_type_id, user_id, timestamp)
VALUES (2, (SELECT id FROM usuarios WHERE email = 'testuser1@example.com'), datetime('now'));

INSERT OR IGNORE INTO gamification_events (event_type_id, session_id, timestamp)
VALUES (2, (SELECT id FROM sesiones_anonimas WHERE username = 'anon_user_1'), datetime('now'));

-- Actualizar gamificación de usuarios de prueba
INSERT OR IGNORE INTO user_gamification (user_id, event_type_id, points, badge_id)
VALUES ((SELECT id FROM usuarios WHERE email = 'testuser1@example.com'), 2, 10, (SELECT id FROM badges WHERE name = 'Tester'));

INSERT OR IGNORE INTO user_gamification (session_id, event_type_id, points, badge_id)
VALUES ((SELECT id FROM sesiones_anonimas WHERE username = 'anon_user_1'), 2, 10, (SELECT id FROM badges WHERE name = 'Tester'));

INSERT OR IGNORE INTO event_types (name, description, points_per_event) VALUES
('survey_question', 'Responder una pregunta de la encuesta', 1),
('survey_completed', 'Completar la encuesta', 0),
('registration_field', 'Rellenar un campo de registro', 1),
('registration_completed', 'Completar el registro', 0),
('subscription_list', 'Suscribirse a una lista', 1),
('all_subscriptions', 'Suscribirse a todas las listas', 0);

INSERT OR IGNORE INTO badges (name, description, event_type_id, required_points, user_type) VALUES
('Encuestador', 'Completar una encuesta', (SELECT id FROM event_types WHERE name='survey_completed'), 0, 'both'),
('Registrado', 'Completar el registro', (SELECT id FROM event_types WHERE name='registration_completed'), 0, 'both'),
('Suscriptor', 'Suscribirse a todas las listas', (SELECT id FROM event_types WHERE name='all_subscriptions'), 0, 'both');

INSERT OR IGNORE INTO event_types (id, name, description, points_per_event) VALUES
(1, 'registro_campo', 'Puntos por completar cada campo del registro', 1),
(2, 'registro_completo', 'Puntos por completar el registro completo', 10),
(3, 'suscripcion_newsletter', 'Puntos por cada suscripción a newsletter', 2),
(4, 'todas_suscripciones', 'Puntos por suscribirse a todas las newsletters', 15),
(5, 'encuesta_pregunta', 'Puntos por cada pregunta de encuesta respondida', 1),
(6, 'encuesta_completa', 'Puntos por completar la encuesta', 10),
(7, 'checkin_horario', 'Puntos por hacer check-in en horario', 5),
(8, 'icp_campo', 'Puntos por completar cada campo del ICP', 1),
(9, 'icp_completo', 'Puntos por completar el ICP completo', 10),
(10, 'leccion_completada', 'Puntos por completar cada lección', 3);

CREATE TABLE IF NOT EXISTS coupons (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    description TEXT,
    unique_identifier TEXT NOT NULL UNIQUE,
    issued_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at DATETIME,
    redeemed_at DATETIME,
    active INTEGER DEFAULT 1,
    status TEXT CHECK(status IN ('active', 'redeemed', 'expired', 'disabled')) DEFAULT 'active',
    credits INTEGER NOT NULL,
    user_id INTEGER,
    session_id TEXT,
    redeemed_by_user_id INTEGER,
    redeemed_by_session_id TEXT,
    FOREIGN KEY (user_id) REFERENCES usuarios(id),
    FOREIGN KEY (session_id) REFERENCES sesiones_anonimas(id),
    FOREIGN KEY (redeemed_by_user_id) REFERENCES usuarios(id),
    FOREIGN KEY (redeemed_by_session_id) REFERENCES sesiones_anonimas(id)
);

-- Mensaje final
SELECT '✅ Base de datos inicializada con datos de ejemplo, incluyendo gamificación.' AS message;


Y por ultimo, para que veas el lio, asi esta la db actualmente (es un dump)

PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE usuarios (
	id INTEGER NOT NULL, 
	email VARCHAR(255) NOT NULL, 
	username VARCHAR(50) NOT NULL, 
	password_hash VARCHAR(255), 
	auth_provider VARCHAR(20), 
	provider_id VARCHAR(255), 
	rol VARCHAR(20), 
	activo BOOLEAN, 
	subscription VARCHAR(9), 
	ciudad VARCHAR(100), 
	website VARCHAR(255), 
	credits INTEGER, 
	create_at DATETIME, 
	renewal DATETIME, 
	last_ip VARCHAR(45), 
	last_login DATETIME, 
	token_valid_until DATETIME, 
	PRIMARY KEY (id)
);
INSERT INTO usuarios VALUES(4,'admin@example.com','admin_user','$2b$12$mSQISiTT0/babKkzsQbNB.WAs6DnyQF6wUFuyRmZPCHMJQMyLESgu',NULL,NULL,'admin',1,'PREMIUM','admin city','web admin',124520,'2025-04-03 10:45:54.737924','2025-04-03 10:48:46.171208','127.0.0.1','2025-04-10 12:08:48.838279',NULL);
CREATE TABLE sesiones_anonimas (
	id VARCHAR(36) NOT NULL, 
	username VARCHAR(50) NOT NULL, 
	credits INTEGER, 
	create_at DATETIME, 
	ultima_actividad DATETIME, 
	last_ip VARCHAR(45), 
	PRIMARY KEY (id), 
	UNIQUE (username)
);
INSERT INTO sesiones_anonimas VALUES('20120a4b-412b-4979-b67b-c0a5d2659f1c','Guest_zgpcm',10,'2025-04-10 11:30:30.870905','2025-04-10 11:49:31.385751','127.0.0.1');
CREATE TABLE event_types (
	id INTEGER NOT NULL, 
	name VARCHAR(50) NOT NULL, 
	description VARCHAR(255), 
	points_per_event INTEGER, 
	PRIMARY KEY (id), 
	UNIQUE (name)
);
INSERT INTO event_types VALUES(1,'api_usage','Uso de la API',10);
INSERT INTO event_types VALUES(2,'login','Inicio de sesión exitoso',5);
INSERT INTO event_types VALUES(3,'purchase','Compra de créditos',50);
INSERT INTO event_types VALUES(4,'test_api','Eventos de prueba',10);
INSERT INTO event_types VALUES(5,'tesr','tyres',5);
INSERT INTO event_types VALUES(6,'survey_question','Responder una pregunta de la encuesta',1);
INSERT INTO event_types VALUES(7,'survey_completed','Completar la encuesta',0);
INSERT INTO event_types VALUES(8,'registration_field','Rellenar un campo de registro',1);
INSERT INTO event_types VALUES(9,'registration_completed','Completar el registro',0);
INSERT INTO event_types VALUES(10,'subscription_list','Suscribirse a una lista',1);
INSERT INTO event_types VALUES(11,'all_subscriptions','Suscribirse a todas las listas',0);
CREATE TABLE revoked_tokens (
	token VARCHAR(500) NOT NULL, 
	revoked_at DATETIME, 
	user_id INTEGER, 
	PRIMARY KEY (token)
);
INSERT INTO revoked_tokens VALUES('expired.token.xxxx','2025-03-04 10:45:55.317705',1);
INSERT INTO revoked_tokens VALUES('compromised.token.yyyy','2025-04-03 08:45:55.317714',2);
INSERT INTO revoked_tokens VALUES('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NDQ4ODQyMzd9.ctr8JQNPmMTFm0t7oWMg9zODqRAB1lnM2kfS7W06ceY','2025-04-10 11:04:17.373515',4);
INSERT INTO revoked_tokens VALUES('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NDQ4ODc4NTd9.sZuYv3M9QtqgPeYgg4qmkbgrgqIWqQxR4XfCs6itwqU','2025-04-10 12:04:18.866916',4);
CREATE TABLE site_settings (
	id INTEGER NOT NULL, 
	"key" VARCHAR(50) NOT NULL, 
	value VARCHAR(255) NOT NULL, 
	description VARCHAR(255), 
	tag VARCHAR(50), 
	updated_by INTEGER, 
	updated_at DATETIME, 
	PRIMARY KEY (id), 
	UNIQUE ("key")
);
INSERT INTO site_settings VALUES(1,'token_expiration','60','Tiempo de vida del access token (segundos)','auth',NULL,'2025-04-03 10:45:55.303092');
INSERT INTO site_settings VALUES(2,'refresh_token_expiration','604800','Tiempo de vida del refresh token (7 días)','auth',NULL,'2025-04-03 10:45:55.303096');
INSERT INTO site_settings VALUES(3,'max_login_attempts','5','Máximo de intentos de login antes de bloqueo','auth',NULL,'2025-04-03 10:45:55.303098');
INSERT INTO site_settings VALUES(4,'rate_limit_auth','{"times": 20, "seconds": 60}','Límite de peticiones para auth','rate_limit',NULL,'2025-04-03 10:45:55.303099');
INSERT INTO site_settings VALUES(5,'rate_limit_api','{"times": 100, "seconds": 60}','Límite de peticiones para API','rate_limit',NULL,'2025-04-03 10:45:55.303101');
INSERT INTO site_settings VALUES(6,'rate_limit_admin','{"times": 50, "seconds": 60}','Límite de peticiones para admin','rate_limit',NULL,'2025-04-03 10:45:55.303103');
INSERT INTO site_settings VALUES(7,'cache_ttl','300','Tiempo de vida del caché en Redis (segundos)','cache',NULL,'2025-04-03 10:45:55.303104');
INSERT INTO site_settings VALUES(8,'cache_enabled','true','Habilitar/deshabilitar el caché','cache',NULL,'2025-04-03 10:45:55.303106');
INSERT INTO site_settings VALUES(9,'cache_max_size','10000','Tamaño máximo del caché en entradas','cache',NULL,'2025-04-03 10:45:55.303107');
INSERT INTO site_settings VALUES(10,'allowed_origins','["http://localhost:3000", "https://neptuno.app", "test", "https://nuevoorigen.com"]','Orígenes permitidos para CORS','cors',NULL,'2025-04-10 10:26:42.688850');
INSERT INTO site_settings VALUES(11,'cors_enabled','true','Habilitar/deshabilitar CORS','cors',NULL,'2025-04-03 10:45:55.303111');
INSERT INTO site_settings VALUES(12,'celery_workers','4','Número de workers de Celery','celery',NULL,'2025-04-03 10:45:55.303112');
INSERT INTO site_settings VALUES(13,'celery_task_timeout','300','Tiempo máximo de ejecución de tareas Celery (segundos)','celery',NULL,'2025-04-03 10:45:55.303114');
INSERT INTO site_settings VALUES(14,'celery_max_retries','3','Máximo de reintentos para tareas Celery','celery',NULL,'2025-04-03 10:45:55.303115');
INSERT INTO site_settings VALUES(15,'db_pool_size','20','Tamaño del pool de conexiones a la DB','database',NULL,'2025-04-03 10:45:55.303117');
INSERT INTO site_settings VALUES(16,'db_max_overflow','10','Conexiones adicionales permitidas en el pool','database',NULL,'2025-04-03 10:45:55.303118');
INSERT INTO site_settings VALUES(17,'db_pool_timeout','30','Tiempo de espera para una conexión del pool (segundos)','database',NULL,'2025-04-03 10:45:55.303120');
INSERT INTO site_settings VALUES(18,'freemium_credits','100','Créditos iniciales para suscripción freemium','credits',NULL,'2025-04-03 10:45:55.303122');
INSERT INTO site_settings VALUES(19,'premium_credits','1000','Créditos iniciales para suscripción premium','credits',NULL,'2025-04-03 10:45:55.303123');
INSERT INTO site_settings VALUES(20,'corporate_credits','5000','Créditos iniciales para suscripción corporativa','credits',NULL,'2025-04-03 10:45:55.303125');
INSERT INTO site_settings VALUES(21,'credit_reset_interval','30','Intervalo de reinicio de créditos (días)','credits',NULL,'2025-04-03 10:45:55.303126');
INSERT INTO site_settings VALUES(22,'log_level','"INFO"','Nivel de logging','logging',NULL,'2025-04-03 10:45:55.303128');
INSERT INTO site_settings VALUES(23,'log_retention_days','90','Días de retención de logs','logging',NULL,'2025-04-03 10:45:55.303130');
INSERT INTO site_settings VALUES(24,'maintenance_mode','false','Activar/desactivar modo mantenimiento','system',NULL,'2025-04-03 10:45:55.303131');
INSERT INTO site_settings VALUES(25,'api_version','"1.0.0"','Versión actual de la API','system',NULL,'2025-04-03 10:45:55.303133');
INSERT INTO site_settings VALUES(26,'enable_registration','"true"',NULL,NULL,NULL,'2025-04-10 10:20:05.845363');
INSERT INTO site_settings VALUES(27,'enable_payment_methods','"true"',NULL,NULL,NULL,'2025-04-05 13:48:44.070527');
INSERT INTO site_settings VALUES(28,'enable_gamification','"true"',NULL,NULL,NULL,'2025-04-04 15:08:31.058845');
INSERT INTO site_settings VALUES(29,'enable_social_login','"false"',NULL,NULL,NULL,'2025-04-08 19:04:43.027686');
INSERT INTO site_settings VALUES(30,'enable_badges','"true"',NULL,NULL,NULL,'2025-04-06 18:54:30.409629');
INSERT INTO site_settings VALUES(31,'enable_points','"true"',NULL,NULL,NULL,'2025-04-06 18:54:31.329235');
INSERT INTO site_settings VALUES(32,'enable_coupons','"true"',NULL,NULL,NULL,'2025-04-10 10:26:18.999869');
INSERT INTO site_settings VALUES(33,'disable_anonymous_users','"false"',NULL,NULL,NULL,'2025-04-10 09:50:27.641205');
CREATE TABLE allowed_origins (
	id INTEGER NOT NULL, 
	origin VARCHAR(255) NOT NULL, 
	PRIMARY KEY (id), 
	UNIQUE (origin)
);
INSERT INTO allowed_origins VALUES(1,'http://localhost:3000');
INSERT INTO allowed_origins VALUES(2,'https://neptuno.app');
INSERT INTO allowed_origins VALUES(3,'https://api.example.com');
CREATE TABLE badges (
	id INTEGER NOT NULL, 
	name VARCHAR(50) NOT NULL, 
	description VARCHAR(255), 
	event_type_id INTEGER NOT NULL, 
	required_points INTEGER NOT NULL, 
	user_type VARCHAR(20), 
	PRIMARY KEY (id), 
	UNIQUE (name), 
	FOREIGN KEY(event_type_id) REFERENCES event_types (id)
);
INSERT INTO badges VALUES(1,'Novato','Primer uso de la API',1,10,'both');
INSERT INTO badges VALUES(3,'Comprador','Primera compra de créditos',3,50,'registered');
INSERT INTO badges VALUES(4,'Becario','Uso intermedio de la API',1,100,'both');
INSERT INTO badges VALUES(5,'Junior','Uso avanzado de la API',1,500,'registered');
INSERT INTO badges VALUES(6,'Senior','Maestro de la API',1,1000,'registered');
INSERT INTO badges VALUES(7,'Tester','Participante en pruebas',2,10,'both');
INSERT INTO badges VALUES(8,'test','test',5,12,'both');
INSERT INTO badges VALUES(9,'Encuestador','Completar una encuesta',7,0,'both');
INSERT INTO badges VALUES(10,'Registrado','Completar el registro',9,0,'both');
INSERT INTO badges VALUES(11,'Suscriptor','Suscribirse a todas las listas',11,0,'both');
INSERT INTO badges VALUES(12,'DIOS','god mode',1,3000,'both');
CREATE TABLE gamification_events (
	id INTEGER NOT NULL, 
	event_type_id INTEGER NOT NULL, 
	user_id INTEGER, 
	session_id VARCHAR(36), 
	timestamp DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(event_type_id) REFERENCES event_types (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id), 
	FOREIGN KEY(session_id) REFERENCES sesiones_anonimas (id)
);
INSERT INTO gamification_events VALUES(1,1,NULL,NULL,'2025-04-03 10:45:55.355293');
INSERT INTO gamification_events VALUES(2,2,NULL,NULL,'2025-04-03 10:45:55.356397');
INSERT INTO gamification_events VALUES(3,3,NULL,NULL,'2025-04-03 10:45:55.356905');
INSERT INTO gamification_events VALUES(4,2,5,NULL,'2025-04-03 12:58:37');
INSERT INTO gamification_events VALUES(5,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 12:58:37');
INSERT INTO gamification_events VALUES(6,2,5,NULL,'2025-04-03 12:59:44');
INSERT INTO gamification_events VALUES(7,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 12:59:44');
INSERT INTO gamification_events VALUES(8,2,5,NULL,'2025-04-03 13:00:02');
INSERT INTO gamification_events VALUES(9,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 13:00:02');
INSERT INTO gamification_events VALUES(10,2,5,NULL,'2025-04-03 13:01:55');
INSERT INTO gamification_events VALUES(11,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 13:01:55');
INSERT INTO gamification_events VALUES(12,2,5,NULL,'2025-04-03 13:04:27');
INSERT INTO gamification_events VALUES(13,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 13:04:27');
INSERT INTO gamification_events VALUES(14,2,5,NULL,'2025-04-03 13:04:27');
INSERT INTO gamification_events VALUES(15,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 13:04:27');
INSERT INTO gamification_events VALUES(16,2,5,NULL,'2025-04-03 13:07:25');
INSERT INTO gamification_events VALUES(17,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-03 13:07:25');
INSERT INTO gamification_events VALUES(18,1,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 18:58:33.498215');
INSERT INTO gamification_events VALUES(19,2,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 18:58:36.399805');
INSERT INTO gamification_events VALUES(20,3,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 18:58:38.199056');
INSERT INTO gamification_events VALUES(21,20,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:01.621054');
INSERT INTO gamification_events VALUES(22,21,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:03.381075');
INSERT INTO gamification_events VALUES(23,22,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:05.145844');
INSERT INTO gamification_events VALUES(24,23,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:05.180272');
INSERT INTO gamification_events VALUES(25,23,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:05.223238');
INSERT INTO gamification_events VALUES(26,1,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:13.066856');
INSERT INTO gamification_events VALUES(27,2,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:14.484946');
INSERT INTO gamification_events VALUES(28,3,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:15.459085');
INSERT INTO gamification_events VALUES(29,10,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:28.244564');
INSERT INTO gamification_events VALUES(30,11,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:29.223398');
INSERT INTO gamification_events VALUES(31,21,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:39.279977');
INSERT INTO gamification_events VALUES(32,22,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:41.160152');
INSERT INTO gamification_events VALUES(33,20,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:42.212157');
INSERT INTO gamification_events VALUES(34,23,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:42.247491');
INSERT INTO gamification_events VALUES(35,23,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:08:42.285835');
INSERT INTO gamification_events VALUES(36,1,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:13:35.927710');
INSERT INTO gamification_events VALUES(37,2,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:13:36.491560');
INSERT INTO gamification_events VALUES(38,3,NULL,'a50a0b78-e23b-4ab8-a14f-3d01096a492c','2025-04-03 19:13:37.031027');
INSERT INTO gamification_events VALUES(39,100,4,NULL,'2025-04-03 19:21:33.228252');
INSERT INTO gamification_events VALUES(40,100,4,NULL,'2025-04-03 19:21:55.649119');
INSERT INTO gamification_events VALUES(41,1,4,NULL,'2025-04-03 21:06:30.322722');
INSERT INTO gamification_events VALUES(42,1,4,NULL,'2025-04-03 21:06:31.529372');
INSERT INTO gamification_events VALUES(43,1,4,NULL,'2025-04-03 21:06:32.171485');
INSERT INTO gamification_events VALUES(44,2,4,NULL,'2025-04-03 21:06:33.943422');
INSERT INTO gamification_events VALUES(45,3,4,NULL,'2025-04-03 21:06:40.814985');
INSERT INTO gamification_events VALUES(46,3,4,NULL,'2025-04-03 21:06:40.869149');
INSERT INTO gamification_events VALUES(47,3,4,NULL,'2025-04-03 21:06:40.971001');
INSERT INTO gamification_events VALUES(48,3,4,NULL,'2025-04-03 21:06:41.025658');
INSERT INTO gamification_events VALUES(49,3,4,NULL,'2025-04-03 21:06:41.521918');
INSERT INTO gamification_events VALUES(50,3,4,NULL,'2025-04-03 21:06:41.592543');
INSERT INTO gamification_events VALUES(51,3,4,NULL,'2025-04-03 21:06:42.152618');
INSERT INTO gamification_events VALUES(52,3,4,NULL,'2025-04-03 21:06:42.233135');
INSERT INTO gamification_events VALUES(53,3,4,NULL,'2025-04-03 21:06:42.937040');
INSERT INTO gamification_events VALUES(54,3,4,NULL,'2025-04-03 21:06:43.053030');
INSERT INTO gamification_events VALUES(55,3,4,NULL,'2025-04-03 21:06:43.157145');
INSERT INTO gamification_events VALUES(56,3,4,NULL,'2025-04-03 21:06:43.241845');
INSERT INTO gamification_events VALUES(57,3,4,NULL,'2025-04-03 21:06:43.318565');
INSERT INTO gamification_events VALUES(58,3,4,NULL,'2025-04-03 21:06:43.417507');
INSERT INTO gamification_events VALUES(59,3,4,NULL,'2025-04-03 21:06:43.524010');
INSERT INTO gamification_events VALUES(60,3,4,NULL,'2025-04-03 21:06:43.617375');
INSERT INTO gamification_events VALUES(61,3,4,NULL,'2025-04-03 21:06:43.719813');
INSERT INTO gamification_events VALUES(62,3,4,NULL,'2025-04-03 21:06:44.166593');
INSERT INTO gamification_events VALUES(63,3,4,NULL,'2025-04-03 21:06:44.244243');
INSERT INTO gamification_events VALUES(64,3,4,NULL,'2025-04-03 21:06:44.317236');
INSERT INTO gamification_events VALUES(65,4,4,NULL,'2025-04-03 21:06:44.388062');
INSERT INTO gamification_events VALUES(66,4,4,NULL,'2025-04-03 21:06:44.480189');
INSERT INTO gamification_events VALUES(67,3,4,NULL,'2025-04-03 21:06:44.521108');
INSERT INTO gamification_events VALUES(68,3,4,NULL,'2025-04-03 21:06:44.585274');
INSERT INTO gamification_events VALUES(69,3,4,NULL,'2025-04-03 21:06:44.638360');
INSERT INTO gamification_events VALUES(70,4,4,NULL,'2025-04-03 21:06:44.806848');
INSERT INTO gamification_events VALUES(71,3,4,NULL,'2025-04-03 21:06:44.907113');
INSERT INTO gamification_events VALUES(72,3,4,NULL,'2025-04-03 21:06:44.906353');
INSERT INTO gamification_events VALUES(73,3,4,NULL,'2025-04-03 21:06:45.096808');
INSERT INTO gamification_events VALUES(74,4,4,NULL,'2025-04-03 21:06:45.095190');
INSERT INTO gamification_events VALUES(75,4,4,NULL,'2025-04-03 21:06:45.098458');
INSERT INTO gamification_events VALUES(76,4,4,NULL,'2025-04-03 21:06:45.348900');
INSERT INTO gamification_events VALUES(77,4,4,NULL,'2025-04-03 21:06:45.356011');
INSERT INTO gamification_events VALUES(78,4,4,NULL,'2025-04-03 21:06:45.507169');
INSERT INTO gamification_events VALUES(79,5,4,NULL,'2025-04-03 21:06:50.811089');
INSERT INTO gamification_events VALUES(80,5,4,NULL,'2025-04-03 21:06:51.370369');
INSERT INTO gamification_events VALUES(81,1,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:33.663302');
INSERT INTO gamification_events VALUES(82,1,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:34.729014');
INSERT INTO gamification_events VALUES(83,1,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:35.882002');
INSERT INTO gamification_events VALUES(84,5,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:37.566455');
INSERT INTO gamification_events VALUES(85,5,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:39.231148');
INSERT INTO gamification_events VALUES(86,5,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:40.298006');
INSERT INTO gamification_events VALUES(87,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.285817');
INSERT INTO gamification_events VALUES(88,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.408422');
INSERT INTO gamification_events VALUES(89,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.441416');
INSERT INTO gamification_events VALUES(90,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.476155');
INSERT INTO gamification_events VALUES(91,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.547895');
INSERT INTO gamification_events VALUES(92,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.578239');
INSERT INTO gamification_events VALUES(93,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.738920');
INSERT INTO gamification_events VALUES(94,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.773664');
INSERT INTO gamification_events VALUES(95,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.807828');
INSERT INTO gamification_events VALUES(96,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.897381');
INSERT INTO gamification_events VALUES(97,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:42.977715');
INSERT INTO gamification_events VALUES(98,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.035740');
INSERT INTO gamification_events VALUES(99,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.071158');
INSERT INTO gamification_events VALUES(100,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.104375');
INSERT INTO gamification_events VALUES(101,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.292130');
INSERT INTO gamification_events VALUES(102,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.341358');
INSERT INTO gamification_events VALUES(103,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.378456');
INSERT INTO gamification_events VALUES(104,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:43.416085');
INSERT INTO gamification_events VALUES(105,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.196898');
INSERT INTO gamification_events VALUES(106,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.234603');
INSERT INTO gamification_events VALUES(107,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.271694');
INSERT INTO gamification_events VALUES(108,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.305680');
INSERT INTO gamification_events VALUES(109,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.360614');
INSERT INTO gamification_events VALUES(110,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.423160');
INSERT INTO gamification_events VALUES(111,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.456237');
INSERT INTO gamification_events VALUES(112,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.503442');
INSERT INTO gamification_events VALUES(113,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.602406');
INSERT INTO gamification_events VALUES(114,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.667396');
INSERT INTO gamification_events VALUES(115,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.704145');
INSERT INTO gamification_events VALUES(116,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.765732');
INSERT INTO gamification_events VALUES(117,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.867438');
INSERT INTO gamification_events VALUES(118,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.902417');
INSERT INTO gamification_events VALUES(119,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.945684');
INSERT INTO gamification_events VALUES(120,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:44.988013');
INSERT INTO gamification_events VALUES(121,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:45.025095');
INSERT INTO gamification_events VALUES(122,3,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:45.096202');
INSERT INTO gamification_events VALUES(123,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:45.191581');
INSERT INTO gamification_events VALUES(124,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:45.231725');
INSERT INTO gamification_events VALUES(125,4,NULL,'148da799-83d2-4972-a23d-39892c183d07','2025-04-03 21:29:45.320308');
INSERT INTO gamification_events VALUES(126,100,4,NULL,'2025-04-03 21:38:19.476679');
INSERT INTO gamification_events VALUES(127,1,4,NULL,'2025-04-03 21:39:27.876391');
INSERT INTO gamification_events VALUES(128,1,4,NULL,'2025-04-03 21:39:29.207911');
INSERT INTO gamification_events VALUES(129,1,4,NULL,'2025-04-03 21:39:30.020395');
INSERT INTO gamification_events VALUES(130,2,4,NULL,'2025-04-03 21:39:31.036509');
INSERT INTO gamification_events VALUES(131,3,4,NULL,'2025-04-03 21:39:35.959878');
INSERT INTO gamification_events VALUES(132,3,4,NULL,'2025-04-03 21:39:35.987832');
INSERT INTO gamification_events VALUES(133,3,4,NULL,'2025-04-03 21:39:36.012930');
INSERT INTO gamification_events VALUES(134,3,4,NULL,'2025-04-03 21:39:36.089285');
INSERT INTO gamification_events VALUES(135,3,4,NULL,'2025-04-03 21:39:36.226996');
INSERT INTO gamification_events VALUES(136,3,4,NULL,'2025-04-03 21:39:36.305783');
INSERT INTO gamification_events VALUES(137,3,4,NULL,'2025-04-03 21:39:36.365774');
INSERT INTO gamification_events VALUES(138,3,4,NULL,'2025-04-03 21:39:36.403604');
INSERT INTO gamification_events VALUES(139,3,4,NULL,'2025-04-03 21:39:37.456661');
INSERT INTO gamification_events VALUES(140,3,4,NULL,'2025-04-03 21:39:37.494294');
INSERT INTO gamification_events VALUES(141,3,4,NULL,'2025-04-03 21:39:37.689988');
INSERT INTO gamification_events VALUES(142,3,4,NULL,'2025-04-03 21:39:37.764666');
INSERT INTO gamification_events VALUES(143,3,4,NULL,'2025-04-03 21:39:37.917089');
INSERT INTO gamification_events VALUES(144,3,4,NULL,'2025-04-03 21:39:37.957492');
INSERT INTO gamification_events VALUES(145,3,4,NULL,'2025-04-03 21:39:38.056111');
INSERT INTO gamification_events VALUES(146,3,4,NULL,'2025-04-03 21:39:38.102782');
INSERT INTO gamification_events VALUES(147,3,4,NULL,'2025-04-03 21:39:39.249672');
INSERT INTO gamification_events VALUES(148,3,4,NULL,'2025-04-03 21:39:39.380507');
INSERT INTO gamification_events VALUES(149,4,4,NULL,'2025-04-03 21:39:39.493159');
INSERT INTO gamification_events VALUES(150,3,4,NULL,'2025-04-03 21:39:39.550928');
INSERT INTO gamification_events VALUES(151,4,4,NULL,'2025-04-03 21:39:39.695688');
INSERT INTO gamification_events VALUES(152,3,4,NULL,'2025-04-03 21:39:39.757962');
INSERT INTO gamification_events VALUES(153,3,4,NULL,'2025-04-03 21:39:39.873758');
INSERT INTO gamification_events VALUES(154,3,4,NULL,'2025-04-03 21:39:39.923024');
INSERT INTO gamification_events VALUES(155,4,4,NULL,'2025-04-03 21:39:39.971010');
INSERT INTO gamification_events VALUES(156,4,4,NULL,'2025-04-03 21:39:40.081952');
INSERT INTO gamification_events VALUES(157,4,4,NULL,'2025-04-03 21:39:40.156299');
INSERT INTO gamification_events VALUES(158,5,4,NULL,'2025-04-03 21:39:46.030089');
INSERT INTO gamification_events VALUES(159,5,4,NULL,'2025-04-03 21:39:47.401548');
INSERT INTO gamification_events VALUES(160,5,4,NULL,'2025-04-03 21:39:48.446137');
INSERT INTO gamification_events VALUES(161,5,4,NULL,'2025-04-03 21:39:53.721480');
INSERT INTO gamification_events VALUES(162,5,4,NULL,'2025-04-03 21:39:54.059632');
INSERT INTO gamification_events VALUES(163,5,4,NULL,'2025-04-03 21:39:54.750839');
INSERT INTO gamification_events VALUES(164,5,4,NULL,'2025-04-03 21:39:55.133993');
INSERT INTO gamification_events VALUES(165,100,4,NULL,'2025-04-04 13:19:25.963688');
INSERT INTO gamification_events VALUES(166,3,4,NULL,'2025-04-04 13:24:23.728879');
INSERT INTO gamification_events VALUES(167,3,4,NULL,'2025-04-04 13:24:26.563877');
INSERT INTO gamification_events VALUES(168,7,4,NULL,'2025-04-04 13:24:28.794056');
INSERT INTO gamification_events VALUES(169,10,4,NULL,'2025-04-04 13:24:32.639359');
INSERT INTO gamification_events VALUES(170,10,4,NULL,'2025-04-04 13:24:34.784990');
INSERT INTO gamification_events VALUES(171,10,4,NULL,'2025-04-04 13:24:36.809305');
INSERT INTO gamification_events VALUES(172,3,4,NULL,'2025-04-04 13:24:43.520535');
INSERT INTO gamification_events VALUES(173,3,4,NULL,'2025-04-04 13:24:44.178790');
INSERT INTO gamification_events VALUES(174,3,4,NULL,'2025-04-04 13:24:44.774676');
INSERT INTO gamification_events VALUES(175,5,4,NULL,'2025-04-04 13:24:53.259041');
INSERT INTO gamification_events VALUES(176,5,4,NULL,'2025-04-04 13:24:53.870485');
INSERT INTO gamification_events VALUES(177,5,4,NULL,'2025-04-04 13:24:54.469913');
INSERT INTO gamification_events VALUES(178,7,4,NULL,'2025-04-04 19:43:25.499539');
INSERT INTO gamification_events VALUES(179,5,4,NULL,'2025-04-04 19:43:31.251656');
INSERT INTO gamification_events VALUES(180,5,4,NULL,'2025-04-04 19:43:32.749036');
INSERT INTO gamification_events VALUES(181,5,4,NULL,'2025-04-04 19:43:33.954273');
INSERT INTO gamification_events VALUES(182,6,4,NULL,'2025-04-04 19:43:34.921451');
INSERT INTO gamification_events VALUES(183,1,4,NULL,'2025-04-04 19:43:48.948725');
INSERT INTO gamification_events VALUES(184,1,4,NULL,'2025-04-04 19:43:49.051842');
INSERT INTO gamification_events VALUES(185,1,4,NULL,'2025-04-04 19:43:49.141666');
INSERT INTO gamification_events VALUES(186,1,4,NULL,'2025-04-04 19:43:49.306064');
INSERT INTO gamification_events VALUES(187,1,4,NULL,'2025-04-04 19:43:49.432833');
INSERT INTO gamification_events VALUES(188,1,4,NULL,'2025-04-04 19:43:49.555140');
INSERT INTO gamification_events VALUES(189,1,4,NULL,'2025-04-04 19:43:49.723016');
INSERT INTO gamification_events VALUES(190,1,4,NULL,'2025-04-04 19:43:49.880137');
INSERT INTO gamification_events VALUES(191,1,4,NULL,'2025-04-04 19:43:50.326554');
INSERT INTO gamification_events VALUES(192,1,4,NULL,'2025-04-04 19:43:50.459679');
INSERT INTO gamification_events VALUES(193,1,4,NULL,'2025-04-04 19:43:50.723485');
INSERT INTO gamification_events VALUES(194,1,4,NULL,'2025-04-04 19:43:50.867514');
INSERT INTO gamification_events VALUES(195,1,4,NULL,'2025-04-04 19:43:51.009047');
INSERT INTO gamification_events VALUES(196,1,4,NULL,'2025-04-04 19:43:51.301341');
INSERT INTO gamification_events VALUES(197,1,4,NULL,'2025-04-04 19:43:51.487780');
INSERT INTO gamification_events VALUES(198,1,4,NULL,'2025-04-04 19:43:51.670068');
INSERT INTO gamification_events VALUES(199,1,4,NULL,'2025-04-04 19:43:51.968959');
INSERT INTO gamification_events VALUES(200,1,4,NULL,'2025-04-04 19:43:52.147352');
INSERT INTO gamification_events VALUES(201,1,4,NULL,'2025-04-04 19:43:52.234250');
INSERT INTO gamification_events VALUES(202,1,4,NULL,'2025-04-04 19:43:52.319270');
INSERT INTO gamification_events VALUES(203,1,4,NULL,'2025-04-04 19:43:52.414936');
INSERT INTO gamification_events VALUES(204,1,4,NULL,'2025-04-04 19:43:52.601861');
INSERT INTO gamification_events VALUES(205,1,4,NULL,'2025-04-04 19:43:52.700331');
INSERT INTO gamification_events VALUES(206,1,4,NULL,'2025-04-04 19:43:52.799384');
INSERT INTO gamification_events VALUES(207,1,4,NULL,'2025-04-04 19:43:53.300854');
INSERT INTO gamification_events VALUES(208,1,4,NULL,'2025-04-04 19:43:53.434624');
INSERT INTO gamification_events VALUES(209,1,4,NULL,'2025-04-04 19:43:53.570219');
INSERT INTO gamification_events VALUES(210,1,4,NULL,'2025-04-04 19:43:53.706984');
INSERT INTO gamification_events VALUES(211,2,4,NULL,'2025-04-04 19:43:53.874027');
INSERT INTO gamification_events VALUES(212,2,4,NULL,'2025-04-04 19:43:53.947839');
INSERT INTO gamification_events VALUES(213,2,4,NULL,'2025-04-04 19:43:54.090423');
INSERT INTO gamification_events VALUES(214,1,4,NULL,'2025-04-04 19:43:55.072334');
INSERT INTO gamification_events VALUES(215,1,4,NULL,'2025-04-04 19:43:55.144145');
INSERT INTO gamification_events VALUES(216,1,4,NULL,'2025-04-04 19:43:55.239924');
INSERT INTO gamification_events VALUES(217,2,4,NULL,'2025-04-04 19:43:55.283801');
INSERT INTO gamification_events VALUES(218,1,4,NULL,'2025-04-04 19:43:55.386606');
INSERT INTO gamification_events VALUES(219,1,4,NULL,'2025-04-04 19:43:55.504183');
INSERT INTO gamification_events VALUES(220,1,4,NULL,'2025-04-04 19:43:55.598656');
INSERT INTO gamification_events VALUES(221,2,4,NULL,'2025-04-04 19:43:55.674568');
INSERT INTO gamification_events VALUES(222,2,4,NULL,'2025-04-04 19:43:55.723486');
INSERT INTO gamification_events VALUES(223,2,4,NULL,'2025-04-04 19:43:55.830773');
INSERT INTO gamification_events VALUES(224,2,4,NULL,'2025-04-04 19:43:55.946519');
INSERT INTO gamification_events VALUES(225,2,4,NULL,'2025-04-04 19:43:55.998540');
INSERT INTO gamification_events VALUES(226,10,4,NULL,'2025-04-04 19:44:05.923815');
INSERT INTO gamification_events VALUES(227,10,4,NULL,'2025-04-04 19:44:07.581156');
INSERT INTO gamification_events VALUES(228,10,4,NULL,'2025-04-04 19:44:10.008129');
INSERT INTO gamification_events VALUES(229,5,4,NULL,'2025-04-05 09:50:04.156027');
INSERT INTO gamification_events VALUES(230,5,4,NULL,'2025-04-05 09:50:04.724569');
INSERT INTO gamification_events VALUES(231,5,4,NULL,'2025-04-05 09:50:06.079929');
INSERT INTO gamification_events VALUES(232,6,4,NULL,'2025-04-05 09:50:06.992549');
INSERT INTO gamification_events VALUES(233,3,4,NULL,'2025-04-05 09:50:30.923807');
INSERT INTO gamification_events VALUES(234,3,4,NULL,'2025-04-05 09:50:32.561518');
INSERT INTO gamification_events VALUES(235,3,4,NULL,'2025-04-05 09:50:33.792915');
INSERT INTO gamification_events VALUES(236,1,4,NULL,'2025-04-05 10:37:54.211037');
INSERT INTO gamification_events VALUES(237,1,4,NULL,'2025-04-05 10:37:54.287616');
INSERT INTO gamification_events VALUES(238,1,4,NULL,'2025-04-05 10:37:54.348449');
INSERT INTO gamification_events VALUES(239,1,4,NULL,'2025-04-05 10:37:54.507002');
INSERT INTO gamification_events VALUES(240,1,4,NULL,'2025-04-05 10:37:54.588908');
INSERT INTO gamification_events VALUES(241,1,4,NULL,'2025-04-05 10:37:54.764190');
INSERT INTO gamification_events VALUES(242,1,4,NULL,'2025-04-05 10:37:54.932550');
INSERT INTO gamification_events VALUES(243,1,4,NULL,'2025-04-05 10:37:55.100810');
INSERT INTO gamification_events VALUES(244,1,4,NULL,'2025-04-05 10:37:55.876893');
INSERT INTO gamification_events VALUES(245,1,4,NULL,'2025-04-05 10:37:56.023376');
INSERT INTO gamification_events VALUES(246,1,4,NULL,'2025-04-05 10:37:56.119658');
INSERT INTO gamification_events VALUES(247,1,4,NULL,'2025-04-05 10:37:56.210340');
INSERT INTO gamification_events VALUES(248,1,4,NULL,'2025-04-05 10:37:56.296208');
INSERT INTO gamification_events VALUES(249,1,4,NULL,'2025-04-05 10:37:56.433240');
INSERT INTO gamification_events VALUES(250,1,4,NULL,'2025-04-05 10:37:56.608850');
INSERT INTO gamification_events VALUES(251,1,4,NULL,'2025-04-05 10:37:56.641640');
INSERT INTO gamification_events VALUES(252,3,4,NULL,'2025-04-05 10:37:58.606132');
INSERT INTO gamification_events VALUES(253,3,4,NULL,'2025-04-05 10:37:59.151626');
INSERT INTO gamification_events VALUES(254,3,4,NULL,'2025-04-05 10:37:59.738000');
INSERT INTO gamification_events VALUES(255,7,4,NULL,'2025-04-05 10:38:02.309667');
INSERT INTO gamification_events VALUES(256,1,4,NULL,'2025-04-05 10:38:06.757264');
INSERT INTO gamification_events VALUES(257,1,4,NULL,'2025-04-05 10:38:06.835684');
INSERT INTO gamification_events VALUES(258,1,4,NULL,'2025-04-05 10:38:06.978827');
INSERT INTO gamification_events VALUES(259,2,4,NULL,'2025-04-05 10:38:07.048642');
INSERT INTO gamification_events VALUES(260,1,4,NULL,'2025-04-05 10:38:07.150954');
INSERT INTO gamification_events VALUES(261,1,4,NULL,'2025-04-05 10:38:07.227471');
INSERT INTO gamification_events VALUES(262,2,4,NULL,'2025-04-05 10:38:07.259818');
INSERT INTO gamification_events VALUES(263,1,4,NULL,'2025-04-05 10:38:07.367643');
INSERT INTO gamification_events VALUES(264,2,4,NULL,'2025-04-05 10:38:07.408994');
INSERT INTO gamification_events VALUES(265,2,4,NULL,'2025-04-05 10:38:07.490992');
INSERT INTO gamification_events VALUES(266,2,4,NULL,'2025-04-05 10:38:07.579261');
INSERT INTO gamification_events VALUES(267,5,4,NULL,'2025-04-05 10:38:08.366762');
INSERT INTO gamification_events VALUES(268,5,4,NULL,'2025-04-05 10:38:10.661342');
INSERT INTO gamification_events VALUES(269,5,4,NULL,'2025-04-05 10:38:11.548305');
INSERT INTO gamification_events VALUES(270,6,4,NULL,'2025-04-05 10:38:12.345985');
INSERT INTO gamification_events VALUES(271,6,4,NULL,'2025-04-05 10:38:18.306390');
INSERT INTO gamification_events VALUES(272,10,4,NULL,'2025-04-05 10:38:21.560345');
INSERT INTO gamification_events VALUES(273,10,4,NULL,'2025-04-05 10:38:22.104895');
INSERT INTO gamification_events VALUES(274,10,4,NULL,'2025-04-05 10:38:23.012114');
INSERT INTO gamification_events VALUES(275,8,4,NULL,'2025-04-05 10:38:27.117972');
INSERT INTO gamification_events VALUES(276,8,4,NULL,'2025-04-05 10:38:27.169374');
INSERT INTO gamification_events VALUES(277,8,4,NULL,'2025-04-05 10:38:27.243188');
INSERT INTO gamification_events VALUES(278,8,4,NULL,'2025-04-05 10:38:27.307387');
INSERT INTO gamification_events VALUES(279,8,4,NULL,'2025-04-05 10:38:27.367278');
INSERT INTO gamification_events VALUES(280,8,4,NULL,'2025-04-05 10:38:27.426527');
INSERT INTO gamification_events VALUES(281,8,4,NULL,'2025-04-05 10:38:27.482728');
INSERT INTO gamification_events VALUES(282,8,4,NULL,'2025-04-05 10:38:27.543161');
INSERT INTO gamification_events VALUES(283,8,4,NULL,'2025-04-05 10:38:28.601964');
INSERT INTO gamification_events VALUES(284,8,4,NULL,'2025-04-05 10:38:28.695779');
INSERT INTO gamification_events VALUES(285,8,4,NULL,'2025-04-05 10:38:28.860165');
INSERT INTO gamification_events VALUES(286,8,4,NULL,'2025-04-05 10:38:29.019248');
INSERT INTO gamification_events VALUES(287,8,4,NULL,'2025-04-05 10:38:29.232991');
INSERT INTO gamification_events VALUES(288,8,4,NULL,'2025-04-05 10:38:29.385815');
INSERT INTO gamification_events VALUES(289,8,4,NULL,'2025-04-05 10:38:29.458956');
INSERT INTO gamification_events VALUES(290,8,4,NULL,'2025-04-05 10:38:29.613199');
INSERT INTO gamification_events VALUES(291,8,4,NULL,'2025-04-05 10:38:30.466103');
INSERT INTO gamification_events VALUES(292,8,4,NULL,'2025-04-05 10:38:30.528400');
INSERT INTO gamification_events VALUES(293,8,4,NULL,'2025-04-05 10:38:30.652010');
INSERT INTO gamification_events VALUES(294,8,4,NULL,'2025-04-05 10:38:30.717094');
INSERT INTO gamification_events VALUES(295,8,4,NULL,'2025-04-05 10:38:30.789940');
INSERT INTO gamification_events VALUES(296,9,4,NULL,'2025-04-05 10:38:30.844237');
INSERT INTO gamification_events VALUES(297,8,4,NULL,'2025-04-05 10:38:30.922403');
INSERT INTO gamification_events VALUES(298,9,4,NULL,'2025-04-05 10:38:31.036564');
INSERT INTO gamification_events VALUES(299,9,4,NULL,'2025-04-05 10:38:31.100944');
INSERT INTO gamification_events VALUES(300,9,4,NULL,'2025-04-05 10:38:31.131770');
INSERT INTO gamification_events VALUES(301,8,4,NULL,'2025-04-05 10:38:31.155125');
INSERT INTO gamification_events VALUES(302,8,4,NULL,'2025-04-05 10:38:31.206375');
INSERT INTO gamification_events VALUES(303,9,4,NULL,'2025-04-05 10:38:31.335032');
INSERT INTO gamification_events VALUES(304,9,4,NULL,'2025-04-05 10:38:31.357321');
INSERT INTO gamification_events VALUES(305,9,4,NULL,'2025-04-05 10:38:31.472612');
INSERT INTO gamification_events VALUES(306,101,8,NULL,'2025-04-06 20:20:30.589519');
INSERT INTO gamification_events VALUES(307,102,8,NULL,'2025-04-06 20:20:30.635927');
INSERT INTO gamification_events VALUES(308,103,8,NULL,'2025-04-06 20:20:30.670162');
INSERT INTO gamification_events VALUES(309,104,8,NULL,'2025-04-06 20:20:31.053996');
INSERT INTO gamification_events VALUES(310,100,4,NULL,'2025-04-06 20:23:06.409847');
INSERT INTO gamification_events VALUES(311,100,4,NULL,'2025-04-06 21:31:32.344543');
INSERT INTO gamification_events VALUES(312,100,4,NULL,'2025-04-08 10:06:53.135345');
INSERT INTO gamification_events VALUES(313,100,4,NULL,'2025-04-08 10:14:39.206429');
INSERT INTO gamification_events VALUES(314,3,NULL,'e8c594f9-2fc7-4528-92d1-34f5dd9f2d61','2025-04-08 10:15:20.785014');
INSERT INTO gamification_events VALUES(315,3,NULL,'e8c594f9-2fc7-4528-92d1-34f5dd9f2d61','2025-04-08 10:15:21.382420');
INSERT INTO gamification_events VALUES(316,3,NULL,'e8c594f9-2fc7-4528-92d1-34f5dd9f2d61','2025-04-08 10:15:22.060175');
INSERT INTO gamification_events VALUES(317,100,8,NULL,'2025-04-08 10:16:34.903230');
INSERT INTO gamification_events VALUES(318,5,NULL,'32fd6476-19d8-435a-a9e2-a23864280144','2025-04-08 10:17:39.146068');
INSERT INTO gamification_events VALUES(319,5,NULL,'32fd6476-19d8-435a-a9e2-a23864280144','2025-04-08 10:17:39.683442');
INSERT INTO gamification_events VALUES(320,5,NULL,'32fd6476-19d8-435a-a9e2-a23864280144','2025-04-08 10:17:40.134781');
INSERT INTO gamification_events VALUES(321,6,NULL,'32fd6476-19d8-435a-a9e2-a23864280144','2025-04-08 10:17:40.747202');
INSERT INTO gamification_events VALUES(322,100,4,NULL,'2025-04-08 11:13:14.390028');
INSERT INTO gamification_events VALUES(323,100,4,NULL,'2025-04-08 11:44:29.681996');
INSERT INTO gamification_events VALUES(324,3,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:02.227442');
INSERT INTO gamification_events VALUES(325,3,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:04.823451');
INSERT INTO gamification_events VALUES(326,3,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:06.012065');
INSERT INTO gamification_events VALUES(327,7,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:38.233857');
INSERT INTO gamification_events VALUES(328,5,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:45.233835');
INSERT INTO gamification_events VALUES(329,5,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:46.333654');
INSERT INTO gamification_events VALUES(330,5,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:47.378376');
INSERT INTO gamification_events VALUES(331,6,NULL,'bd4d41d4-0df3-4953-a8e0-9953376dec04','2025-04-08 12:04:48.511454');
INSERT INTO gamification_events VALUES(332,100,4,NULL,'2025-04-08 13:15:48.539485');
INSERT INTO gamification_events VALUES(333,100,4,NULL,'2025-04-08 13:15:49.125641');
INSERT INTO gamification_events VALUES(334,101,9,NULL,'2025-04-08 13:23:23.382603');
INSERT INTO gamification_events VALUES(335,102,9,NULL,'2025-04-08 13:23:23.836662');
INSERT INTO gamification_events VALUES(336,103,9,NULL,'2025-04-08 13:23:24.269554');
INSERT INTO gamification_events VALUES(337,104,9,NULL,'2025-04-08 13:23:25.191726');
INSERT INTO gamification_events VALUES(338,100,9,NULL,'2025-04-08 13:24:05.396417');
INSERT INTO gamification_events VALUES(339,100,4,NULL,'2025-04-08 14:48:18.594505');
INSERT INTO gamification_events VALUES(340,3,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:10.588496');
INSERT INTO gamification_events VALUES(341,3,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:11.087679');
INSERT INTO gamification_events VALUES(342,3,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:11.386541');
INSERT INTO gamification_events VALUES(343,5,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:13.253214');
INSERT INTO gamification_events VALUES(344,5,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:13.697658');
INSERT INTO gamification_events VALUES(345,5,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:14.368387');
INSERT INTO gamification_events VALUES(346,6,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:15.353377');
INSERT INTO gamification_events VALUES(347,7,NULL,'53be0a91-7d1e-44bc-a957-7c7ef1783762','2025-04-09 18:18:16.353573');
INSERT INTO gamification_events VALUES(348,100,9,NULL,'2025-04-09 18:20:36.051766');
INSERT INTO gamification_events VALUES(349,3,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:51.524930');
INSERT INTO gamification_events VALUES(350,3,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:51.913293');
INSERT INTO gamification_events VALUES(351,3,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:52.247114');
INSERT INTO gamification_events VALUES(352,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:53.235486');
INSERT INTO gamification_events VALUES(353,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:53.713291');
INSERT INTO gamification_events VALUES(354,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:54.591366');
INSERT INTO gamification_events VALUES(355,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:55.157449');
INSERT INTO gamification_events VALUES(356,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:55.535502');
INSERT INTO gamification_events VALUES(357,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:56.068742');
INSERT INTO gamification_events VALUES(358,5,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:56.514082');
INSERT INTO gamification_events VALUES(359,7,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:26:58.646911');
INSERT INTO gamification_events VALUES(360,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:00.624108');
INSERT INTO gamification_events VALUES(361,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:00.857896');
INSERT INTO gamification_events VALUES(362,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:01.035522');
INSERT INTO gamification_events VALUES(363,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:01.212879');
INSERT INTO gamification_events VALUES(364,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:01.613112');
INSERT INTO gamification_events VALUES(365,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:01.836065');
INSERT INTO gamification_events VALUES(366,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:02.313269');
INSERT INTO gamification_events VALUES(367,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:02.446682');
INSERT INTO gamification_events VALUES(368,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:02.602239');
INSERT INTO gamification_events VALUES(369,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:02.746459');
INSERT INTO gamification_events VALUES(370,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:03.224041');
INSERT INTO gamification_events VALUES(371,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:03.383746');
INSERT INTO gamification_events VALUES(372,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:03.568455');
INSERT INTO gamification_events VALUES(373,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:03.724035');
INSERT INTO gamification_events VALUES(374,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:05.405061');
INSERT INTO gamification_events VALUES(375,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:05.579516');
INSERT INTO gamification_events VALUES(376,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:06.013083');
INSERT INTO gamification_events VALUES(377,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:06.157601');
INSERT INTO gamification_events VALUES(378,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:06.292506');
INSERT INTO gamification_events VALUES(379,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:06.613106');
INSERT INTO gamification_events VALUES(380,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:06.813652');
INSERT INTO gamification_events VALUES(381,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:07.235060');
INSERT INTO gamification_events VALUES(382,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:08.157316');
INSERT INTO gamification_events VALUES(383,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:08.446371');
INSERT INTO gamification_events VALUES(384,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:09.079735');
INSERT INTO gamification_events VALUES(385,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:09.446259');
INSERT INTO gamification_events VALUES(386,8,NULL,'1960aa2f-d064-4340-a38c-7e091b9a9e36','2025-04-09 18:27:09.946349');
INSERT INTO gamification_events VALUES(387,2,5,NULL,'2025-04-09 23:57:15');
INSERT INTO gamification_events VALUES(388,2,NULL,'69fa5be7-1433-4df4-917b-b8a2607877dc','2025-04-09 23:57:15');
INSERT INTO gamification_events VALUES(389,100,4,NULL,'2025-04-10 00:42:43.959895');
INSERT INTO gamification_events VALUES(390,100,4,NULL,'2025-04-10 00:48:58.054107');
INSERT INTO gamification_events VALUES(391,100,4,NULL,'2025-04-10 08:07:31.462201');
INSERT INTO gamification_events VALUES(392,5,4,NULL,'2025-04-10 09:24:08.001149');
INSERT INTO gamification_events VALUES(393,5,4,NULL,'2025-04-10 09:24:08.887458');
INSERT INTO gamification_events VALUES(394,5,4,NULL,'2025-04-10 09:24:10.998526');
INSERT INTO gamification_events VALUES(395,6,4,NULL,'2025-04-10 09:24:12.131838');
INSERT INTO gamification_events VALUES(396,100,4,NULL,'2025-04-10 09:25:36.864451');
INSERT INTO gamification_events VALUES(397,100,4,NULL,'2025-04-10 09:49:55.739620');
INSERT INTO gamification_events VALUES(398,5,4,NULL,'2025-04-10 09:58:37.909989');
INSERT INTO gamification_events VALUES(399,5,4,NULL,'2025-04-10 09:58:39.054415');
INSERT INTO gamification_events VALUES(400,5,4,NULL,'2025-04-10 09:58:40.043274');
INSERT INTO gamification_events VALUES(401,6,4,NULL,'2025-04-10 09:58:41.776515');
INSERT INTO gamification_events VALUES(402,5,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:10.111803');
INSERT INTO gamification_events VALUES(403,5,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:11.399277');
INSERT INTO gamification_events VALUES(404,5,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:12.484100');
INSERT INTO gamification_events VALUES(405,6,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:14.500761');
INSERT INTO gamification_events VALUES(406,3,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:28.692352');
INSERT INTO gamification_events VALUES(407,3,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:29.284155');
INSERT INTO gamification_events VALUES(408,3,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1','2025-04-10 10:03:31.000327');
INSERT INTO gamification_events VALUES(409,100,4,NULL,'2025-04-10 10:03:57.706251');
INSERT INTO gamification_events VALUES(410,5,4,NULL,'2025-04-10 10:28:32.309453');
INSERT INTO gamification_events VALUES(411,5,4,NULL,'2025-04-10 10:28:33.842136');
INSERT INTO gamification_events VALUES(412,5,4,NULL,'2025-04-10 10:28:35.896928');
INSERT INTO gamification_events VALUES(413,6,4,NULL,'2025-04-10 10:28:37.630332');
CREATE TABLE password_reset_tokens (
	id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	token VARCHAR(100) NOT NULL, 
	created_at DATETIME, 
	expires_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id), 
	UNIQUE (token)
);
INSERT INTO password_reset_tokens VALUES(1,1,'reset_token_123','2025-04-03 10:45:55.334424','2025-04-03 11:45:55.317795');
INSERT INTO password_reset_tokens VALUES(2,4,'reset_token_456','2025-04-03 10:45:55.334428','2025-04-03 11:45:55.317801');
CREATE TABLE credit_transactions (
	id INTEGER NOT NULL, 
	user_id INTEGER, 
	session_id VARCHAR(36), 
	user_type VARCHAR(20) NOT NULL, 
	amount INTEGER NOT NULL, 
	transaction_type VARCHAR(50) NOT NULL, 
	description VARCHAR(255), 
	payment_amount FLOAT, 
	payment_method VARCHAR(50), 
	payment_status VARCHAR(20), 
	timestamp DATETIME, 
	PRIMARY KEY (id), 
	CONSTRAINT check_user_or_session CHECK ((user_id IS NOT NULL AND session_id IS NULL AND user_type = 'registered') OR (user_id IS NULL AND session_id IS NOT NULL AND user_type = 'anonymous')), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id), 
	FOREIGN KEY(session_id) REFERENCES sesiones_anonimas (id)
);
INSERT INTO credit_transactions VALUES(1,4,NULL,'registered',-1,'usage','Consulta realizada',NULL,NULL,'pending','2025-04-10 10:37:20.214410');
INSERT INTO credit_transactions VALUES(2,4,NULL,'registered',-1,'usage','Consulta realizada',NULL,NULL,'pending','2025-04-10 10:37:21.802392');
INSERT INTO credit_transactions VALUES(3,4,NULL,'registered',-1,'usage','Consulta realizada',NULL,NULL,'pending','2025-04-10 10:37:23.402732');
CREATE TABLE integrations (
	id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	name VARCHAR(50) NOT NULL, 
	webhook_url VARCHAR(255) NOT NULL, 
	event_type VARCHAR(50) NOT NULL, 
	active BOOLEAN, 
	created_at DATETIME, 
	last_triggered DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id)
);
INSERT INTO integrations VALUES(1,2,'slack','https://hooks.slack.com/services/TXXXXX/BXXXXX/XXXXX','credit_usage',1,'2025-04-03 10:45:55.329495','2025-04-03 08:45:55.316848');
INSERT INTO integrations VALUES(2,4,'zapier','https://hooks.zapier.com/hooks/catch/XXXXX/XXXXX','user_login',1,'2025-04-03 10:45:55.329498',NULL);
INSERT INTO integrations VALUES(3,3,'crm_custom','https://api.crm.com/webhook/XXXXX','payment_added',0,'2025-04-03 10:45:55.329500',NULL);
INSERT INTO integrations VALUES(4,4,'teste','teset','teset',1,'2025-04-10 11:10:27.911651',NULL);
INSERT INTO integrations VALUES(5,4,'erqwerqwer','qwerqwer','qwerqwer',1,'2025-04-10 11:14:54.373691',NULL);
CREATE TABLE payment_methods (
	id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	payment_type VARCHAR(20) NOT NULL, 
	details VARCHAR(255) NOT NULL, 
	is_default BOOLEAN, 
	created_at DATETIME, 
	updated_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id)
);
INSERT INTO payment_methods VALUES(1,2,'credit_card','VISA ending in 4242',1,'2025-04-03 10:45:55.332126','2025-04-03 10:45:55.332129');
INSERT INTO payment_methods VALUES(2,2,'paypal','user@example.com',0,'2025-04-03 10:45:55.332131','2025-04-03 10:45:55.332132');
INSERT INTO payment_methods VALUES(3,3,'bank_transfer','IBAN: ESXX XXXX XXXX XXXX XXXX',1,'2025-04-03 10:45:55.332134','2025-04-03 10:45:55.332136');

CREATE TABLE error_logs (
	id INTEGER NOT NULL, 
	user_id INTEGER, 
	session_id VARCHAR(36), 
	user_type VARCHAR(20) NOT NULL, 
	error_code INTEGER NOT NULL, 
	message VARCHAR(255) NOT NULL, 
	details TEXT, 
	url VARCHAR(255), 
	method VARCHAR(10), 
	ip_address VARCHAR(45), 
	created_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id), 
	FOREIGN KEY(session_id) REFERENCES sesiones_anonimas (id)
);
INSERT INTO error_logs VALUES(1,NULL,NULL,'anonymous',400,'Sesión anónima inválida',NULL,'http://127.0.0.1:8000/info','GET','127.0.0.1','2025-04-10 10:17:11.100311');

CREATE TABLE user_gamification (
	id INTEGER NOT NULL, 
	user_id INTEGER, 
	session_id VARCHAR(36), 
	event_type_id INTEGER NOT NULL, 
	points INTEGER, 
	badge_id INTEGER, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id), 
	FOREIGN KEY(session_id) REFERENCES sesiones_anonimas (id), 
	FOREIGN KEY(event_type_id) REFERENCES event_types (id), 
	FOREIGN KEY(badge_id) REFERENCES badges (id)
);
INSERT INTO user_gamification VALUES(1,4,NULL,5,150,8);
INSERT INTO user_gamification VALUES(2,4,NULL,6,7,NULL);
CREATE TABLE payment_providers (
	id INTEGER NOT NULL, 
	name VARCHAR(50) NOT NULL, 
	active BOOLEAN, 
	PRIMARY KEY (id), 
	UNIQUE (name)
);
INSERT INTO payment_providers VALUES(1,'stripoer',1);
INSERT INTO payment_providers VALUES(2,'credit bank',1);
INSERT INTO payment_providers VALUES(6,'checke gourmet',1);
CREATE TABLE coupons (
	id INTEGER NOT NULL, 
	name VARCHAR(100) NOT NULL, 
	description VARCHAR(255), 
	unique_identifier VARCHAR(50) NOT NULL, 
	issued_at DATETIME, 
	expires_at DATETIME, 
	redeemed_at DATETIME, 
	active BOOLEAN, 
	status VARCHAR(20), 
	credits INTEGER NOT NULL, 
	user_id INTEGER, 
	session_id VARCHAR, 
	redeemed_by_user_id INTEGER, 
	redeemed_by_session_id VARCHAR, 
	PRIMARY KEY (id), 
	UNIQUE (unique_identifier)
);
INSERT INTO coupons VALUES(4,'Recompensa Encuesta','Cupón por completar la encuesta','c0f4f4eb-30e8-4127-be23-4dc3011fbb17','2025-04-10 09:24:12.634122',NULL,NULL,1,'active',10,NULL,NULL,NULL,NULL);
INSERT INTO coupons VALUES(5,'Bienvenida','Cupón de bienvenida para usuarios anónimos','dd7ba7c4-651f-4c7a-81ee-b3149e343cf4','2025-04-10 09:24:34.576009',NULL,NULL,1,'active',5,NULL,'5277baa1-6b36-4401-b252-c12cabf33629',NULL,NULL);
INSERT INTO coupons VALUES(6,'Registrado','Cupon por registrarse','6fe9652f-cc54-4153-b05b-9226285d6dfd','2025-04-10 09:27:07.967261',NULL,NULL,1,'active',5,NULL,NULL,NULL,NULL);
INSERT INTO coupons VALUES(7,'Bienvenida','Cupón de bienvenida para usuarios anónimos','a552999a-d89e-4ff7-982d-fc20e1fc0a7a','2025-04-10 09:30:16.071504',NULL,'2025-04-10 09:31:27.034389',1,'redeemed',5,NULL,'403b50a2-e91c-4f80-88aa-86d1122c9494',NULL,'403b50a2-e91c-4f80-88aa-86d1122c9494');
INSERT INTO coupons VALUES(8,'Bienvenida','Cupón de bienvenida para usuarios anónimos','6e2b3eb4-31cf-4522-ac49-ca0ae046fa58','2025-04-10 09:44:26.320947',NULL,NULL,1,'active',5,NULL,'57d71af6-6f56-405c-8bb6-639e502397b5',NULL,NULL);
INSERT INTO coupons VALUES(9,'Recompensa Encuesta','Cupón por completar la encuesta','bf2d709c-1e69-4984-bb7f-5e1efb573c84','2025-04-10 09:58:42.233347',NULL,NULL,1,'active',10,NULL,NULL,NULL,NULL);
INSERT INTO coupons VALUES(10,'Demo Coupon','Cupón de demostración','8d2d9360-6960-4f34-adda-277cf38ab5ce','2025-04-10 10:00:03.405445',NULL,NULL,1,'active',5,NULL,NULL,NULL,NULL);
INSERT INTO coupons VALUES(11,'Bienvenida','Cupón de bienvenida para usuarios anónimos','cb6a5293-e712-49fb-8ed8-bb71a6208dc0','2025-04-10 10:02:46.013487',NULL,NULL,1,'active',5,NULL,'bfaf0269-a2ec-4100-a671-6a2ac7a52ce1',NULL,NULL);
INSERT INTO coupons VALUES(12,'Demo Coupon','Cupón de demostración','01f6fba6-b195-4533-9a60-0e163f3582c5','2025-04-10 10:03:35.236935',NULL,NULL,1,'active',5,NULL,NULL,NULL,NULL);
INSERT INTO coupons VALUES(13,'Recompensa Encuesta','Cupón por completar la encuesta','3ad3c85b-886d-48e8-b306-cdd447bb1e9c','2025-04-10 10:28:37.949055',NULL,NULL,1,'active',10,NULL,NULL,NULL,NULL);
INSERT INTO coupons VALUES(14,'Bienvenida','Cupón de bienvenida para usuarios anónimos','af5d8fc4-f4b2-4cb2-9df3-aa34c2e15f6f','2025-04-10 11:30:30.952932',NULL,NULL,1,'active',5,NULL,'20120a4b-412b-4979-b67b-c0a5d2659f1c',NULL,NULL);
CREATE TABLE api_logs (
	id INTEGER NOT NULL, 
	user_id INTEGER, 
	endpoint VARCHAR(255) NOT NULL, 
	method VARCHAR(10) NOT NULL, 
	status_code INTEGER NOT NULL, 
	request_data TEXT, 
	response_data TEXT, 
	timestamp DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES usuarios (id)
);
CREATE UNIQUE INDEX ix_usuarios_username ON usuarios (username);
CREATE INDEX ix_usuarios_id ON usuarios (id);
CREATE UNIQUE INDEX ix_usuarios_email ON usuarios (email);
CREATE INDEX ix_sesiones_anonimas_id ON sesiones_anonimas (id);
CREATE INDEX ix_event_types_id ON event_types (id);
CREATE INDEX ix_site_settings_id ON site_settings (id);
CREATE INDEX ix_allowed_origins_id ON allowed_origins (id);
CREATE INDEX ix_badges_id ON badges (id);
CREATE INDEX ix_gamification_events_id ON gamification_events (id);
CREATE INDEX ix_password_reset_tokens_id ON password_reset_tokens (id);
CREATE INDEX ix_credit_transactions_id ON credit_transactions (id);
CREATE INDEX ix_integrations_id ON integrations (id);
CREATE INDEX ix_payment_methods_id ON payment_methods (id);
CREATE INDEX ix_error_logs_id ON error_logs (id);
CREATE INDEX ix_user_gamification_id ON user_gamification (id);
CREATE INDEX ix_payment_providers_id ON payment_providers (id);
CREATE INDEX ix_coupons_id ON coupons (id);
CREATE INDEX ix_api_logs_id ON api_logs (id);
COMMIT;


¿ que deseo hacer ? en esta parte:

- crear una logica solida y robusta para inicialiar y crear la db automaticamente cuando la aplicación se ejecute por primera vez
- la nueva db que se crea en el primer arranque debe tener todas las configuraciones creadas, valores por defecto para todos los modelos,
y un usuario admin de prueba.
- si eres capaz, con lo que sabes de la app y los datos que te he pasado, aunque esten obsoletos, crea unos datos por defecto para todas las opciones.
- implanta la inicialización de la db en main

# backend/main.py
# Punto de entrada principal de la aplicación.
from api.v1 import payment_providers
from api.v1 import coupons
from models.gamification import EventType
from schemas.gamification import GamificationEventCreate, GamificationEventResponse, UserGamificationResponse
from services.gamification_service import get_user_gamification, register_event
from fastapi import Depends, FastAPI, HTTPException, Request, Depends
from fastapi.responses import JSONResponse
from sqlalchemy import text
from api.v1 import auth, endpoints, payments, site_settings, integrations, payments
from api.v1 import anonymous_sessions, credit_transactions, error_logs
from api.v1 import api_logs
from api.v1 import users
from api.v1 import gamification
from dependencies.credits import check_credits
from models.credit_transaction import CreditTransaction
from models.guests import GuestsSession
from models.user import User
from services.integration_service import trigger_webhook
from middleware.credits_middleware import require_credits
from middleware.logging import LoggingMiddleware
from dependencies.auth import UserContext, get_user_context
from services.settings_service import get_setting
from services.origin_service import get_allowed_origins
from core.database import Base, engine, get_db
from core.logging import configure_logging
from core.config import settings
from services.credits_service import reset_credits
from models.error_log import ErrorLog
from sqlalchemy.orm import Session
from fastapi.middleware.cors import CORSMiddleware
from fastapi_limiter import FastAPILimiter
from fastapi_limiter.depends import RateLimiter

app = FastAPI(
    title=settings.PROJECT_NAME,
    docs_url="/docs" if settings.ENVIRONMENT == "development" else None,
    redoc_url=None,
    #root_path="/api"
    proxy_headers=True  # Necesario para X-Forwarded-*
    #servers=[{"url": "/api", "description": "Local server"}],
    #openapi_url="/api/openapi.json",
    #swagger_ui_parameters={"url": "/api/openapi.json"}
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # En desarrollo (en producción usa dominios exactos)
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["*"]  # Añade esto para headers personalizados
)

logger = configure_logging()
# app.add_middleware(LoggingMiddleware)

# Middleware para confiar en el proxy
# app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])

db = next(get_db())
#app.add_middleware(
#    CORSMiddleware,
#    allow_origins=["*", #
#        "https://172.18.0.2:8000",
#        "https://localhost:8000",
#        "https://localhost:3000",
#        "http://localhost:8000",
#        "http://localhost:3000",
#        "https://neptuno.ciberpunk.es",
#        "http://neptuno.ciberpunk.es",
#        "127.0.0.0.1",
        #"194.164.164.177",
        #"neptuno.ciberpunk.es",
        #"172.18.0.3"
    #],  # Lista explícita de dominios permitidos
    #allow_origins=["*"], #allowed_origins = get_setting(db, "allowed_origins") or ["https://localhost:3000"]  # Valor por defecto
    #allow_credentials=True,
    #allow_methods=["*"],
#    allow_headers=["*"]
#)


Base.metadata.create_all(bind=engine)



@app.on_event("startup")
async def startup_event():

    try:
        admin_id = 1
        logger.info(f"Iniciando {settings.PROJECT_NAME} en entorno {settings.ENVIRONMENT}")
        logger.info("Ejecutando renovación de créditos automática al iniciar")
        reset_credits(db, admin_id)
    except HTTPException as e:
        logger.error(f"Error HTTP en startup: {e.detail}")
    except Exception as e:
        logger.error(f"Error inesperado en startup: {str(e)}")
    finally:
        db.close()
        
#rate_limit_auth = get_setting(db, "rate_limit_auth") or {"times": 20, "seconds": 60}
#rate_limit_api = get_setting(db, "rate_limit_api") or {"times": 100, "seconds": 60}
#rate_limit_admin = get_setting(db, "rate_limit_admin") or {"times": 50, "seconds": 60}

async def get_rate_limit_key(request: Request, user: UserContext = Depends(get_user_context)):
        if user.user_type == "registered":
            return f"user:{user.user_id}"
        return f"ip:{request.client.host}"

app.include_router(auth.router, prefix="/v1/auth", tags=["auth"])
app.include_router(users.router, prefix="/v1/users", tags=["users"])
app.include_router(endpoints.router, prefix="/v1/api", tags=["api"])
app.include_router(payments.router, prefix="/v1/payments", tags=["payments"])
app.include_router(site_settings.router, prefix="/v1/settings", tags=["site_settings"])
app.include_router(integrations.router, prefix="/v1/integrations", tags=["integrations"])
#app.include_router(payments.router, prefix="/v1/payments", tags=["payments"], dependencies=[Depends(RateLimiter(**rate_limit_api, identifier=get_rate_limit_key))])
app.include_router(error_logs.router, prefix="/v1/errors", tags=["Errors"])
app.include_router(anonymous_sessions.router, prefix="/v1/sessions", tags=["Sessions"])
app.include_router(credit_transactions.router, prefix="/v1/transactions", tags=["Transactions"])
app.include_router(api_logs.router, prefix="/v1/logs", tags=["Logs"])
app.include_router(gamification.router, prefix="/v1/gamification", tags=["Gamification"])
app.include_router(payment_providers.router, prefix="/v1/payment-providers", tags=["Payment Providers"])
app.include_router(coupons.router, prefix="/v1/coupons", tags=["Coupons"])



@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException) -> JSONResponse:
    db = next(get_db())
    try:
        logger.error(f"HTTP Error {exc.status_code} en {request.method} {request.url}: {exc.detail}")
        error_log = ErrorLog(
            error_code=exc.status_code,
            message=exc.detail,
            url=str(request.url),
            method=request.method,
            ip_address=request.client.host
        )
        db.add(error_log)
        db.commit()
    finally:
        db.close()
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": {"code": exc.status_code, "message": exc.detail}}
    )

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    db = next(get_db())
    try:
        logger.critical(f"Error inesperado en {request.method} {request.url}: {str(exc)}")
        error_log = ErrorLog(
            error_code=500,
            message="Error interno del servidor",
            details=str(exc),
            url=str(request.url),
            method=request.method,
            ip_address=request.client.host
        )
        db.add(error_log)
        db.commit()
    finally:
        db.close()
    return JSONResponse(
        status_code=500,
        content={"error": {"code": 500, "message": "Error interno del servidor"}}
    )
    
# Health check endpoint para despliegue
@app.get("/health")
async def health_check(db: Session = Depends(get_db)):
    try:
        # Ejecuta una consulta SQL simple utilizando text()
        db.execute(text("SELECT 1"))
        logger.info("Base de datos accesible")
        return {"status": "healthy", "environment": settings.ENVIRONMENT}
    except Exception as e:
        logger.error(f"Error en health check: {str(e)}")
        raise HTTPException(status_code=503, detail="Database unavailable")
    
@app.get("/")
async def root():
    return {"message": "Bienvenido a la API Backend"}

@app.get("/no-login/")
async def no_login_test(user: UserContext = Depends(check_credits), db: Session = Depends(get_db)):
    """
    Endpoint para probar la API sin necesidad de login.
    Consume créditos si están activos.
    """
    # Preparar la respuesta
    response = {"message": "Consulta realizada sin necesidad de login", "user_type": user.user_type}
    if user.user_type == "anonymous":
        response["session_id"] = user.user_id  # Incluir session_id en la respuesta

    # Consumir créditos si no están desactivados
    disable_credits = get_setting(db, "disable_credits")
    if disable_credits != "true":
        try:
            if user.user_type == "registered":
                user_db = db.query(User).filter(User.id == int(user.user_id)).first()
                user_db.credits -= 1
                transaction = CreditTransaction(
                    user_id=user_db.id,
                    user_type="registered",  # Especificar explícitamente
                    amount=-1,
                    transaction_type="usage",
                    description="Consulta realizada"
                )
                credits_remaining = user_db.credits
            else:
                session_db = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
                session_db.credits -= 1
                transaction = CreditTransaction(
                    session_id=session_db.id,
                    user_type="anonymous",  # Especificar explícitamente para claridad
                    amount=-1,
                    transaction_type="usage",
                    description="Consulta realizada por anónimo"
                )
                credits_remaining = session_db.credits
            
            db.add(transaction)
            db.commit()

            trigger_webhook(db, "credit_usage", {
                "user_id": user.user_id,
                "user_type": user.user_type,
                "credits_remaining": credits_remaining
            })
            logger.debug(f"Créditos actualizados para {user.user_type} ID {user.user_id}: {credits_remaining}")
        except Exception as e:
            logger.error(f"Error al consumir créditos para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")

    return response

@app.get("/restricted")
async def restricted_test(user: UserContext = Depends(check_credits), db: Session = Depends(get_db)):
    """
    Endpoint restringido que requiere login.
    Consume créditos si están activos.
    """
    if user.user_type != "registered":
        raise HTTPException(status_code=401, detail="Se requiere autenticación")

    # Preparar la respuesta
    response = {"message": "Consulta realizada con login", "user_type": user.user_type}

    # Consumir créditos si no están desactivados
    disable_credits = get_setting(db, "disable_credits")
    if disable_credits != "true":
        try:
            user_db = db.query(User).filter(User.id == int(user.user_id)).first()
            user_db.credits -= 1
            transaction = CreditTransaction(
                user_id=user_db.id,
                user_type="registered",  # Especificar explícitamente
                amount=-1,
                transaction_type="usage",
                description="Consulta realizada"
            )
            db.add(transaction)
            db.commit()

            trigger_webhook(db, "credit_usage", {
                "user_id": user.user_id,
                "user_type": user.user_type,
                "credits_remaining": user_db.credits
            })
            logger.debug(f"Créditos actualizados para {user.user_type} ID {user.user_id}: {user_db.credits}")
        except Exception as e:
            logger.error(f"Error al consumir créditos para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")

    return response

@app.get("/info")
async def get_info(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_anonymous = get_setting(db, "disable_anonymous_users")
    base_info = {
        "user_id": user.user_id,
        "email": user.email,
        "username": user.username,
        "user_type": user.user_type,
        "subscription": user.subscription,
        "credits": user.credits,
        "rol": user.rol,
        "session_id": user.session_id if user.user_type == "anonymous" else None
    }

    gamification = get_user_gamification(db, user)
    gamification_data = [
        UserGamificationResponse.from_orm(g) for g in gamification
    ]

    return {**base_info, "gamification": gamification_data}


@app.post("/test-event", response_model=GamificationEventResponse)
def test_gamification_event(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    event_type = db.query(EventType).filter(EventType.name == "test_api").first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type 'test_api' not found")
    event = GamificationEventCreate(event_type_id=event_type.id)
    return register_event(db, event, user)



Si necesitas más ayuda o necesitas código adicional que ver, no dudes en decírmelo. A ver como te desenvuelves con mi software.

Se que es muchiiiisima información, por favor leela toda con detenimiento. Si es mucho separa tu respuesta en partes. Solicitame los archivos que necesites ver. 


Respeta la logica actual para no romper ningun servicio activo. 
Es importante esta parte que salga bien, tomate tu tiempo.
Pideme los archivos que necesites ver para una mejor implantación.
Si te parece mejor por motivos de capacidad generame la respuesta en varias partes, lo dejo a tu elección.

Explica cada paso para que yo aprenda a implantar mis propios modulos.

Recuerda generar codigo completo.


Ya puedes proceder paso a paso con tu respuesta.




