Aqui tienes los archivos solicitados:

# backend/api/v1/auth.py
# Módulo de autenticación de la API v1.

from fastapi import APIRouter, Depends, HTTPException, Request
from sqlalchemy.orm import Session
from services.settings_service import get_setting
from schemas.auth import (ChangePasswordRequest, PasswordResetConfirm,
                          TokenResponse, RefreshTokenRequest,
                          PasswordResetRequest)
from schemas.user import RegisterRequest
from services.auth_service import (login_user, register_user,
                                   refresh_access_token, logout_user,
                                   request_password_reset,
                                   confirm_password_reset,
                                   change_user_password, login_with_provider)
from core.database import get_db
from core.security import oauth2_scheme, OAuth2PasswordRequestForm
from core.security import get_oauth2_redirect_url
from dependencies.auth import UserContext, get_user_context
from core.logging import configure_logging

router = APIRouter(tags=["auth"])
logger = configure_logging()


@router.post("/token", response_model=TokenResponse)
def login_for_access_token(request: Request,
                           form_data: OAuth2PasswordRequestForm = Depends(),
                           db: Session = Depends(get_db)):
    try:
        ip = request.client.host
        return login_user(db, form_data.username, form_data.password, ip)
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(
            f"Error inesperado en login desde IP {request.client.host}: {str(e)}"
        )
        raise HTTPException(status_code=500,
                            detail="Error al procesar el login")


@router.post("/register", response_model=TokenResponse)
def register(data: RegisterRequest, db: Session = Depends(get_db)):
    enable_registration = get_setting(db, "enable_registration")
    if enable_registration != "true":
        raise HTTPException(
            status_code=403,
            detail="El registro de nuevos usuarios está deshabilitado")
    return register_user(db, data.email, data.username, data.password)


@router.post("/password-reset", response_model=dict)
def reset_password(data: PasswordResetRequest, db: Session = Depends(get_db)):
    return request_password_reset(db, data.email)


@router.post("/password-reset/confirm", response_model=dict)
def confirm_password_reset(data: PasswordResetConfirm,
                           db: Session = Depends(get_db)):
    return confirm_password_reset(db, data.token, data.new_password)


@router.post("/refresh", response_model=TokenResponse)
def refresh_token(request: Request,
                  data: RefreshTokenRequest,
                  db: Session = Depends(get_db)):
    try:
        logger.info(
            f"Intento de refresco de token desde IP {request.client.host}")
        result = refresh_access_token(db, data.refresh_token)
        logger.info("Refresco de token exitoso")
        return result
    except HTTPException as e:
        logger.error(f"Error al refrescar token: {e.detail}")
        raise
    except Exception as e:
        logger.critical(f"Error inesperado en refresh_token: {str(e)}",
                        exc_info=True)
        raise HTTPException(status_code=500,
                            detail="Error interno del servidor")


@router.post("/logout", response_model=dict)
def logout(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):
    return logout_user(db, token)


@router.get("/login/{provider}", response_model=dict)
def get_provider_login_url(provider: str, db: Session = Depends(get_db)):
    enable_social_login = get_setting(
        db, "enable_social_login")  # comprobar he tenido que meter db
    if enable_social_login != "true":
        raise HTTPException(status_code=403,
                            detail="El login social está deshabilitado")

    try:
        redirect_url = get_oauth2_redirect_url(provider)
        return {"redirect_url": redirect_url}
    except ValueError:
        raise HTTPException(status_code=400, detail="Proveedor no soportado")


@router.post("/login/{provider}/callback", response_model=TokenResponse)
def provider_callback(provider: str,
                      code: str,
                      request: Request,
                      db: Session = Depends(get_db)):
    ip = request.client.host
    return login_with_provider(db, provider, code, ip)


@router.put("/me/password", response_model=dict)
def change_password(data: ChangePasswordRequest,
                    user: UserContext = Depends(get_user_context),
                    db: Session = Depends(get_db)):
    if user.user_type != "registered":
        raise HTTPException(
            status_code=403,
            detail="Solo usuarios registrados pueden cambiar su contraseña")
    return change_user_password(db, int(user.user_id), data.current_password,
                                data.new_password)


# backend/core/security.py
# Usar OAuth2 con Password Flow para autenticación segur

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from oauthlib.oauth2 import WebApplicationClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jwt import encode, decode, PyJWTError
from os import getenv
from datetime import datetime, timedelta
from typing import Optional
from core.logging import configure_logging
from core.database import get_db
from services.settings_service import get_setting

logger = configure_logging()

# Configuración de OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/v1/auth/token")
google_client = WebApplicationClient(getenv("GOOGLE_CLIENT_ID"))
meta_client = WebApplicationClient(getenv("META_CLIENT_ID"))

# Configuración de hash de contraseñas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_token(user_id: str, user_type: str = "registered"):
    payload = {
        "sub": str(user_id),
        "type": user_type,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, getenv("SECRET_KEY"), algorithm="HS256")

def decode_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, getenv("SECRET_KEY"), algorithms=["HS256"])
        # Validación adicional del payload
        if not payload.get("sub") or not payload.get("type"):
            logger.warning(f"Token inválido: falta sub o type en el payload")
            return None
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token expirado")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Token inválido: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Error inesperado al decodificar token: {str(e)}")
        return None

def create_access_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "token_expiration") or "3600")
        if expiration < 300:  # Mínimo 5 minutos
            expiration = 3600
            logger.warning("Token expiration too low, using default 1h")
    except Exception as e:
        logger.error(f"Error token_expiration: {str(e)}")
        expiration = 3600
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

def create_refresh_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "refresh_token_expiration") or "604800")
        if expiration < 86400:  # Mínimo 1 día
            expiration = 604800
            logger.warning("Refresh token expiration too low, using default 7d")
    except Exception as e:
        logger.error(f"Error refresh_token_expiration: {str(e)}")
        expiration = 604800
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")


def create_refresh_token(data: dict):
    db = next(get_db())
    expiration_str = get_setting(db, "refresh_token_expiration") or "604800"  # Valor por defecto: 7 días
    try:
        expiration = int(str(expiration_str))  # Convertir a cadena primero y luego a entero
    except ValueError:
        logger.error(f"Valor inválido para refresh_token_expiration: {expiration_str}")
        expiration = 604800  # Valor por defecto si falla
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

    
def get_oauth2_redirect_url(provider: str) -> str:
    if provider == "google":
        return google_client.prepare_request_uri(
            "https://accounts.google.com/o/oauth2/v2/auth",
            redirect_uri=getenv("GOOGLE_REDIRECT_URI"),
            scope=["openid", "email", "profile"]
        )
    elif provider == "meta":
        return meta_client.prepare_request_uri(
            "https://www.facebook.com/v13.0/dialog/oauth",
            redirect_uri=getenv("META_REDIRECT_URI"),
            scope=["email"]
        )
    raise ValueError("Proveedor no soportado")

# backend/dependencies/auth.py
from fastapi import Depends, HTTPException, Request
from sqlalchemy.orm import Session
from core.database import get_db
from models.user import User, UserTypeEnum
from core.security import decode_token
from core.logging import configure_logging
from pydantic import BaseModel
from fastapi import Response
import random
import string
from datetime import datetime
from uuid import uuid4

logger = configure_logging()


class UserContext(BaseModel):
    user_type: str  # "registered" o "anonymous"
    user_id: str
    email: str
    username: str
    credits: int
    subscription: str
    rol: str

    class Config:
        from_attributes = True

def generate_unique_username(db: Session) -> str:
    while True:
        random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        username = f"Guest_{random_chars}"
        if not db.query(User).filter(User.username == username).first():
            return username


async def get_user_context(request: Request, response: Response, db: Session = Depends(get_db)):
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
    client_ip = request.client.host
    logger.info(f"Procesando solicitud: token={bool(token)}, ip={client_ip}")

    try:
        if token:
            # Usuario registrado
            payload = decode_token(token)
            if not payload or payload.get("type") != "access":
                logger.error(f"Token inválido recibido desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token inválido o no es de acceso")
            user = db.query(User).filter(User.id == int(payload["sub"])).first()
            if not user:
                logger.error(f"Usuario no encontrado para token desde IP {client_ip}")
                raise HTTPException(status_code=404, detail="Usuario no encontrado")
            if not user.activo:
                logger.warning(f"Intento de acceso con usuario inactivo ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=403, detail="Usuario inactivo")
            
            user.last_ip = client_ip
            user.last_login = datetime.utcnow()
            db.commit()
            logger.info(f"Usuario registrado ID {user.id} autenticado desde IP {client_ip}")
            return UserContext(
                user_type=user.type.value,
                user_id=str(user.id),
                email=user.email or "anonymous@example.com",
                username=user.username,
                credits=user.credits,
                subscription=user.subscription.value,
                rol=user.rol
            )
        else:
            # Usuario anónimo
            user_id_raw = request.headers.get("X-User-ID")
            if user_id_raw:
                try:
                    user_id = int(user_id_raw)
                    user = db.query(User).filter(User.id == user_id).first()
                except ValueError:
                    user = None  # ID inválido, crearemos uno nuevo
            else:
                user = None

            if not user:
                logger.info(f"Creando nuevo usuario anónimo desde IP {client_ip}")
                username = generate_unique_username(db)
                new_user = User(
                    type=UserTypeEnum.ANONYMOUS,
                    username=username,
                    credits=10,
                    create_at=datetime.utcnow(),
                    last_ip=client_ip
                )
                db.add(new_user)
                db.commit()
                db.refresh(new_user)
                user = new_user
            
            response.headers["X-User-ID"] = str(user.id)
            logger.info(f"Usuario anónimo ID {user.id} procesado desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=str(user.id),
                email="anonymous@example.com",
                username=user.username,
                credits=user.credits,
                subscription="freemium",
                rol="anonymous"
            )

    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en get_user_context desde IP {client_ip}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar la autenticación")

# backend/dependencies/credits.py
from fastapi import Depends, HTTPException
from sqlalchemy.orm import Session
from models.credit_transaction import CreditTransaction
from dependencies.auth import UserContext, get_user_context
from models.user import User
# from models.guests import GuestsSession
from core.database import get_db
from core.logging import configure_logging
from services.integration_service import trigger_webhook
from services.settings_service import get_setting

logger = configure_logging()

async def check_credits(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_credits = get_setting(db, "disable_credits")
    
    if disable_credits != "true":  # Solo procesar créditos si no están desactivados
        try:
            if user.user_type == "registered":
                user_db = db.query(User).filter(User.id == int(user.user_id)).first()
                if not user_db:
                    raise HTTPException(status_code=404, detail="Usuario no encontrado")
                credits = user_db.credits
            else:
                session_db = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
                if not session_db:
                    raise HTTPException(status_code=404, detail="Sesión no encontrada")
                credits = session_db.credits

            if credits <= 0:
                logger.warning(f"Usuario {user.user_type} ID {user.user_id} sin créditos suficientes")
                raise HTTPException(status_code=403, detail="No te quedan créditos disponibles.")
            
            return user  # Retorna el usuario para usarlo en el endpoint
        except HTTPException as e:
            raise e
        except Exception as e:
            logger.error(f"Error inesperado en check_credits para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")
    return user  # Si los créditos están desactivados, simplemente retorna el usuario

# backend/models/user.py
from datetime import datetime
from sqlalchemy import Column, Integer, String, DateTime, Boolean, Enum
from sqlalchemy.orm import relationship
from core.database import Base
import enum

class UserTypeEnum(enum.Enum):
    REGISTERED = "registered"
    ANONYMOUS = "anonymous"

class subscriptionEnum(enum.Enum):
    FREEMIUM = "freemium"
    PREMIUM = "premium"
    CORPORATE = "corporate"

class User(Base):
    __tablename__ = "usuarios"
    
    id = Column(Integer, primary_key=True, index=True)
    type = Column(Enum(UserTypeEnum), default=UserTypeEnum.ANONYMOUS, nullable=False)  # Nuevo campo
    email = Column(String(255), unique=True, index=True, nullable=True)  # Opcional para anónimos
    username = Column(String(50), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=True)  # Opcional para anónimos
    auth_provider = Column(String(20), nullable=True)  # "local", "google", "meta", etc.
    provider_id = Column(String(255), nullable=True)  # ID único del proveedor
    rol = Column(String(20), default="user")  # "user" o "admin"
    activo = Column(Boolean, default=True)  # Estado de la cuenta
    subscription = Column(Enum(subscriptionEnum), default=subscriptionEnum.FREEMIUM)
    website = Column(String(255), nullable=True)
    credits = Column(Integer, default=10)  # Créditos disponibles
    ciudad = Column(String(100), nullable=True)
    create_at = Column(DateTime, default=datetime.utcnow)
    renewal = Column(DateTime, nullable=True)
    last_ip = Column(String(45), nullable=True)
    last_login = Column(DateTime, nullable=True)
    token_valid_until = Column(DateTime, nullable=True)

    # Relaciones
    gamification_events = relationship("GamificationEvent", back_populates="user")
    gamification = relationship("UserGamification", back_populates="user")
    coupons = relationship("Coupon", foreign_keys="Coupon.user_id", back_populates="user")

# backend/services/user_service.py
from sqlalchemy.orm import Session
from models.user import User
from fastapi import HTTPException

def get_user_info(db: Session, user_id: int):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    return user

def update_user(db: Session, user_id: int, email: str = None, username: str = None, ciudad: str = None, website: str = None):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    if email and email != user.email:
        existing_email = db.query(User).filter(User.email == email).first()
        if existing_email:
            raise HTTPException(status_code=400, detail="El email ya está en uso")
        user.email = email
    
    if username and username != user.username:
        existing_username = db.query(User).filter(User.username == username).first()
        if existing_username:
            raise HTTPException(status_code=400, detail="El username ya está en uso")
        user.username = username
    
    if ciudad is not None:
        user.ciudad = ciudad
    if website is not None:
        user.website = website
    
    db.commit()
    db.refresh(user)
    return user

def delete_user(db: Session, user_id: int):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    db.delete(user)
    db.commit()
    return {"message": "Usuario eliminado"}

def list_users(db: Session):
    return db.query(User).all()

# backend/schemas/user.py
from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class RegisterRequest(BaseModel):
    email: EmailStr
    username: str
    password: str
    ciudad: Optional[str] = None
    website: Optional[str] = None

class UpdateProfileRequest(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    ciudad: Optional[str] = None
    website: Optional[str] = None

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    username: str
    rol: str
    activo: bool
    subscription: str  # Esto funciona porque Pydantic automáticamente usa el .value de los Enum
    ciudad: Optional[str] = None
    website: Optional[str] = None
    credits: int
    create_at: datetime
    last_ip: Optional[str] = None

    class Config:
        from_attributes = True  # Esto reemplaza a orm_mode = True en Pydantic v2

// src/lib/types.ts
export interface User {
  id: number;
  email: string;
  username: string;
  rol: string;
  activo: boolean;
  subscription: string;
  ciudad?: string;
  website?: string;
  credits: number;
  create_at: string;  // ISO string (e.g., "2023-10-01T12:00:00Z")
  last_ip?: string;
  last_login: string;
  user_type: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}



export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  ciudad?: string;
  website?: string;
}

export interface UpdateProfileRequest {
  email?: string;
  username?: string;
  ciudad?: string;
  website?: string;
}

export interface PurchaseRequest {
  credits: number;
  payment_amount: number;
  payment_method?: string;
}

export interface PurchaseResponse {
  transaction_id: string;
  credits_added: number;
  new_balance: number;
}

export interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
  created_at: string;  // ISO string
  updated_at: string;  // ISO string
}

export interface HTTPValidationError {
  detail: ValidationError[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status?: string;
  timestamp: string; // ISO string
}

export interface Integration {
  user_id: number;
  id: number;
  name: string;
  webhook_url: string;
  event_type: string;
  active: boolean;
  created_at: string;
  last_triggered: string | null;
}

export interface SiteSetting {
    id: number;
    key: string;
    value: string;
    description?: string;
    tag?: string;
    updated_by?: number;
    updated_at: string; // ISO string
}

export interface FetchResponse<T> {
  data: T | null;
  error: string | HTTPValidationError | null;
  total_pages?: number;
}

// src/lib/types.ts
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string;
  gamification: UserGamificationResponse[]; // Actualizado para reflejar /info
}

export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[];
}

export interface GamificationEventCreate {
  event_type_id: number;
}

export interface GamificationEventResponse {
  id: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  timestamp: string; // ISO string
}

export interface UserGamificationResponse {
  points: number;
  badge_id?: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  event_type: EventType;
  badge?: Badge;
}
export interface RankingResponse {
  username: string;
  points: number;
  badges_count: number;
  user_type: string;
}

export interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}



export interface InfoResponse {
  credits: number;
  gamification: { points: number; badge: Badge | null }[];
}


export interface BadgeWithEventType extends Badge {
  event_type: EventType;
}


// src/lib/types.ts

// Nuevo tipo para cupones
export interface Coupon {
  id: number;
  name: string;
  description?: string;
  unique_identifier: string;
  issued_at: string; // ISO string
  expires_at?: string; // ISO string, opcional
  redeemed_at?: string; // ISO string, opcional
  active: boolean;
  status: "active" | "redeemed" | "expired" | "disabled";
  credits: number;
  user_id?: number; // Opcional, para usuarios registrados
  session_id?: string; // Opcional, para usuarios anónimos
  redeemed_by_user_id?: number; // Quién lo canjeó, si aplica
  redeemed_by_session_id?: string; // Quién lo canjeó (anónimo), si aplica
}



export interface CouponType {
  id: number;
  name: string;
  description?: string;
  credits: number;
  active: boolean;
}

"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, Gamification, Badge, Coupon } from "../types";
import { motion } from "framer-motion";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null;
  coupons: Coupon[];
  setCredits: (credits: number) => void;
  setCoupons: (coupons: Coupon[]) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  setGamification: (gamification: Gamification) => void;
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(10); // Valor por defecto
  const [gamification, setGamification] = useState<Gamification | null>(null);
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const [coupons, setCoupons] = useState<Coupon[]>([]);

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<any>("/info");
        if (data) {
          const userData: User = {
            id: parseInt(data.user_id),
            email: data.email || "",
            username: data.username || `Guest_${data.user_id}`,
            rol: data.rol || "user",
            activo: data.activo ?? true,
            subscription: data.subscription || "free",
            credits: data.credits || 0,
            create_at: data.create_at || "",
            last_ip: data.last_ip || "",
            last_login: data.last_login || "",
            user_type: data.user_type || "anonymous",
          };

          setUser(userData);
          setCredits(data.credits || 0);

          // Obtener datos de gamificación
          const gamificationRes = await fetchAPI<any[]>("/v1/gamification/me");
          if (gamificationRes.data) {
            const totalPoints = gamificationRes.data.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationRes.data.map(g => g.badge).filter(Boolean) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }

          // Obtener cupones del usuario
          const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/me");
          setCoupons(couponsRes.data || []);
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        setCoupons([]);
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    setUser(null);
    setCredits(0);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true })
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits, gamification, coupons, setCoupons, setGamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

# backend/main.py
# Punto de entrada principal de la aplicación.
from api.v1 import payment_providers
from api.v1 import coupons
from api.v1 import test
from api.v1 import origins
from ini_db import init_db, init_settings_and_users
from models.gamification import EventType
from schemas.gamification import GamificationEventCreate, GamificationEventResponse, UserGamificationResponse
from services.gamification_service import get_user_gamification, register_event
from fastapi import Depends, FastAPI, HTTPException, Request, Depends
from fastapi.responses import JSONResponse
from sqlalchemy import text
from api.v1 import auth, payments, site_settings, integrations, payments
from api.v1 import anonymous_sessions, credit_transactions, error_logs
from api.v1 import api_logs
from api.v1 import users
from api.v1 import gamification
from dependencies.credits import check_credits
from models.credit_transaction import CreditTransaction
# from models.guests import GuestsSession
from models.user import User
from services.integration_service import trigger_webhook
from middleware.credits_middleware import require_credits
from middleware.logging import LoggingMiddleware
from dependencies.auth import UserContext, get_user_context
from services.settings_service import get_setting
from services.origin_service import get_allowed_origins
from core.database import Base, engine, get_db
from core.logging import configure_logging
from core.config import settings
from services.credits_service import reset_credits
from models.error_log import ErrorLog
from sqlalchemy.orm import Session
from fastapi.middleware.cors import CORSMiddleware
from fastapi_limiter import FastAPILimiter
from fastapi_limiter.depends import RateLimiter

app = FastAPI(
    title=settings.PROJECT_NAME,
    docs_url="/docs" if settings.ENVIRONMENT == "development" else None,
    redoc_url=None,
    #root_path="/api"
    proxy_headers=True  # Necesario para X-Forwarded-*
    #servers=[{"url": "/api", "description": "Local server"}],
    #openapi_url="/api/openapi.json",
    #swagger_ui_parameters={"url": "/api/openapi.json"}
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # En desarrollo (en producción usa dominios exactos)
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["*"]  # Añade esto para headers personalizados
)

#def configure_cors():
#    db = next(get_db())
#    allowed_origins_enabled = get_setting(db, "allowed_origins") == "true"
#    origins = [origin.origin for origin in db.query(AllowedOrigin).all()] if allowed_origins_enabled else ["*"]
#    app.add_middleware(
#        CORSMiddleware,
#        allow_origins=origins,
#        allow_credentials=True,
#        allow_methods=["*"],
#        allow_headers=["*"],
#    )#
#configure_cors()

logger = configure_logging()
# app.add_middleware(LoggingMiddleware)

# Middleware para confiar en el proxy
# app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])

db = next(get_db())
#app.add_middleware(
#    CORSMiddleware,
#    allow_origins=["*", #
#        "https://172.18.0.2:8000",
#        "https://localhost:8000",
#        "https://localhost:3000",
#        "http://localhost:8000",
#        "http://localhost:3000",
#        "https://neptuno.ciberpunk.es",
#        "http://neptuno.ciberpunk.es",
#        "127.0.0.0.1",
        #"194.164.164.177",
        #"neptuno.ciberpunk.es",
        #"172.18.0.3"
    #],  # Lista explícita de dominios permitidos
    #allow_origins=["*"], #allowed_origins = get_setting(db, "allowed_origins") or ["https://localhost:3000"]  # Valor por defecto
    #allow_credentials=True,
    #allow_methods=["*"],
#    allow_headers=["*"]
#)


#Base.metadata.create_all(bind=engine)



@app.on_event("startup")
async def startup_event():
    init_db()  # Crea las tablas si no existen
    init_settings_and_users()  # Pobla con datos iniciales si es necesario
    
    try:
        admin_id = 1
        logger.info(f"Iniciando {settings.PROJECT_NAME} en entorno {settings.ENVIRONMENT}")
        logger.info("Ejecutando renovación de créditos automática al iniciar")
        reset_credits(db, admin_id)
    except HTTPException as e:
        logger.error(f"Error HTTP en startup: {e.detail}")
    except Exception as e:
        logger.error(f"Error inesperado en startup: {str(e)}")
    finally:
        db.close()
        
#rate_limit_auth = get_setting(db, "rate_limit_auth") or {"times": 20, "seconds": 60}
#rate_limit_api = get_setting(db, "rate_limit_api") or {"times": 100, "seconds": 60}
#rate_limit_admin = get_setting(db, "rate_limit_admin") or {"times": 50, "seconds": 60}

async def get_rate_limit_key(request: Request, user: UserContext = Depends(get_user_context)):
        if user.user_type == "registered":
            return f"user:{user.user_id}"
        return f"ip:{request.client.host}"

app.include_router(auth.router, prefix="/v1/auth", tags=["auth"])
app.include_router(users.router, prefix="/v1/users", tags=["users"])
app.include_router(test.router, prefix="/v1/test", tags=["test"])
app.include_router(payments.router, prefix="/v1/payments", tags=["payments"])
app.include_router(site_settings.router, prefix="/v1/settings", tags=["site_settings"])
app.include_router(integrations.router, prefix="/v1/integrations", tags=["integrations"])
#app.include_router(payments.router, prefix="/v1/payments", tags=["payments"], dependencies=[Depends(RateLimiter(**rate_limit_api, identifier=get_rate_limit_key))])
app.include_router(error_logs.router, prefix="/v1/errors", tags=["Errors"])
app.include_router(anonymous_sessions.router, prefix="/v1/sessions", tags=["Sessions"])
app.include_router(credit_transactions.router, prefix="/v1/transactions", tags=["Transactions"])
app.include_router(api_logs.router, prefix="/v1/logs", tags=["Logs"])
app.include_router(gamification.router, prefix="/v1/gamification", tags=["Gamification"])
app.include_router(payment_providers.router, prefix="/v1/payment-providers", tags=["Payment Providers"])
app.include_router(coupons.router, prefix="/v1/coupons", tags=["Coupons"])
app.include_router(origins.router, prefix="/v1/origins", tags=["Origins"])



@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException) -> JSONResponse:
    db = next(get_db())
    try:
        logger.error(f"HTTP Error {exc.status_code} en {request.method} {request.url}: {exc.detail}")
        error_log = ErrorLog(
            error_code=exc.status_code,
            message=exc.detail,
            url=str(request.url),
            method=request.method,
            ip_address=request.client.host
        )
        db.add(error_log)
        db.commit()
    finally:
        db.close()
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": {"code": exc.status_code, "message": exc.detail}}
    )

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    db = next(get_db())
    try:
        logger.critical(f"Error inesperado en {request.method} {request.url}: {str(exc)}")
        error_log = ErrorLog(
            error_code=500,
            message="Error interno del servidor",
            details=str(exc),
            url=str(request.url),
            method=request.method,
            ip_address=request.client.host
        )
        db.add(error_log)
        db.commit()
    finally:
        db.close()
    return JSONResponse(
        status_code=500,
        content={"error": {"code": 500, "message": "Error interno del servidor"}}
    )
    
# Health check endpoint para despliegue
@app.get("/health")
async def health_check(db: Session = Depends(get_db)):
    try:
        # Ejecuta una consulta SQL simple utilizando text()
        db.execute(text("SELECT 1"))
        logger.info("Base de datos accesible")
        return {"status": "healthy", "environment": settings.ENVIRONMENT}
    except Exception as e:
        logger.error(f"Error en health check: {str(e)}")
        raise HTTPException(status_code=503, detail="Database unavailable")
    
@app.get("/")
async def root():
    return {"message": "Bienvenido a la API Backend"}

@app.get("/test/no-login/")
async def no_login_test(user: UserContext = Depends(check_credits), db: Session = Depends(get_db)):
    response = {"message": "Consulta realizada sin necesidad de login", "user_type": user.user_type}

    disable_credits = get_setting(db, "disable_credits")
    if disable_credits != "true":
        try:
            user_db = db.query(User).filter(User.id == int(user.user_id)).first()
            user_db.credits -= 1
            transaction = CreditTransaction(
                user_id=user_db.id,
                user_type=user.user_type,
                amount=-1,
                transaction_type="usage",
                description="Consulta realizada"
            )
            db.add(transaction)
            db.commit()

            trigger_webhook(db, "credit_usage", {
                "user_id": user.user_id,
                "user_type": user.user_type,
                "credits_remaining": user_db.credits
            })
            logger.debug(f"Créditos actualizados para {user.user_type} ID {user.user_id}: {user_db.credits}")
        except Exception as e:
            logger.error(f"Error al consumir créditos para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")

    return response


@app.get("/test/restricted")
async def restricted_test(user: UserContext = Depends(check_credits), db: Session = Depends(get_db)):
    """
    Endpoint restringido que requiere login.
    Consume créditos si están activos.
    """
    if user.user_type != "registered":
        raise HTTPException(status_code=401, detail="Se requiere autenticación")

    # Preparar la respuesta
    response = {"message": "Consulta realizada con login", "user_type": user.user_type}

    # Consumir créditos si no están desactivados
    disable_credits = get_setting(db, "disable_credits")
    if disable_credits != "true":
        try:
            user_db = db.query(User).filter(User.id == int(user.user_id)).first()
            user_db.credits -= 1
            transaction = CreditTransaction(
                user_id=user_db.id,
                user_type="registered",  # Especificar explícitamente
                amount=-1,
                transaction_type="usage",
                description="Consulta realizada"
            )
            db.add(transaction)
            db.commit()

            trigger_webhook(db, "credit_usage", {
                "user_id": user.user_id,
                "user_type": user.user_type,
                "credits_remaining": user_db.credits
            })
            logger.debug(f"Créditos actualizados para {user.user_type} ID {user.user_id}: {user_db.credits}")
        except Exception as e:
            logger.error(f"Error al consumir créditos para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")

    return response

@app.get("/info")
async def get_info(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_anonymous = get_setting(db, "disable_anonymous_users")
    if disable_anonymous == "true" and user.user_type == "anonymous":
        raise HTTPException(status_code=403, detail="Usuarios anónimos están deshabilitados")

    base_info = {
        "user_id": user.user_id,
        "email": user.email,
        "username": user.username,
        "user_type": user.user_type,
        "subscription": user.subscription,
        "credits": user.credits,
        "rol": user.rol
    }

    gamification = get_user_gamification(db, user)
    gamification_data = [
        UserGamificationResponse.from_orm(g) for g in gamification
    ]

    return {**base_info, "gamification": gamification_data}
    
#@app.get("/info")
#async def get_info(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
#    disable_anonymous = get_setting(db, "disable_anonymous_users")
#    base_info = {
###        "user_id": user.user_id,
#        "email": user.email,
#        "username": user.username,
#        "user_type": user.user_type,
#        "subscription": user.subscription,
#        "credits": user.credits,
#        "rol": user.rol,
#        "session_id": user.session_id if user.user_type == "anonymous" else None
#    }

    gamification = get_user_gamification(db, user)
    gamification_data = [
        UserGamificationResponse.from_orm(g) for g in gamification
    ]

    return {**base_info, "gamification": gamification_data}


@app.post("/test-event", response_model=GamificationEventResponse)
def test_gamification_event(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    event_type = db.query(EventType).filter(EventType.name == "test_api").first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type 'test_api' not found")
    event = GamificationEventCreate(event_type_id=event_type.id)
    return register_event(db, event, user)

def configure_cors():
    db = next(get_db())
    try:
        allowed_origins_enabled = get_setting(db, "allowed_origins") == "true"
        origins = get_allowed_origins(db) if allowed_origins_enabled else ["*"]
        app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"], # origins,
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        logger.info(f"CORS configurado con orígenes: {origins}")
    except Exception as e:
        logger.error(f"Error al configurar CORS: {str(e)}")
    finally:
        db.close()

configure_cors()

adapta la carga de datos iniciales a la nueva situación con los users:

import uuid
from datetime import datetime, timedelta
from sqlalchemy.orm import Session
from sqlalchemy.orm import sessionmaker
from core.database import SessionLocal, Base, engine
from models.site_settings import SiteSettings
from models.user import User, subscriptionEnum
from models.allowed_origin import AllowedOrigin
from models.credit_transaction import CreditTransaction
from models.error_log import ErrorLog
from models.integration import Integration
from models.log import APILog
from models.payment_method import PaymentMethod
from models.gamification import EventType, Badge, GamificationEvent, UserGamification
# from models.guests import GuestsSession
from models.token import RevokedToken, PasswordResetToken
from models.coupon import Coupon
from models.coupon_type import CouponType
from models.payment_provider import PaymentProvider
from core.security import hash_password
import json


def init_db():
    """Crea todas las tablas en la base de datos"""
    Base.metadata.create_all(bind=engine)


def init_settings_and_users():
    """Pobla la base de datos con datos iniciales si está vacía."""
    Session = sessionmaker(bind=engine)
    db = Session()
    try:
        # Verificar si la base de datos ya tiene datos
        if db.query(User).first():
            print(
                "La base de datos ya está poblada. No se realizarán cambios.")
            return

        # Configuraciones iniciales en site_settings
        settings_data = [
            {
                "key": "token_expiration",
                "value": 3600,
                "description": "Tiempo de vida del access token (segundos)",
                "tag": "auth"
            },
            {
                "key": "refresh_token_expiration",
                "value": 604800,
                "description": "Tiempo de vida del refresh token (7 días)",
                "tag": "auth"
            },
            {
                "key": "max_login_attempts",
                "value": 5,
                "description": "Máximo de intentos de login antes de bloqueo",
                "tag": "auth"
            },
            {
                "key": "rate_limit_auth",
                "value": {
                    "times": 20,
                    "seconds": 60
                },
                "description": "Límite de peticiones para auth",
                "tag": "rate_limit"
            },
            {
                "key": "rate_limit_api",
                "value": {
                    "times": 100,
                    "seconds": 60
                },
                "description": "Límite de peticiones para API",
                "tag": "rate_limit"
            },
            {
                "key": "rate_limit_admin",
                "value": {
                    "times": 50,
                    "seconds": 60
                },
                "description": "Límite de peticiones para admin",
                "tag": "rate_limit"
            },
            {
                "key": "cache_ttl",
                "value": 300,
                "description": "Tiempo de vida del caché en Redis (segundos)",
                "tag": "cache"
            },
            {
                "key": "cache_enabled",
                "value": True,
                "description": "Habilitar/deshabilitar el caché",
                "tag": "cache"
            },
            {
                "key": "cache_max_size",
                "value": 10000,
                "description": "Tamaño máximo del caché en entradas",
                "tag": "cache"
            },
            {
                "key": "allowed_origins",
                "value": True,
                "description":
                "Activar/desactivar orígenes permitidos para CORS",
                "tag": "cors"
            },
            {
                "key": "cors_enabled",
                "value": True,
                "description": "Habilitar/deshabilitar CORS",
                "tag": "cors"
            },
            {
                "key": "celery_workers",
                "value": 4,
                "description": "Número de workers de Celery",
                "tag": "celery"
            },
            {
                "key": "celery_task_timeout",
                "value": 300,
                "description":
                "Tiempo máximo de ejecución de tareas Celery (segundos)",
                "tag": "celery"
            },
            {
                "key": "celery_max_retries",
                "value": 3,
                "description": "Máximo de reintentos para tareas Celery",
                "tag": "celery"
            },
            {
                "key": "db_pool_size",
                "value": 20,
                "description": "Tamaño del pool de conexiones a la DB",
                "tag": "database"
            },
            {
                "key": "db_max_overflow",
                "value": 10,
                "description": "Conexiones adicionales permitidas en el pool",
                "tag": "database"
            },
            {
                "key": "db_pool_timeout",
                "value": 30,
                "description":
                "Tiempo de espera para una conexión del pool (segundos)",
                "tag": "database"
            },
            {
                "key": "freemium_credits",
                "value": 100,
                "description": "Créditos iniciales para suscripción freemium",
                "tag": "credits"
            },
            {
                "key": "premium_credits",
                "value": 1000,
                "description": "Créditos iniciales para suscripción premium",
                "tag": "credits"
            },
            {
                "key": "corporate_credits",
                "value": 5000,
                "description":
                "Créditos iniciales para suscripción corporativa",
                "tag": "credits"
            },
            {
                "key": "credit_reset_interval",
                "value": 30,
                "description": "Intervalo de reinicio de créditos (días)",
                "tag": "credits"
            },
            {
                "key": "log_level",
                "value": "INFO",
                "description": "Nivel de logging",
                "tag": "logging"
            },
            {
                "key": "log_retention_days",
                "value": 90,
                "description": "Días de retención de logs",
                "tag": "logging"
            },
            {
                "key": "maintenance_mode",
                "value": False,
                "description": "Activar/desactivar modo mantenimiento",
                "tag": "system"
            },
            {
                "key": "api_version",
                "value": "1.0.0",
                "description": "Versión actual de la API",
                "tag": "system"
            },
            {
                "key": "enable_registration",
                "value": True,
                "description": "Activar/desactivar registro de usuarios",
                "tag": "features"
            },
            {
                "key": "enable_social_login",
                "value": True,
                "description": "Activar/desactivar login social",
                "tag": "features"
            },
            {
                "key": "disable_anonymous_users",
                "value": False,
                "description": "Desactivar usuarios anónimos",
                "tag": "features"
            },
            {
                "key": "disable_credits",
                "value": False,
                "description": "Desactivar sistema de créditos",
                "tag": "features"
            },
            {
                "key": "enable_payment_methods",
                "value": True,
                "description": "Activar métodos de pago",
                "tag": "features"
            },
            {
                "key": "enable_points",
                "value": True,
                "description": "Activar sistema de puntos",
                "tag": "features"
            },
            {
                "key": "enable_badges",
                "value": True,
                "description": "Activar insignias",
                "tag": "features"
            },
            {
                "key": "enable_coupons",
                "value": True,
                "description": "Activar cupones",
                "tag": "features"
            },
        ]

        for setting in settings_data:
            if not db.query(SiteSettings).filter(
                    SiteSettings.key == setting["key"]).first():
                db.add(
                    SiteSettings(key=setting["key"],
                                 value=json.dumps(setting["value"]),
                                 description=setting["description"],
                                 tag=setting["tag"]))

        # Usuarios iniciales
        users_data = [{
            "email": "admin@example.com",
            "username": "admin_user1",
            "password_hash": hash_password("admin123"),
            "subscription": subscriptionEnum.PREMIUM,
            "credits": 1000,
            "rol": "admin",
            "create_at": datetime.utcnow() - timedelta(days=40),
            "activo": True
        }, {
            "email": "user@example.com",
            "username": "user",
            "password_hash": hash_password("user123"),
            "subscription": subscriptionEnum.CORPORATE,
            "credits": 5000,
            "rol": "user",
            "create_at": datetime.utcnow() - timedelta(days=35),
            "activo": True
        }]

        users = []
        for user_data in users_data:
            if not db.query(User).filter(
                    User.email == user_data["email"]).first():
                user = User(**user_data)
                db.add(user)
                users.append(user)

        db.commit()  # Necesario para obtener los IDs de los usuarios

        # Orígenes permitidos
        origins = [
            "localhost:3000", "neptuno.app",
            "staging.neptuno.app", "api.neptuno.app",
            "admin.neptuno.app"
        ]
        for origin in origins:
            if not db.query(AllowedOrigin).filter(
                    AllowedOrigin.origin == origin).first():
                db.add(AllowedOrigin(origin=origin))

        # Sesiones anónimas
        anonymous_sessions = []
        for i in range(2):
            session_id = str(uuid.uuid4())
            session = GuestsSession(
                id=session_id,
                username=f"anon_user_{i+1}",
                credits=100 - (i * 15),
                create_at=datetime.utcnow() - timedelta(days=i * 2),
                ultima_actividad=datetime.utcnow() - timedelta(hours=i),
                last_ip=f"192.168.1.{100 + i}")
            db.add(session)
            anonymous_sessions.append(session)

        # Proveedores de pago
        payment_providers = [{
            "name": "STRIPE",
            "active": True
        }, {
            "name": "PayPal",
            "active": True
        }, {
            "name": "Transferencia bancaria",
            "active": False
        }, {
            "name": "Crypto",
            "active": True
        }]
        for provider in payment_providers:
            if not db.query(PaymentProvider).filter(
                    PaymentProvider.name == provider["name"]).first():
                db.add(PaymentProvider(**provider))

        # Transacciones de créditos
        transactions = [{
            "user_id": users[0].id,
            "user_type": "registered",
            "amount": -10,
            "transaction_type": "api_call",
            "description": "Llamada a API"
        }]

        for transaction in transactions:
            db.add(CreditTransaction(**transaction))

        # Logs de errores
        error_logs = [{
            "user_id": users[0].id,
            "user_type": "registered",
            "error_code": 400,
            "message": "Invalid request",
            "details": "Missing 'email'",
            "url": "/api/v1/users",
            "method": "POST",
            "ip_address": "192.168.1.100"
        }, {
            "session_id": anonymous_sessions[0].id,
            "user_type": "anonymous",
            "error_code": 429,
            "message": "Rate limit exceeded",
            "details": "Too many requests",
            "url": "/api/v1/process",
            "method": "POST",
            "ip_address": "192.168.1.101"
        }]

        for error in error_logs:
            db.add(ErrorLog(**error))

        # Integraciones
        integrations = [{
            "user_id":
            users[0].id,
            "name":
            "slack_notif",
            "webhook_url":
            "https://hooks.slack.com/services/XXX",
            "event_type":
            "credit_usage",
            "active":
            True,
            "last_triggered":
            datetime.utcnow() - timedelta(hours=1)
        }]

        for integration in integrations:
            db.add(Integration(**integration))

        # Logs de API
        api_logs = [{
            "user_id":
            users[0].id,
            "endpoint":
            "/api/v1/auth/login",
            "method":
            "POST",
            "status_code":
            200,
            "request_data":
            json.dumps({"email": "freemium1@example.com"}),
            "response_data":
            json.dumps({"token": "xxx.yyy.zzz"})
        }]

        for log in api_logs:
            db.add(APILog(**log))

        # Métodos de pago
        payment_methods = [{
            "user_id": users[0].id,
            "payment_type": "credit_card",
            "details": "VISA ending in 4242",
            "is_default": True
        }]
        for method in payment_methods:
            db.add(PaymentMethod(**method))

        # Tokens revocados
        revoked_tokens = [{
            "token": "expired.token.xxx",
            "revoked_at": datetime.utcnow() - timedelta(days=10),
            "user_id": users[0].id
        }]
        for token in revoked_tokens:
            db.add(RevokedToken(**token))

        # Tokens de reseteo de contraseña
        reset_tokens = [{
            "user_id": users[0].id,
            "token": "reset_abc123",
            "expires_at": datetime.utcnow() + timedelta(hours=1)
        }]
        for token in reset_tokens:
            db.add(PasswordResetToken(**token))

        # Tipos de cupones
        coupon_types = [{
            "name": "Bienvenida",
            "description": "Cupón para nuevos usuarios",
            "credits": 50,
            "active": True
        }, {
            "name": "FIDELIDAD",
            "description": "Cupón por lealtad",
            "credits": 100,
            "active": True
        }, {
            "name": "PROMOCION",
            "description": "Cupón promocional especial",
            "credits": 200,
            "active": True
        }, {
            "name": "EVENTO",
            "description": "Cupón para eventos",
            "credits": 75,
            "active": False
        }]
        coupon_type_objects = []
        for ct in coupon_types:
            if not db.query(CouponType).filter(
                    CouponType.name == ct["name"]).first():
                coupon_type = CouponType(**ct)
                db.add(coupon_type)
                coupon_type_objects.append(coupon_type)
        db.commit()

        # Cupones
        coupons = [{
            "coupon_type_id": coupon_type_objects[0].id,
            "unique_identifier": str(uuid.uuid4()),
            "name": str(uuid.uuid4()),
            "issued_at": datetime.utcnow() - timedelta(days=5),
            "expires_at": datetime.utcnow() + timedelta(days=25),
            "active": True,
            "status": "active",
            "user_id": users[0].id,
            "session_id": anonymous_sessions[0].id,
            "credits": 50
        }]
        for coupon in coupons:
            db.add(Coupon(**coupon))

        # Eventos de gamificación
        event_types = [{
            "name": "api_usage",
            "description": "Uso de la API",
            "points_per_event": 10
        }, {
            "name": "login",
            "description": "Inicio de sesión",
            "points_per_event": 5
        }, {
            "name": "purchase",
            "description": "Compra de créditos",
            "points_per_event": 50
        }, {
            "name": "error_report",
            "description": "Reporte de error",
            "points_per_event": 20
        }]
        event_type_objects = []
        for event in event_types:
            if not db.query(EventType).filter(
                    EventType.name == event["name"]).first():
                event_type = EventType(**event)
                db.add(event_type)
                event_type_objects.append(event_type)
        db.commit()

        # Insignias
        badges = [{
            "name": "Novato",
            "description": "Primer uso de API",
            "event_type_id": event_type_objects[0].id,
            "required_points": 10,
            "user_type": "both"
        }, {
            "name": "Experto",
            "description": "100 usos de API",
            "event_type_id": event_type_objects[0].id,
            "required_points": 100,
            "user_type": "both"
        }, {
            "name": "Comprador",
            "description": "Primera compra",
            "event_type_id": event_type_objects[2].id,
            "required_points": 50,
            "user_type": "registered"
        }, {
            "name": "Solucionador",
            "description": "Reporte de errores",
            "event_type_id": event_type_objects[3].id,
            "required_points": 40,
            "user_type": "registered"
        }]
        badge_objects = []
        for badge in badges:
            if not db.query(Badge).filter(Badge.name == badge["name"]).first():
                badge_obj = Badge(**badge)
                db.add(badge_obj)
                badge_objects.append(badge_obj)
        db.commit()

        # Eventos de gamificación
        gamification_events = [{
            "event_type_id":
            event_type_objects[0].id,
            "user_id":
            users[0].id,
            "timestamp":
            datetime.utcnow() - timedelta(days=1)
        }]
        for event in gamification_events:
            db.add(GamificationEvent(**event))

        # Puntos de gamificación de usuarios
        user_gamification_data = [{
            "user_id": users[0].id,
            "event_type_id": event_type_objects[0].id,
            "points": 10,
            "badge_id": badge_objects[0].id
        }]
        for ug in user_gamification_data:
            db.add(UserGamification(**ug))

        db.commit()
        print(
            "✅ Base de datos inicializada con datos de ejemplo en todas las tablas."
        )
    except Exception as e:
        db.rollback()
        print(f"❌ Error al cargar datos iniciales: {str(e)}")
        raise
    finally:
        db.close()


if __name__ == "__main__":
    print("Creando tablas en la base de datos...")
    init_db()
    print("Cargando datos iniciales...")
    init_settings_and_users()


--------

cuando recargo la pagina pierde el user

actualiar el init_Db