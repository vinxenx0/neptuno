Excelente, yo tb he tomado nota de todas tus sugerencias, las he ordenado y jerarquizado y puesto en el roadmap

y ahora por fin te voy a solicitar las siguientes mejoras en la aplicación:

MEJORA 1: Ampliación de las funcionalidades (o modulos) disponibles en el BaaS con un:

** SISTEMA BASICO DE MARKETPLACE O CARRITO DE LA COMPRA **

Vamos a implar un sistema basico de carrito de la compra: el administrador podrá dar de alta 
nuevos productos con de una categoria de producto, por el otro lado: el usuario podrá añadir al carrito cualquiera
de esos productos y hacer el checkout a través de los endpoints de pago que ya hay implantados.

La logica podria ser la siguiente:

El usuario tendrá una nueva pestaña en su dashboard de usuario donde podrá ver el historial de productos comprados y Ver
todos los datos del producto o de la compra. Ademas, si es un producto digital, podrá bajarse el producto digital comprado. (archivo zip)

El administrador tendrá una nueva opción en el menu de config que será "marketplace" donde podrá gestionar los articulos
que están a la venta, sus cateorias, y las caracteristicas de los mismo. Ademas si es un producto digital, podrá adjuntar el archivo que
se llevará el usuario tras la compra.

El navbar tendrá un nuevo icono, junto al icono de los mensajes, que será el carrito de la compra, si tiene articulos
en el carrito aparecerá la notificación en un badge como el resto de iconos del navbar, cuando se pincha en el icono del carrito
vemos los productos y comenzará el checkout.

A la hora de hacer el checkout el usuario podrá descontar sus creditos actuales en la compra (1 credito = 1 euro) o seguir guardandolos en su cuenta.



TEndras que generar Para el backend: 
- los endpoints necesarios en la API actual para gestionar toda la logica del carrito y marketplace
- las dependencias, si procede, que requerira la logica para el carrito y marketplace
- middleware para el carrito y marketplace si lo consideras necesario, que quizas no sea el caso
- modelo completo de datos con todos los atributos y relaciones necesarias si las hubiere para los productos del carrito y marketplace
- shemas pydantic necesarios para la implantación correcta del sistema de el carrito y marketplace
- servicios necesarios para la implantación robusta y fiable de la logica de el carrito y marketplace
- algunos prodcutos de ejemplo para insertarlos en los datos iniciales
- crear un Site_setting necesario para poder habilitar y deshabilitar el carrito y marketplace
- actualizar todos los archivos necesarios como main.py o los afectados para la implantación de la logica.


TEndras que generar Para el frontend:

- añadir a la botonera de navbar un icono mas para el carrito que notificará de los articulos que hay en el carrito para el usuario activo en ese momento
- una pagina en /checkout/ que se accederá pinchando desde el icono de carrito de la botonera de navbar que nos llevará a una pagina donde se mostrará
el carrito y podrá comenzar el checkout

- actualizaremos el dashboard de usuario añadiendo una pestaña mas a la barra de opciones: antes de la pestaña TRANSACCIONES, pondemos la pestaña "COMPRAS"
donde el usuario podra ver si historial de compras y articulos comprados, asi como bajarse los productos digitales si fuese el caso

- actualizaremos el dashboard de administrador añadiendo: en la pestaña de funcionalidades añadiremos la nueva tarjeta para activar o desactivar la 
funcionalidad de el carrito y marketplace

- vamos añadir una opción mas al menu de settigs de solo el administrador: antes de la opción Revenues vamos a poner: Marketplace,y ahi sera donde el administrador
podra gestionar los productos que hay en el marketplace, asi como categorias y todo lo relacionado con el carrito.

- crear los tipados, funciones, handles, constantes, y todo lo que necesites


Como habras visto en los prompts anteriores, ya esta implantado las transacciones y las formas de pago, puedes ver como esta implantada en el dashboard
de users (compra de creditos, forma de pago, etc) toda esa parte no debes crearla sino integrar el marketplace con lo desarrollado para las formas de pago y compra.

Ahora te paso los archivos que considero relevantes para que los conozcas y ya sea que apliques los cambios necesarios o los tomes 
como guia o referencia para aplicar logicas generales. Aquilos tienes, solicita los que necesites si yo no te los he proporcionado:

Primero de todo la estructura actual, por si necesitas algo:

Primero de todo, el arbol de archivos

├── alembic.ini
├── backend
│   ├── ALAMBIC
│   ├── api
│   │   ├── graphql
│   │   │   ├── main.example.py
│   │   │   ├── p
│   │   │   ├── readme.md
│   │   │   ├── router.py
│   │   │   ├── schema
│   │   │   │   ├── auth.py
│   │   │   │   ├── coupons.py
│   │   │   │   ├── gamification.py
│   │   │   │   ├── __init__.py
│   │   │   │   ├── payment_providers.py
│   │   │   │   ├── payment.py
│   │   │   │   ├── site_settings.py
│   │   │   │   └── user.py
│   │   │   ├── schema.py
│   │   │   └── test.md
│   │   ├── __init__.py
│   │   └── v1
│   │       ├── auth
│   │       │   └── auth.py
│   │       ├── config
│   │       │   ├── integrations.py
│   │       │   ├── origins.py
│   │       │   └── site_settings.py
│   │       ├── gamification
│   │       │   ├── coupons.py
│   │       │   └── gamification.py
│   │       ├── health
│   │       │   └── test.py
│   │       ├── __init__.py
│   │       ├── logs
│   │       │   ├── api_logs.py
│   │       │   └── error_logs.py
│   │       ├── transactions
│   │       │   ├── credit_transactions.py
│   │       │   ├── payment_providers.py
│   │       │   └── payments.py
│   │       └── users
│   │           ├── anonymous_sessions.py
│   │           └── users.py
│   ├── app.log
│   ├── app.log.1
│   ├── background.sh
│   ├── check_db.sh
│   ├── core
│   │   ├── config.py
│   │   ├── database.py
│   │   ├── __init__.py
│   │   ├── logging.py
│   │   └── security.py
│   ├── dependencies
│   │   ├── auth.py
│   │   ├── credits.py
│   │   └── __init__.py
│   ├── dev.db
│   ├── Dockerfile
│   ├── env.local
│   ├── env.prod
│   ├── ini_db.py
│   ├── __init__.py
│   ├── main.py
│   ├── middleware
│   │   ├── credits_middleware.py
│   │   ├── gamification.py
│   │   ├── __init__.py
│   │   └── logging.py
│   ├── models
│   │   ├── allowed_origin.py
│   │   ├── coupon.py
│   │   ├── coupon_type.py
│   │   ├── credit_transaction.py
│   │   ├── error_log.py
│   │   ├── gamification.py
│   │   ├── guests.py
│   │   ├── __init__.py
│   │   ├── integration.py
│   │   ├── log.py
│   │   ├── payment_method.py
│   │   ├── payment_provider.py
│   │   ├── site_settings.py
│   │   ├── token.py
│   │   └── user.py
│   ├── requirements.txt
│   ├── schemas
│   │   ├── allowed_origin.py
│   │   ├── anonymous_session.py
│   │   ├── api_log.py
│   │   ├── auth.py
│   │   ├── coupon.py
│   │   ├── credit_transaction.py
│   │   ├── error_log.py
│   │   ├── gamification.py
│   │   ├── integration.py
│   │   ├── payment.py
│   │   ├── site_settings.py
│   │   └── user.py
│   ├── services
│   │   ├── auth_service.py
│   │   ├── coupon_service.py
│   │   ├── credits_service.py
│   │   ├── gamification_service.py
│   │   ├── __init__.py
│   │   ├── integration_service.py
│   │   ├── log_service.py
│   │   ├── origin_service.py
│   │   ├── payment_provider_service.py
│   │   ├── payment_service.py
│   │   ├── settings_service.py
│   │   └── user_service.py
│   ├── tasks.py
│   └── up_api.sh
├── backlog.md
├── docker-compose.yml
├── frontend
│   ├── deploy.sh
│   ├── Dockerfile
│   ├── env.local
│   ├── env.prod
│   ├── eslint.config.mjs
│   ├── next.config.ts
│   ├── package.json
│   ├── package-lock.json
│   ├── postcss.config.js
│   ├── public
│   │   ├── apple-touch-icon.ico
│   │   ├── favicon-16x16.ico
│   │   ├── favicon.ico
│   │   ├── logo.png
│   │   └── robots.txt
│   ├── src
│   │   ├── app
│   │   │   ├── about
│   │   │   │   ├── layout.tsx
│   │   │   │   └── [page]
│   │   │   │       ├── contact.tsx
│   │   │   │       ├── page.tsx
│   │   │   │       ├── policy.tsx
│   │   │   │       ├── privacy.tsx
│   │   │   │       └── us.tsx
│   │   │   ├── admin
│   │   │   │   ├── dashboard
│   │   │   │   │   ├── page.min..tsx
│   │   │   │   │   ├── page.sidebar.tsx
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── gamification
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── registry
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── reset-credits
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── revenues
│   │   │   │   │   └── page.tsx
│   │   │   │   └── users
│   │   │   │       └── page.tsx
│   │   │   ├── (default-site)
│   │   │   │   ├── about-us
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── blog
│   │   │   │   │   ├── page.tsx
│   │   │   │   │   └── [slug]
│   │   │   │   │       └── page.tsx.bug
│   │   │   │   ├── contact
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── faq
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── landing
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── __layout.tsx
│   │   │   │   ├── pricing
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── privacy
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── products
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── services
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── _sitemap.xml
│   │   │   │   │   └── route.ts
│   │   │   │   └── terms
│   │   │   │       └── page.tsx
│   │   │   ├── (gamification)
│   │   │   │   ├── ejemplos
│   │   │   │   │   └── page.tsx
│   │   │   │   └── rankings
│   │   │   │       └── page.tsx
│   │   │   ├── global.css
│   │   │   ├── layout.tsx
│   │   │   ├── page.old.tsx
│   │   │   ├── page.tsx
│   │   │   ├── sitemap.ts.example
│   │   │   └── user
│   │   │       ├── auth
│   │   │       │   ├── layout.tsx
│   │   │       │   └── page.tsx
│   │   │       ├── badges
│   │   │       │   └── page.tsx
│   │   │       ├── change-password
│   │   │       │   └── page.tsx
│   │   │       ├── coupon
│   │   │       │   └── page.tsx
│   │   │       ├── dashboard
│   │   │       │   ├── page.bug..tsx
│   │   │       │   ├── page.min.tsx
│   │   │       │   └── page.tsx
│   │   │       ├── points
│   │   │       │   └── page.tsx
│   │   │       └── transactions
│   │   │           └── page.tsx
│   │   ├── components
│   │   │   ├── admin
│   │   │   │   └── AdminUsersPage.tsx
│   │   │   ├── dashboard
│   │   │   │   └── DashboardUI.tsx
│   │   │   ├── seo
│   │   │   │   ├── MetaTags.tsx
│   │   │   │   └── ShemaMarkup.tsx
│   │   │   ├── ui
│   │   │   │   ├── FeatureDisabled.tsx
│   │   │   │   ├── FeatureStateHandler.tsx
│   │   │   │   ├── FilterableTabs.tsx
│   │   │   │   ├── index.tsx
│   │   │   │   ├── MinimalCard copy.tsx
│   │   │   │   ├── MinimalCard.tsx
│   │   │   │   ├── MinimalForm.tsx
│   │   │   │   ├── MinimalList.tsx
│   │   │   │   ├── Notification.tsx
│   │   │   │   ├── SectionHeader.tsx
│   │   │   │   ├── SectionTable.tsx
│   │   │   │   └── Styled.tsx
│   │   │   └── web
│   │   │       ├── Footer.tsx
│   │   │       ├── Navbar.bak.tsx
│   │   │       ├── Navbar.new.1.tsx
│   │   │       └── Navbar.tsx
│   │   ├── hooks
│   │   │   ├── useFetchData.ts
│   │   │   └── useNotifications.tsx
│   │   └── lib
│   │       ├── api.ts
│   │       ├── auth
│   │       │   └── context.tsx
│   │       ├── payments
│   │       │   ├── example.tsx
│   │       │   ├── manager.ts
│   │       │   └── stripe.ts
│   │       ├── payments.ts
│   │       └── types.ts
│   ├── tailwind.config.js
│   ├── tsconfig.json
│   ├── up_front.sh
│   └── WEBSOCKETS


│   └── welcome.prompt
├── README.md
├── roadmap.doc
├── run.sh

archivos que te paso para las modificaciones Para el backend:



Si necesitas algun archivo de referencia del backend pidemelo, recuerda que en el backend debes generar Para el backend: 

- los endpoints necesarios en la API actual para gestionar toda la logica de el carrito y el marketplace
- las dependencias, si procede, que requerira la logica para  el carrito y el marketplace
- middleware para  el carrito y el marketplace si lo consideras necesario, que quizas no sea el caso
- modelo completo de datos con todos los atributos y relaciones necesarias si las hubiere
- shemas pydantic necesarios para la implantación correcta del sistema de  el carrito y el marketplace
- servicios necesarios para la implantación robusta y fiable de la logica de  el carrito y el marketplace
- algunos producto y categorias de ejemplo para insertarlos en los datos iniciales
- crear un Site_setting necesario para poder habilitar y deshabilitar  el carrito y el marketplace
- actualizar todos los archivos necesarios como main.py o los afectados para la implantación de la logica.
. cualquier otra cosa que necesites implantar

resumiendo:

Backend: Implementación del sistema de carrito y el marketplace dentro de la arquitectura actual de neptuno,
respetando la funciones actuales, metodos, y guia de estilos actuales

        Modelo de datos
        Esquemas Pydantic
        Servicios
        Endpoints
        Configuración del SiteSetting
        Datos iniciales de ejemplo
        Actualización de archivos existentes (como main.py)

    Frontend: Implementación del sistema de carrito y el marketplace dentro de la interfaz de usuario y admin en nextjs

        Tipados y actualizaciones en el contexto de autenticación
        Modificación de la Navbar
        Páginas para marketplace y checkout
        Actualización del dashboard de usuario
        Actualización del dashboard de administrador
        Nueva pagina de configuración del  sistema de carrito y el marketplace

Ahora te paso los archivos que necesitaras para el frontend, son los mismos que he pasado en el Inicio
es para que los tengas recientes

Primero el mas importante: el contexto:

// src/lib/auth/context.tsx
// frontend/src/lib/auth/context.tsx
// Contexto de autenticación y estado global del usuario

"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge, Coupon } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // Añadimos gamificación al contexto
  coupons: Coupon[];
  setCredits: (credits: number) => void; // Añadido
  setCoupons: (coupons: Coupon[]) => void;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  setGamification: (gamification: Gamification) => void; // Añadido
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}



const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(10); // Valor por defecto para anónimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificación
  const [loading, setLoading] = useState(true);
  const router = useRouter();
  const [coupons, setCoupons] = useState<Coupon[]>([]);


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<any>("/whoami"); // Endpoint para obtener info del usuario
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
          } else {
            setUser(null);
            setCredits(0);
          }

          // Obtener datos de gamificación
          const gamificationRes = await fetchAPI<any[]>("/v1/gamification/me");
          if (gamificationRes.data) {
            const totalPoints = gamificationRes.data.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationRes.data.map(g => g.badge).filter(Boolean) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }

          // Obtener cupones del usuario
          const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/me");
          setCoupons(couponsRes.data || []);
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        setCoupons([]);
      } finally {
        setLoading(false);
      }
    };

    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesión
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesión
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operación
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits, gamification, coupons, setCoupons, setGamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// frontend/src/lib/types.ts
// Tipos TypeScript para entidades y respuestas de la app

// src/lib/types.ts
export interface User {
  id: number;
  email: string;
  username: string;
  rol: string;
  activo: boolean;
  subscription: string;
  ciudad?: string;
  website?: string;
  credits: number;
  create_at: string;  // ISO string (e.g., "2023-10-01T12:00:00Z")
  last_ip?: string;
  last_login: string;
  user_type: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}



export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  ciudad?: string;
  website?: string;
}

export interface UpdateProfileRequest {
  email?: string;
  username?: string;
  ciudad?: string;
  website?: string;
}

export interface PurchaseRequest {
  credits: number;
  payment_amount: number;
  payment_method?: string;
}

export interface PurchaseResponse {
  transaction_id: string;
  credits_added: number;
  new_balance: number;
}

export interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
  created_at: string;  // ISO string
  updated_at: string;  // ISO string
}

export interface HTTPValidationError {
  detail: ValidationError[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string; // ISO string
}

export interface Integration {
  user_id: number;
  id: number;
  name: string;
  webhook_url: string;
  event_type: string;
  active: boolean;
  created_at: string;
  last_triggered: string | null;
}

export interface SiteSetting {
    id: number;
    key: string;
    value: string;
    description?: string;
    tag?: string;
    updated_by?: number;
    updated_at: string; // ISO string
}

export interface FetchResponse<T> {
  data: T | null;
  error: string | HTTPValidationError | null;
  total_pages?: number;
}

// src/lib/types.ts
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string;
  gamification: UserGamificationResponse[]; // Actualizado para reflejar /whoami
}

export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[];
}

export interface GamificationEventCreate {
  event_type_id: number;
}

export interface GamificationEventResponse {
  id: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  timestamp: string; // ISO string
}

export interface UserGamificationResponse {
  points: number;
  badge_id?: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  event_type: EventType;
  badge?: Badge;
}
export interface RankingResponse {
  username: string;
  points: number;
  badges_count: number;
  user_type: string;
}

export interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}



export interface InfoResponse {
  credits: number;
  gamification: { points: number; badge: Badge | null }[];
}


export interface BadgeWithEventType extends Badge {
  event_type: EventType;
}


// src/lib/types.ts

// Nuevo tipo para cupones
export interface Coupon {
  id: number;
  name: string;
  description?: string;
  unique_identifier: string;
  issued_at: string; // ISO string
  expires_at?: string; // ISO string, opcional
  redeemed_at?: string; // ISO string, opcional
  active: boolean;
  status: "active" | "redeemed" | "expired" | "disabled";
  credits: number;
  user_id?: number; // Opcional, para usuarios registrados
  session_id?: string; // Opcional, para usuarios anónimos
  redeemed_by_user_id?: number; // Quién lo canjeó, si aplica
  redeemed_by_session_id?: string; // Quién lo canjeó (anónimo), si aplica
}



export interface CouponType {
  id: number;
  name: string;
  description?: string;
  credits: number;
  active: boolean;
}

export interface CouponActivity {
  id: number;
  coupon_type: string;
  unique_identifier: string;
  user_id?: number;
  session_id?: string;
  status: string;
  issued_at: string;
  redeemed_at?: string;
}

export interface AllowedOrigin {
  id: number;
  origin: string;
}

// frontend/src/lib/api.ts
// Cliente Axios y funciones para consumir la API

// src/lib/api.ts
import axios, { AxiosRequestConfig, AxiosResponse, AxiosError, AxiosInstance } from "axios";
import { useState, useEffect } from 'react';
import { HTTPValidationError, FetchResponse, RegisterRequest, TokenResponse, UpdateProfileRequest, User, ValidationError } from "./types";

// Extender AxiosRequestConfig para incluir _retry
interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  _retry?: boolean;
}

// Crear una instancia personalizada de Axios
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Variables para manejar el estado de refresco
let isRefreshing = false;
let failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

// Agregar el interceptor de solicitudes
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("accessToken");
  const sessionId = localStorage.getItem("session_id");
  if (token) {
    config.headers["Authorization"] = `Bearer ${token}`;
  } else if (sessionId) {
    config.headers["X-Session-ID"] = sessionId;
  }
  return config;
});

const logRequest = (method: string, url: string, status: number, data?: unknown) => {
  console.log(`[${method}] ${url} - Status: ${status}`, data ?? "");
};

const fetchAPI = async <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  contentType: string = "application/json"
): Promise<FetchResponse<T>> => {
  console.log(`Iniciando fetchAPI para ${endpoint}`);

  const config: CustomAxiosRequestConfig = {
    ...options,
    url: endpoint, // baseURL ya está configurado en la instancia
    headers: {
      "Content-Type": contentType,
      ...options.headers,
    },
    data: options.data,
  };

  // Convertir datos a formato x-www-form-urlencoded si es necesario
  if (contentType === "application/x-www-form-urlencoded" && config.data) {
    const formData = new URLSearchParams();
    Object.entries(config.data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });
    config.data = formData;
  }

  const normalizeResponse = (
    response: AxiosResponse<T> | undefined,
    error: unknown
  ): FetchResponse<T> => {
    if (response && response.status >= 200 && response.status < 300) {
      return { data: response.data, error: null };
    }

    if (axios.isAxiosError(error)) {
      const errorData = error.response?.data;
      if (errorData && errorData.detail) {
        if (typeof errorData.detail === "string") {
          return { data: null, error: errorData.detail };
        } else if (Array.isArray(errorData.detail)) {
          const messages = errorData.detail
            .map((err: ValidationError) => err.msg)
            .join(", ");
          return { data: null, error: messages };
        }
      }
    }

    return { data: null, error: "Error desconocido" };
  };

  try {
    const response: AxiosResponse<T> = await api(config); // Usar la instancia 'api'
    logRequest(config.method || "GET", config.url!, response.status, response.data);

    if (response.data && (response.data as any).session_id) {
      localStorage.setItem("session_id", (response.data as any).session_id);
    }

    return normalizeResponse(response, null);
  } catch (err: unknown) {
    const axiosError = err as AxiosError;
    logRequest(
      config.method || "GET",
      config.url!,
      axiosError.response?.status || 500,
      axiosError.response?.data
    );

    if (axiosError.response?.status === 401 && !config._retry) {
      const originalRequest: CustomAxiosRequestConfig = config;
      originalRequest._retry = true;

      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");

      if (accessToken && refreshToken) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token) => {
                originalRequest.headers.Authorization = `Bearer ${token}`;
                api(originalRequest)
                  .then(response => resolve(normalizeResponse(response, null)))
                  .catch(error => reject(normalizeResponse(undefined, error)));
              },
              reject: (error) => reject(normalizeResponse(undefined, error)),
            });
          });
        }

        isRefreshing = true;

        try {
          console.log("Intentando refrescar token de acceso");
          const refreshResponse = await api.post<TokenResponse>(
            "/v1/auth/refresh",
            { refresh_token: refreshToken },
            {
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`,
              },
            }
          );

          localStorage.setItem("accessToken", refreshResponse.data.access_token);
          localStorage.setItem("refreshToken", refreshResponse.data.refresh_token);

          originalRequest.headers.Authorization = `Bearer ${refreshResponse.data.access_token}`;
          processQueue(null, refreshResponse.data.access_token);

          const retryResponse = await api(originalRequest);
          return normalizeResponse(retryResponse, null);
        } catch (refreshError) {
          console.error("Error al refrescar token:", refreshError);
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          localStorage.removeItem("session_id");
          processQueue(refreshError, null);
          window.location.href = "/user/auth/#login";
          return normalizeResponse(undefined, {
            message: "Sesión expirada, por favor inicia sesión nuevamente",
          });
        } finally {
          isRefreshing = false;
        }
      } else {
        return normalizeResponse(undefined, { message: "No autorizado" });
      }
    }

    return normalizeResponse(undefined, err);
  }
};

// Custom hook to fetch data
export const useFetchData = <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  dependencies: any[] = []
): { data: T | null; loading: boolean; error: string | null } => {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetchAPI<T>(endpoint, options);
        if (response.error) {
          setError(typeof response.error === 'string' ? response.error : 'Error desconocido');
        } else {
          setData(response.data);
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error desconocido');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [endpoint, options, dependencies]); // Asegurar que la lista de dependencias sea un array literal y agregar endpoint y options como dependencias

  return { data, loading, error };
};

// Funciones específicas de la API
export const getAllUsers = async (
  page: number = 1,
  limit: number = 10
): Promise<FetchResponse<{
  data: User[],
  total_items: number,
  total_pages: number,
  current_page: number
}>> => {
  return fetchAPI(`/v1/users/admin/users?page=${page}&limit=${limit}`, {
    method: "GET"
  });
};

export const getUserById = async (
  userId: number
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "GET"
  });
};

export const updateUser = async (
  userId: number,
  data: UpdateProfileRequest
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "PUT",
    data
  });
};

export const deleteUser = async (
  userId: number
): Promise<FetchResponse<void>> => {
  return fetchAPI<void>(`/v1/users/${userId}`, {
    method: "DELETE"
  });
};

export const createUser = async (
  data: RegisterRequest
): Promise<FetchResponse<TokenResponse>> => {
  return fetchAPI<TokenResponse>("/v1/auth/register", {
    method: "POST",
    data
  });
};

export default fetchAPI;


// frontend/src/hooks/useFetchData.ts
// frontend/src/hooks/useFetchData.ts
// Custom hook para realizar peticiones HTTP y manejar el estado de carga, error y datos.
import { useState, useEffect } from 'react';

interface FetchDataResult<T> {
  data: T | null;
  error: string | null;
  loading: boolean;
}

export function useFetchData<T>(url: string, dependencies: any[] = []): FetchDataResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`Error: ${response.statusText}`);
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url, dependencies]);

  return { data, error, loading };
}

## IMPORTANTISIMO EL NAVBAR ## MANEJALO CON EXTREMA DELICADEZA Y precaución

// frontend/src/components/web/Navbar.tsx
// Barra de navegación principal con estado de usuario y notificaciones
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import { usePathname } from "next/navigation";
import fetchAPI from "@/lib/api";
import {
  Button,
  Avatar,
  IconButton,
  Menu,
  MenuItem,
  useTheme,
  styled,
  Box,
  Typography,
  Snackbar,
  Alert,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Tooltip,
  Badge
} from "@mui/material";
import {
  MonetizationOn,
  Settings,
  ListAlt,
  People,
  Dashboard,
  Login,
  PersonAdd,
  Person,
  Home,
  Star,
  EmojiEvents,
  Leaderboard,
  School,
  Menu as MenuIcon,
  ContactMail,
  Close,
  Key,
  LocalActivity,
  Mail,
  Favorite
} from "@mui/icons-material";
import Image from "next/image";

const MobileBottomNav = styled(Box)(({ theme }) => ({
  position: 'fixed',
  bottom: 0,
  left: 0,
  right: 0,
  background: 'rgba(255, 255, 255, 0.1)',
  backdropFilter: 'blur(10px)',
  borderTop: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1),
  zIndex: 999,
  justifyContent: 'space-around',
  alignItems: 'center',
  display: 'flex',
  [theme.breakpoints.up('md')]: {
    display: 'none',
  },
}));

const GlassNavbar = styled("nav")(({ theme }) => ({
  background: "rgba(255, 255, 255, 0.1)",
  backdropFilter: "blur(10px)",
  borderBottom: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1, 2),
  position: "fixed",
  top: 0,
  left: 0,
  right: 0,
  zIndex: 1000,
}));

const NavContainer = styled(Box)(({ theme }) => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  maxWidth: "1200px",
  margin: "0 auto",
  [theme.breakpoints.down("md")]: {
    flexDirection: "row",
    alignItems: "center",
    gap: 1
  },
}));

export default function Navbar() {
  const theme = useTheme();
  const pathname = usePathname();
  const { user, credits, gamification, coupons, setCredits, setGamification, logout } = useAuth();
  const [settingsAnchorEl, setSettingsAnchorEl] = useState<null | HTMLElement>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [disableCredits, setDisableCredits] = useState(false);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const [enablePoints, setEnablePoints] = useState(true);
  const [enableCoupons, setEnableCoupons] = useState(true);
  const [enableBadges, setEnableBadges] = useState(true);
  const [enablePaymentMethods, setEnablePaymentMethods] = useState(true);
  const [anonUsername, setAnonUsername] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [newBadge, setNewBadge] = useState<string | null>(null);

  useEffect(() => {
    const storedAnonUsername = localStorage.getItem("anonUsername");
    setAnonUsername(storedAnonUsername);
  }, []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const [
          disableCreditsRes,
          enableRegistrationRes,
          enablePointsRes,
          enableCouponsRes,
          enableBadgesRes,
          enablePaymentMethodsRes,
        ] = await Promise.all([
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_coupons"),
          fetchAPI("/v1/settings/enable_badges"),
          fetchAPI("/v1/settings/enable_payment_methods"),
        ]);
        setDisableCredits(disableCreditsRes.data === "true" || disableCreditsRes.data === true);
        setEnableRegistration(enableRegistrationRes.data === "true" || enableRegistrationRes.data === true);
        setEnablePoints(enablePointsRes.data === "true" || enablePointsRes.data === true);
        setEnableCoupons(enableCouponsRes.data === "true" || enableCouponsRes.data === true);
        setEnableBadges(enableBadgesRes.data === "true" || enableBadgesRes.data === true);
        setEnablePaymentMethods(enablePaymentMethodsRes.data === "true" || enablePaymentMethodsRes.data === true);
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
      }
    };
    fetchSettings();
  }, []);

  interface InfoData {
    credits: number;
  }

  useEffect(() => {
    if (!enablePoints && !enableBadges) return;

    const interval = setInterval(async () => {
      try {
        const { data: infoData } = await fetchAPI<InfoData>("/whoami");
        if (infoData) {
          setCredits(infoData.credits);
        }

        const { data: gamificationData } = await fetchAPI("/v1/gamification/me");
        if (gamificationData && Array.isArray(gamificationData)) {
          const totalPoints = enablePoints
            ? gamificationData.reduce((sum, g) => sum + g.points, 0)
            : 0;
          const badges = enableBadges
            ? gamificationData.map((g) => g.badge).filter((b) => b !== null)
            : [];

          const previousBadges = JSON.parse(localStorage.getItem("badges") || "[]");
          const currentBadgeIds = badges.map((b) => b.id);
          const newBadges = currentBadgeIds.filter((id) => !previousBadges.includes(id));
          if (newBadges.length > 0 && enableBadges) {
            const badge = badges.find((b) => b.id === newBadges[0]);
            setNewBadge(badge?.name || "Nuevo badge");
            setSnackbarOpen(true);
            localStorage.setItem("badges", JSON.stringify(currentBadgeIds));
          }

          setGamification({ points: totalPoints, badges });
        }
      } catch (err) {
        console.error("Error al actualizar datos:", err);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [setCredits, setGamification, enablePoints, enableBadges]);

  const handleSettingsMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchorEl(event.currentTarget);
  };

  const handleSettingsMenuClose = () => {
    setSettingsAnchorEl(null);
  };

  const handleDrawerOpen = () => {
    setDrawerOpen(true);
  };

  const handleDrawerClose = () => {
    setDrawerOpen(false);
  };

  const availableCoupons = (coupons || []).filter(
    (coupon) =>
      coupon &&
      coupon.status === "active" &&
      (!coupon.expires_at || new Date(coupon.expires_at) > new Date())
  ).length;

  return (
    <>
      <GlassNavbar>
        <NavContainer>
          {/* Sección izquierda: Logo y menú hamburguesa */}
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            <IconButton
              onClick={handleDrawerOpen}
              sx={{ display: { xs: "block", md: "none" } }}
            >
              <MenuIcon />
            </IconButton>

            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              <Link href="/" passHref>
                <Box sx={{
                  display: "flex",
                  alignItems: "center",
                  gap: 1,
                  cursor: "pointer"
                }}>
                  <Image
                    src="/logo.png"
                    alt="Logo Neptuno"
                    width={40}
                    height={40}
                    style={{ borderRadius: "50%" }}
                  />
                  <Typography
                    variant="h6"
                    component="span"
                    className="app-logo"
                    sx={{
                      fontWeight: "bold",
                      display: {
                        xs: 'none',
                        md: 'block'
                      }
                    }}
                  >
                    Neptuno
                  </Typography>
                </Box>
              </Link>
            </Box>
          </Box>

          {/* Sección derecha: Elementos específicos para móvil */}
          <Box sx={{ 
            display: { xs: "flex", md: "none" },
            alignItems: "center",
            gap: 1
          }}>
            {/* Mensajes */}
            <Tooltip title="Mensajes (próximamente)">
              <IconButton sx={{ color: theme.palette.text.disabled }}>
                <Mail />
              </IconButton>
            </Tooltip>

            {/* Favoritos */}
            <Tooltip title="Likes (próximamente)">
              <IconButton sx={{ color: theme.palette.text.disabled }}>
                <Favorite />
              </IconButton>
            </Tooltip>

            {/* Settings solo para admin */}
            {user?.rol === "admin" && (
              <IconButton
                onClick={handleSettingsMenuOpen}
                sx={{ color: "inherit" }}
              >
                <Settings />
              </IconButton>
            )}
          </Box>

          {/* Sección derecha: Versión desktop */}
          <Box sx={{ 
            display: { xs: "none", md: "flex" },
            alignItems: "center",
            gap: 2
          }}>
            {/* Enlaces desktop */}
            <Box sx={{ display: "flex", gap: 2, mr: 1 }}>
              <Button
                component={Link}
                href="/ejemplos"
                className={pathname === '/ejemplos' ? 'active-link' : ''}
              >
                Ejemplos
              </Button>
              <Button
                component={Link}
                href="/rankings"
                className={pathname === '/rankings' ? 'active-link' : ''}
              >
                Rankings
              </Button>
            </Box>

            {/* Iconos de notificaciones - Orden modificado */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {/* Nuevo orden: corazón primero */}
              <Tooltip title="Likes (próximamente)">
                <IconButton sx={{ color: theme.palette.text.disabled }}>
                  <Favorite />
                </IconButton>
              </Tooltip>

              {/* Mensaje segundo */}
              <Tooltip title="Mensajes (próximamente)">
                <IconButton sx={{ color: theme.palette.text.disabled }}>
                  <Mail />
                </IconButton>
              </Tooltip>

              {/* Créditos tercero */}
              {!disableCredits && credits > 0 && (
                <Link href="/user/transactions" passHref>
                  <IconButton className="notification-icon">
                    <MonetizationOn />
                    <span className="notification-badge credits-badge">{credits}</span>
                  </IconButton>
                </Link>
              )}

              {enableCoupons && (
                <Link href="/user/coupon" passHref>
                  <Tooltip title="Tus cupones">
                    <IconButton className="notification-icon">
                      <Badge badgeContent={availableCoupons} color="secondary">
                        <LocalActivity />
                      </Badge>
                    </IconButton>
                  </Tooltip>
                </Link>
              )}

              {gamification && (
                <>
                  {enablePoints && (
                    <Link href="/user/points" passHref>
                      <IconButton className="notification-icon">
                        <Star />
                        <span className="notification-badge points-badge">{gamification.points}</span>
                      </IconButton>
                    </Link>
                  )}
                  {enableBadges && (
                    <Link href="/user/badges" passHref>
                      <IconButton className="notification-icon">
                        <EmojiEvents />
                        <span className="notification-badge badges-badge">{gamification.badges.length}</span>
                      </IconButton>
                    </Link>
                  )}
                </>
              )}
            </Box>

            {/* Menú admin y usuario */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {user?.rol === "admin" && (
                <>
                  <IconButton
                    onClick={handleSettingsMenuOpen}
                    sx={{ color: "inherit" }}
                  >
                    <Settings />
                  </IconButton>
                  <Menu
                    anchorEl={settingsAnchorEl}
                    open={Boolean(settingsAnchorEl)}
                    onClose={handleSettingsMenuClose}
                    PaperProps={{
                      sx: {
                        background: "rgba(255, 255, 255, 0.9)",
                        backdropFilter: "blur(10px)",
                        borderRadius: "12px",
                        mt: 1,
                        minWidth: "200px",
                      },
                    }}
                  >
                    <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/dashboard">
                      <Dashboard sx={{ mr: 1 }} /> Config
                    </MenuItem>
                    <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/gamification">
                      <EmojiEvents sx={{ mr: 1 }} /> Gamification
                    </MenuItem>
                    <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/revenues">
                      <MonetizationOn sx={{ mr: 1 }} /> Revenues
                    </MenuItem>
                    <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/registry">
                      <ListAlt sx={{ mr: 1 }} /> Registros
                    </MenuItem>
                    <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/users">
                      <People sx={{ mr: 1 }} /> Usuarios
                    </MenuItem>
                  </Menu>
                </>
              )}

              {user ? (
                <Tooltip title={user.username} arrow>
                  <IconButton
                    component={Link}
                    href="/user/dashboard"
                    className="user-avatar"
                  >
                    <Avatar sx={{
                      bgcolor: theme.palette.primary.main,
                      width: 40,
                      height: 40,
                      fontSize: '1rem'
                    }}>
                      {user.username[0].toUpperCase()}
                    </Avatar>
                  </IconButton>
                </Tooltip>
              ) : (
                <Tooltip title={anonUsername ? "Iniciar sesión" : "Registrarse"} arrow>
                  <Box sx={{ position: 'relative' }}>
                    <IconButton
                      component={Link}
                      href={anonUsername ? "/user/auth/#login" : "/user/auth/#register"}
                      className="user-avatar"
                    >
                      <Avatar sx={{
                        bgcolor: theme.palette.grey[500],
                        width: 40,
                        height: 40,
                        color: theme.palette.common.white
                      }}>
                        {anonUsername ? <Person /> : <Key />}
                      </Avatar>
                    </IconButton>
                    {anonUsername && (
                      <Box sx={{
                        position: 'absolute',
                        top: 0,
                        right: 0,
                        backgroundColor: theme.palette.secondary.main,
                        borderRadius: '50%',
                        width: 20,
                        height: 20,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        border: `2px solid ${theme.palette.background.paper}`
                      }}>
                        <Key sx={{ fontSize: 12, color: theme.palette.common.white }} />
                      </Box>
                    )}
                  </Box>
                </Tooltip>
              )}
            </Box>
          </Box>

          {/* Menú hamburguesa */}
          <Drawer anchor="left" open={drawerOpen} onClose={handleDrawerClose}>
            <List>
              <Box sx={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'space-between',
                p: 2,
                borderBottom: `1px solid ${theme.palette.divider}`
              }}>
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                  <Image
                    src="/logo.png"
                    alt="Logo Neptuno"
                    width={40}
                    height={40}
                    style={{ borderRadius: "50%" }}
                  />
                  <Typography
                    variant="h6"
                    sx={{
                      fontWeight: "bold",
                      background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                      WebkitBackgroundClip: "text",
                      WebkitTextFillColor: "transparent",
                      display: "inline-block",
                    }}
                  >
                    Neptuno
                  </Typography>
                </Box>
                <IconButton onClick={handleDrawerClose}>
                  <Close />
                </IconButton>
              </Box>

              <ListItem component={Link} href="/">
                <ListItemIcon><Home /></ListItemIcon>
                <ListItemText primary="Inicio" />
              </ListItem>
              <ListItem component={Link} href="/ejemplos">
                <ListItemIcon><School /></ListItemIcon>
                <ListItemText primary="Ejemplos" />
              </ListItem>
              <ListItem component={Link} href="/rankings">
                <ListItemIcon><Leaderboard /></ListItemIcon>
                <ListItemText primary="Rankings" />
              </ListItem>
              <ListItem component={Link} href="/about/contact">
                <ListItemIcon><ContactMail /></ListItemIcon>
                <ListItemText primary="Contacto" />
              </ListItem>

              {user?.rol === "admin" && (
                <>
                  <ListItem component={Link} href="/admin/dashboard">
                    <ListItemIcon><Dashboard /></ListItemIcon>
                    <ListItemText primary="Dashboard" />
                  </ListItem>
                  <ListItem component={Link} href="/admin/registry">
                    <ListItemIcon><ListAlt /></ListItemIcon>
                    <ListItemText primary="Registros" />
                  </ListItem>
                  <ListItem component={Link} href="/admin/users">
                    <ListItemIcon><People /></ListItemIcon>
                    <ListItemText primary="Usuarios" />
                  </ListItem>
                </>
              )}
              {user ? (
                <ListItem component={Link} href="/user/dashboard">
                  <ListItemIcon><Person /></ListItemIcon>
                  <ListItemText primary={user.username} />
                </ListItem>
              ) : (
                <>
                  <ListItem component={Link} href="/user/auth/#login">
                    <ListItemIcon><Login /></ListItemIcon>
                    <ListItemText primary="Iniciar Sesión" />
                  </ListItem>
                  {enableRegistration && (
                    <ListItem component={Link} href="/user/auth/#register">
                      <ListItemIcon><PersonAdd /></ListItemIcon>
                      <ListItemText primary="Registrarse" />
                    </ListItem>
                  )}
                </>
              )}
            </List>
          </Drawer>
        </NavContainer>

        <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)}>
          <Alert onClose={() => setSnackbarOpen(false)} severity="success" sx={{ width: "100%" }}>
            ¡Felicidades! Has obtenido el badge: {newBadge}
          </Alert>
        </Snackbar>
      </GlassNavbar>

      <MobileBottomNav>
        {!disableCredits && credits > 0 && (
          <Link href="/user/transactions" passHref>
            <IconButton className="notification-icon">
              <MonetizationOn />
              <span className="notification-badge credits-badge">{credits}</span>
            </IconButton>
          </Link>
        )}

        {enableCoupons && (
          <Link href="/user/coupon" passHref>
            <Tooltip title="Tus cupones">
              <IconButton className="notification-icon">
                <Badge badgeContent={availableCoupons} color="secondary">
                  <LocalActivity />
                </Badge>
              </IconButton>
            </Tooltip>
          </Link>
        )}

        {user ? (
          <Tooltip title={user.username} arrow>
            <IconButton component={Link} href="/user/dashboard">
              <Avatar sx={{
                bgcolor: theme.palette.primary.main,
                width: 32,
                height: 32,
                fontSize: '0.9rem'
              }}>
                {user.username[0].toUpperCase()}
              </Avatar>
            </IconButton>
          </Tooltip>
        ) : (
          <Tooltip title={anonUsername ? "Iniciar sesión" : "Registrarse"} arrow>
            <IconButton
              component={Link}
              href={anonUsername ? "/user/auth/#login" : "/user/auth/#register"}
            >
              <Avatar sx={{
                bgcolor: theme.palette.grey[500],
                width: 32,
                height: 32,
                color: theme.palette.common.white
              }}>
                {anonUsername ? <Person fontSize="small" /> : <Key fontSize="small" />}
              </Avatar>
            </IconButton>
          </Tooltip>
        )}

        {/* Mostrar icono de puntos incluso cuando es 0 */}
        {enablePoints && gamification && (
          <Link href="/user/points" passHref>
            <IconButton className="notification-icon">
              <Star />
              <span className="notification-badge points-badge">{gamification.points || 0}</span>
            </IconButton>
          </Link>
        )}

        {gamification?.badges && enableBadges && (
          <Link href="/user/badges" passHref>
            <IconButton className="notification-icon">
              <EmojiEvents />
              <span className="notification-badge badges-badge">{gamification.badges.length}</span>
            </IconButton>
          </Link>
        )}
      </MobileBottomNav>
    </>
  );
}

// src/app/user/dashboard/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { Dialog, DialogTitle, DialogContent, DialogActions, Table, TableBody, TableCell, TableHead, TableRow, Link } from "@mui/material";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box, Grid, Card, CardContent, CardHeader, TextField, Button, Accordion, AccordionSummary, AccordionDetails, Typography, IconButton,
  Snackbar, Alert, MenuItem, Avatar, Chip, Divider, List, ListItem, ListItemAvatar, ListItemText, Badge, Paper, Tabs, Tab, useTheme, styled
} from "@mui/material";
import {
  AccountCircle, Lock, Payment, CreditCard, AddCircle, Delete, ExpandMore, Edit, History, AttachMoney, Security, Logout, Person,
  LocationOn, Language, Star, StarBorder,
  LocalActivity
} from "@mui/icons-material";
import { Integration } from "@/lib/types";

// Styled Components
const GradientCard = styled(Card)(({ theme }) => ({
  background: `linear-gradient(135deg, var(--primary) 0%, var(--primary-hover) 100%)`,
  color: 'white',
  borderRadius: '16px',
  boxShadow: theme.shadows[4]
}));

const GlassCard = styled(Card)(({ theme }) => ({
  background: 'rgba(248, 249, 250, 0.8)',
  backdropFilter: 'blur(10px)',
  border: '1px solid rgba(222, 226, 230, 0.5)',
  borderRadius: '16px',
  boxShadow: theme.shadows[2]
}));

interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
}

interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string;
}

interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}

export default function UserDashboard() {
  const { user, logout, updateProfile } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState({ email: "", username: "", ciudad: "", website: "" });
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [methods, setMethods] = useState<PaymentMethod[]>([]);
  const [newMethod, setNewMethod] = useState({ payment_type: "", details: "", is_default: false });
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>([]);
  const [credits, setCredits] = useState("");
  const [paymentAmount, setPaymentAmount] = useState("");
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [tabValue, setTabValue] = useState(0);
  const [editMethod, setEditMethod] = useState<PaymentMethod | null>(null);
  const [deleteMethodId, setDeleteMethodId] = useState<number | null>(null);
  const { coupons, setCoupons } = useAuth();
  const [newIntegration, setNewIntegration] = useState({ name: "", webhook_url: "", event_type: "" });
  const [integrations, setIntegrations] = useState<Integration[]>([]);



  // Añadir este useEffect justo después de los useState existentes
  useEffect(() => {
    const fetchCoupons = async () => {
      try {
        const { data } = await fetchAPI<any[]>("/v1/coupons/me"); // Ajusta el endpoint según tu API
        setCoupons(data || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar cupones");
      }
    };
    fetchCoupons();
  }, [setCoupons]);

  // Actualizar la función handleRedeem
  const handleRedeem = async (couponId: number) => {
    try {
      const { data } = await fetchAPI<any>(`/v1/coupons/redeem/${couponId}`, {
        method: "POST",
      });
      if (data) {
        setCoupons(coupons.map((c) => (c.id === couponId ? data : c)));
        const { data: info } = await fetchAPI<any>("/whoami");
        setCredits(info.credits);
        setSuccess("Cupón canjeado exitosamente");
      } else {
        setError("No se pudo canjear el cupón");
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al canjear cupón");
    }
  };

  // Actualizar el contenido de la pestaña "Coupons" (tabValue === 2)


  useEffect(() => {
    if (!user) {
      router.push("/");
      return;
    }
    setFormData({
      email: user.email || "",
      username: user.username || "",
      ciudad: user.ciudad || "",
      website: user.website || "",
    });

    const fetchData = async () => {
      try {
        const [transRes, methRes, providersRes, integrationsRes] = await Promise.all([
          fetchAPI<CreditTransaction[]>("/v1/payments/transactions"),
          fetchAPI<PaymentMethod[]>("/v1/payments/methods"),
          fetchAPI<PaymentProvider[]>("/v1/payment-providers"),
          fetchAPI<Integration[]>("/v1/integrations/"),
        ]);
        setTransactions(transRes.data || []);
        setMethods(methRes.data || []);
        setPaymentProviders(providersRes.data?.filter(p => p.active) || []);
        setIntegrations(integrationsRes.data || []);
        if (providersRes.data && providersRes.data.length > 0) {
          setNewMethod(prev => ({ ...prev, payment_type: providersRes.data.find(p => p.active)?.name || "" }));
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      }
    };
    fetchData();
  }, [user, router, credits]);

  const handleAddIntegration = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Integration>("/v1/integrations/", {
        method: "POST",
        data: { name: newIntegration.name, webhook_url: newIntegration.webhook_url, event_type: newIntegration.event_type },
      });
      setIntegrations([...integrations, data!]);
      setNewIntegration({ name: "", webhook_url: "", event_type: "" });
      setSuccess("Integración creada con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear integración");
    }
  };

  const handleDeleteIntegration = async (id: number) => {
    try {
      await fetchAPI(`/v1/integrations/${id}`, { method: "DELETE" });
      setIntegrations(integrations.filter((i) => i.id !== id));
      setSuccess("Integración eliminada");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar integración");
    }
  };

  const handleEditMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editMethod) return;
    try {
      const { data } = await fetchAPI<PaymentMethod>(`/v1/payments/methods/${editMethod.id}`, {
        method: "PUT",
        data: editMethod,
      });
      setMethods(methods.map((m) => (m.id === data!.id ? data! : m)));
      setEditMethod(null);
      setSuccess("Método actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar método");
    }
  };

  const handleDeleteMethod = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}`, { method: "DELETE" });
      setMethods(methods.filter((m) => m.id !== id));
      setDeleteMethodId(null);
      setSuccess("Método eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar método");
    }
  };

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateProfile(formData);
      setSuccess("Perfil actualizado");
      setEditMode(false);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar perfil");
    }
  };

  const handleChangePassword = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<{ message: string }>("/v1/auth/me/password", {
        method: "PUT",
        data: { current_password: currentPassword, new_password: newPassword },
      });
      setSuccess(data?.message || "Contraseña actualizada");
      setCurrentPassword("");
      setNewPassword("");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al cambiar contraseña");
    }
  };

  const handlePurchase = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<CreditTransaction>("/v1/payments/purchase", {
        method: "POST",
        data: { credits: parseInt(credits), payment_amount: parseFloat(paymentAmount), payment_method: "stripe" },
      });
      setTransactions([data!, ...transactions]);
      setCredits("");
      setPaymentAmount("");
      setSuccess("Créditos comprados");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al comprar créditos");
    }
  };

  const handleAddMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentMethod>("/v1/payments/methods", {
        method: "POST",
        data: newMethod,
      });
      setMethods([...methods, data!]);
      setNewMethod({ payment_type: paymentProviders[0]?.name || "", details: "", is_default: false });
      setSuccess("Método añadido");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir método");
    }
  };

  const handleSetDefault = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}/default`, { method: "PUT" });
      setMethods(methods.map((m) => ({ ...m, is_default: m.id === id })));
      setSuccess("Método predeterminado actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al establecer predeterminado");
    }
  };

  const handleDeleteAccount = async () => {
    if (confirm("¿Estás seguro de eliminar tu cuenta? Esta acción es irreversible.")) {
      try {
        await fetchAPI("/v1/users/me", { method: "DELETE" });
        await logout();
        router.push("/user/auth/#login");
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al eliminar cuenta");
      }
    }
  };

  if (!user) return (
    <Box sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h6" color="textSecondary">Cargando tu perfil...</Typography>
      </motion.div>
    </Box>
  );

  return (
    <Box sx={{
      p: { xs: 2, md: 4 },
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <Box sx={{ maxWidth: '1400px', mx: 'auto' }}>
        {/* Header Section */}
        <Box sx={{
          display: 'flex',
          flexDirection: { xs: 'column', md: 'row' },
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 4,
          gap: 2
        }}>
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                display: 'inline-block'
              }}
            >
              Hola, {user.username}!
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Bienvenido a tu panel de control
            </Typography>
          </motion.div>

          <Badge
            overlap="circular"
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            badgeContent={
              <IconButton onClick={() => setEditMode(true)} size="small" sx={{ bgcolor: 'primary.main', color: 'white' }}>
                <Edit fontSize="small" />
              </IconButton>
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.primary.main,
                fontSize: '2rem',
                boxShadow: theme.shadows[6]
              }}
            >
              {user.username.charAt(0).toUpperCase()}
            </Avatar>
          </Badge>
        </Box>

        {/* Stats Cards */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.1 }}
        >
          <Grid container spacing={3} sx={{ mb: 4 }}>
            {/* Credits Card */}
            <Grid item xs={12} md={4}>
              <GradientCard>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Tus Créditos
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {user.credits ?? 0}
                      </Typography>
                    </Box>
                    <AttachMoney sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Transactions Card */}
            <Grid item xs={12} md={4}>
              <GradientCard sx={{ background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)' }}>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Transacciones
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {transactions.length}
                      </Typography>
                    </Box>
                    <History sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Payment Methods Card */}
            <Grid item xs={12} md={4}>
              <GradientCard sx={{ background: 'linear-gradient(135deg, #a6c1ee 0%, #fbc2eb 100%)' }}>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Métodos de Pago
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {methods.length}
                      </Typography>
                    </Box>
                    <Payment sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Tabs Navigation */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <Paper sx={{ mb: 3, borderRadius: '12px', overflow: 'hidden' }}>
            <Tabs
              value={tabValue}
              onChange={(_, newValue) => setTabValue(newValue)}
              variant="scrollable"
              scrollButtons="auto"
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label="Perfil" icon={<Person />} iconPosition="start" />
              <Tab label="Seguridad" icon={<Security />} iconPosition="start" />
              <Tab label="Cupones" icon={<LocalActivity />} iconPosition="start" />
              <Tab label="Transacciones" icon={<History />} iconPosition="start" />
              <Tab label="Métodos de Pago" icon={<Payment />} iconPosition="start" />
              <Tab label="Comprar Créditos" icon={<CreditCard />} iconPosition="start" />
              <Tab label="Integraciones" icon={<Link />} iconPosition="start" />
            </Tabs>
          </Paper>
        </motion.div>

        {/* Tab Content */}
        <Box sx={{ mb: 4 }}>
          {/* Profile Tab */}
          {tabValue === 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Información Personal"
                      avatar={<AccountCircle color="primary" />}
                      action={
                        <IconButton onClick={() => setEditMode(!editMode)}>
                          <Edit color="primary" />
                        </IconButton>
                      }
                    />
                    <CardContent>
                      <AnimatePresence mode="wait">
                        {editMode ? (
                          <Box
                            component={motion.form}
                            key="edit"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                            onSubmit={handleUpdate}
                            sx={{ display: "flex", flexDirection: "column", gap: 2 }}
                          >
                            <TextField
                              label="Email"
                              type="email"
                              value={formData.email}
                              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Username"
                              type="text"
                              value={formData.username}
                              onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Ciudad"
                              type="text"
                              value={formData.ciudad}
                              onChange={(e) => setFormData({ ...formData, ciudad: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: <LocationOn color="action" sx={{ mr: 1 }} />
                              }}
                            />
                            <TextField
                              label="Website"
                              type="text"
                              value={formData.website}
                              onChange={(e) => setFormData({ ...formData, website: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: <Language color="action" sx={{ mr: 1 }} />
                              }}
                            />
                            <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
                              <Button
                                type="submit"
                                variant="contained"
                                color="primary"
                                sx={{ flex: 1 }}
                              >
                                Guardar Cambios
                              </Button>
                              <Button
                                onClick={() => setEditMode(false)}
                                variant="outlined"
                                sx={{ flex: 1 }}
                              >
                                Cancelar
                              </Button>
                            </Box>
                          </Box>
                        ) : (
                          <Box
                            component={motion.div}
                            key="view"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                          >
                            <List>
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.primary.light }}>
                                    <Person />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Username"
                                  secondary={user.username || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                                    <AccountCircle />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Email"
                                  secondary={user.email || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.success.light }}>
                                    <LocationOn />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Ciudad"
                                  secondary={user.ciudad || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.warning.light }}>
                                    <Language />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Website"
                                  secondary={user.website || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                            </List>
                          </Box>
                        )}
                      </AnimatePresence>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Actividad Reciente"
                      avatar={<History color="primary" />}
                    />
                    <CardContent>
                      {transactions.slice(0, 3).length > 0 ? (
                        <List>
                          {transactions.slice(0, 3).map((t) => (
                            <motion.div
                              key={t.id}
                              initial={{ opacity: 0 }}
                              animate={{ opacity: 1 }}
                              transition={{ duration: 0.3 }}
                            >
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{
                                    bgcolor: t.amount > 0 ? theme.palette.success.light : theme.palette.error.light
                                  }}>
                                    {t.amount > 0 ? "+" : "-"}
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary={`${t.transaction_type}`}
                                  secondary={`${new Date(t.timestamp).toLocaleString()} • ${t.payment_status}`}
                                />
                                <Typography variant="body2" color={t.amount > 0 ? "success.main" : "error.main"}>
                                  {t.amount > 0 ? "+" : ""}{t.amount} créditos
                                </Typography>
                              </ListItem>
                              <Divider variant="inset" component="li" />
                            </motion.div>
                          ))}
                        </List>
                      ) : (
                        <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 2 }}>
                          No hay actividad reciente
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(2)}
                      >
                        Ver todas las transacciones
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>

              {/* Danger Zone moved to Profile Tab */}
              <GlassCard sx={{ mt: 3 }}>
                <CardHeader
                  title="Zona Peligrosa"
                  avatar={<Security color="error" />}
                />
                <CardContent>
                  <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                    Estas acciones son irreversibles. Por favor, procede con precaución.
                  </Typography>
                  <Box sx={{ display: 'flex', gap: 2 }}>
                    <Button
                      onClick={logout}
                      variant="outlined"
                      color="secondary"
                      startIcon={<Logout />}
                      sx={{ flex: 1 }}
                    >
                      Cerrar Sesión
                    </Button>
                    <Button
                      onClick={handleDeleteAccount}
                      variant="contained"
                      color="error"
                      startIcon={<Delete />}
                      sx={{ flex: 1 }}
                    >
                      Eliminar Cuenta
                    </Button>
                  </Box>
                </CardContent>
              </GlassCard>
            </motion.div>
          )}

          {/* Security Tab */}
          {tabValue === 1 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Cambiar Contraseña"
                      avatar={<Lock color="primary" />}
                    />
                    <CardContent>
                      <Box
                        component="form"
                        onSubmit={handleChangePassword}
                        sx={{ display: "flex", flexDirection: "column", gap: 2 }}
                      >
                        <TextField
                          label="Contraseña Actual"
                          type="password"
                          value={currentPassword}
                          onChange={(e) => setCurrentPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: <Lock color="action" sx={{ mr: 1 }} />
                          }}
                        />
                        <TextField
                          label="Nueva Contraseña"
                          type="password"
                          value={newPassword}
                          onChange={(e) => setNewPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: <Security color="action" sx={{ mr: 1 }} />
                          }}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          sx={{ mt: 1 }}
                        >
                          Actualizar Contraseña
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Métodos de Pago"
                      subheader={`${methods.length} configurados`}
                      avatar={<Payment color="primary" />}
                    />
                    <CardContent>
                      {methods.length > 0 ? (
                        <List>
                          {methods.slice(0, 2).map((m) => (
                            <ListItem key={m.id}>
                              <ListItemAvatar>
                                <Avatar sx={{ bgcolor: m.is_default ? theme.palette.success.light : theme.palette.grey[300] }}>
                                  {m.is_default ? <Star /> : <StarBorder />}
                                </Avatar>
                              </ListItemAvatar>
                              <ListItemText
                                primary={m.payment_type}
                                secondary={m.details}
                              />
                            </ListItem>
                          ))}
                        </List>
                      ) : (
                        <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 2 }}>
                          No hay métodos de pago configurados
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(3)}
                      >
                        {methods.length > 0 ? 'Gestionar métodos' : 'Añadir método'}
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}

          {/* Coupons Tab */}
          {tabValue === 2 && (

            <Box>
              <Typography variant="h6">Mis Cupones</Typography>
              {(!coupons || coupons.length === 0) ? (
                <Typography>No tienes cupones</Typography>
              ) : (
                <Table>
                  <TableHead>
                    <TableRow>
                      <TableCell>Nombre</TableCell>
                      <TableCell>Créditos</TableCell>
                      <TableCell>Estado</TableCell>
                      <TableCell>Acciones</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {coupons.map((coupon) => (
                      <TableRow key={coupon.id}>
                        <TableCell>{coupon.name}</TableCell>
                        <TableCell>{coupon.credits}</TableCell>
                        <TableCell>
                          <Chip
                            label={coupon.status}
                            color={coupon.status === "active" ? "success" : "error"}
                          />
                        </TableCell>
                        <TableCell>
                          {coupon.status === "active" && (
                            <Button
                              variant="contained"
                              onClick={() => handleRedeem(coupon.id)}
                            >
                              Canjear
                            </Button>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              )}
            </Box>
          )
          }



          {/* Transactions Tab */}
          {tabValue === 3 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <GlassCard>
                <CardHeader
                  title="Historial de Transacciones"
                  avatar={<History color="primary" />}
                  action={
                    <Chip
                      label={`${transactions.length} transacciones`}
                      color="primary"
                      variant="outlined"
                    />
                  }
                />
                <CardContent>
                  {transactions.length === 0 ? (
                    <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 4 }}>
                      No hay transacciones registradas
                    </Typography>
                  ) : (
                    <List sx={{ maxHeight: '500px', overflow: 'auto' }}>
                      {transactions.map((t, index) => (
                        <motion.div
                          key={t.id || index} // Usar `index` como respaldo si `t.id` no está definido
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          transition={{ duration: 0.2 }}
                        >
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{
                                bgcolor: t.amount > 0 ? theme.palette.success.light : theme.palette.error.light
                              }}>
                                {t.amount > 0 ? "+" : "-"}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={t.transaction_type || "N/A"}
                              secondary={`${t.timestamp ? new Date(t.timestamp).toLocaleString() : "N/A"} • ${t.payment_status || "N/A"}`}
                            />
                          </ListItem>
                          <Divider variant="inset" component="li" />
                        </motion.div>
                      ))}
                    </List>
                  )}
                </CardContent>
              </GlassCard>
            </motion.div>
          )}

          {/* Payment Methods Tab */}
          {tabValue === 4 && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
              <GlassCard>
                <CardHeader
                  title="Métodos de Pago"
                  avatar={<Payment color="primary" />}
                  subheader="Gestiona tus métodos de pago asociados"
                />
                <CardContent>
                  {methods.length > 0 && (
                    <List sx={{ mb: 3 }}>
                      {methods.map((m) => (
                        <Paper key={m.id} elevation={2} sx={{ mb: 2, borderRadius: "8px", overflow: "hidden" }}>
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{ bgcolor: m.is_default ? theme.palette.success.main : theme.palette.grey[300] }}>
                                {m.is_default ? <Star /> : <CreditCard />}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={
                                <Box sx={{ display: "flex", alignItems: "center" }}>
                                  <Typography sx={{ mr: 1 }}>{m.payment_type}</Typography>
                                  {m.is_default && (
                                    <Chip label="Predeterminado" size="small" color="success" variant="outlined" />
                                  )}
                                </Box>
                              }
                              secondary={m.details}
                            />
                            <Box sx={{ display: "flex", gap: 1 }}>
                              <IconButton onClick={() => setEditMethod(m)} color="primary">
                                <Edit />
                              </IconButton>
                              <IconButton onClick={() => setDeleteMethodId(m.id)} color="error">
                                <Delete />
                              </IconButton>
                              {!m.is_default && (
                                <Button
                                  onClick={() => handleSetDefault(m.id)}
                                  variant="outlined"
                                  size="small"
                                >
                                  Hacer Predeterminado
                                </Button>
                              )}
                            </Box>
                          </ListItem>
                        </Paper>
                      ))}
                    </List>
                  )}

                  {/* Formulario para añadir método */}
                  <Accordion
                    sx={{
                      background: "rgba(255, 255, 255, 0.05)",
                      boxShadow: "none",
                      border: "1px solid rgba(255, 255, 255, 0.2)",
                    }}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Typography>Añadir nuevo método de pago</Typography>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Box component="form" onSubmit={handleAddMethod} sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <TextField
                          label="Tipo"
                          select
                          value={newMethod.payment_type}
                          onChange={(e) => setNewMethod({ ...newMethod, payment_type: e.target.value })}
                          fullWidth
                          variant="outlined"
                          size="small"
                        >
                          {paymentProviders.map((provider) => (
                            <MenuItem key={provider.id} value={provider.name}>
                              {provider.name}
                            </MenuItem>
                          ))}
                        </TextField>
                        <TextField
                          label="Detalles"
                          value={newMethod.details}
                          onChange={(e) => setNewMethod({ ...newMethod, details: e.target.value })}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          multiline
                          rows={3}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          startIcon={<AddCircle />}
                          sx={{ mt: 1 }}
                        >
                          Añadir Método
                        </Button>
                      </Box>
                    </AccordionDetails>
                  </Accordion>
                </CardContent>
              </GlassCard>

              {/* Diálogo para editar método */}
              <Dialog open={!!editMethod} onClose={() => setEditMethod(null)}>
                <DialogTitle>Editar Método de Pago</DialogTitle>
                <DialogContent>
                  <Box
                    component="form"
                    onSubmit={handleEditMethod}
                    sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}
                  >
                    <TextField
                      label="Tipo"
                      select
                      value={editMethod?.payment_type || ""}
                      onChange={(e) => setEditMethod({ ...editMethod!, payment_type: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                    >
                      {paymentProviders.map((provider) => (
                        <MenuItem key={provider.id} value={provider.name}>
                          {provider.name}
                        </MenuItem>
                      ))}
                    </TextField>
                    <TextField
                      label="Detalles"
                      value={editMethod?.details || ""}
                      onChange={(e) => setEditMethod({ ...editMethod!, details: e.target.value })}
                      fullWidth
                      required
                      variant="outlined"
                      size="small"
                      multiline
                      rows={3}
                    />
                    <DialogActions>
                      <Button onClick={() => setEditMethod(null)} variant="outlined">
                        Cancelar
                      </Button>
                      <Button type="submit" variant="contained" color="primary">
                        Guardar
                      </Button>
                    </DialogActions>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Diálogo para confirmar eliminación */}
              <Dialog open={!!deleteMethodId} onClose={() => setDeleteMethodId(null)}>
                <DialogTitle>¿Eliminar Método de Pago?</DialogTitle>
                <DialogContent>
                  <Typography>Esta acción es irreversible. ¿Estás seguro de eliminar este método?</Typography>
                </DialogContent>
                <DialogActions>
                  <Button onClick={() => setDeleteMethodId(null)} variant="outlined">
                    Cancelar
                  </Button>
                  <Button
                    onClick={() => handleDeleteMethod(deleteMethodId!)}
                    variant="contained"
                    color="error"
                  >
                    Eliminar
                  </Button>
                </DialogActions>
              </Dialog>
            </motion.div>
          )}

          {/* Buy Credits Tab */}
          {tabValue === 5 && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader title="Comprar Créditos" avatar={<AttachMoney color="primary" />} subheader="Recarga tu saldo de créditos" />
                    <CardContent>
                      <Box component="form" onSubmit={handlePurchase} sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <TextField
                          label="Cantidad de Créditos"
                          type="number"
                          value={credits}
                          onChange={(e) => setCredits(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{ startAdornment: <AttachMoney color="action" sx={{ mr: 1 }} /> }}
                        />
                        <TextField
                          label="Monto a Pagar (USD)"
                          type="number"
                          inputProps={{ step: "0.01" }}
                          value={paymentAmount}
                          onChange={(e) => setPaymentAmount(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{ startAdornment: <Typography sx={{ mr: 1 }}>$</Typography> }}
                        />
                        <TextField
                          label="Método de Pago"
                          select
                          value={methods.find((m) => m.is_default)?.id || methods[0]?.id || ""}
                          onChange={(e) => {
                            const selectedMethod = methods.find((m) => m.id === parseInt(e.target.value));
                            if (selectedMethod) {
                              handleSetDefault(selectedMethod.id);
                            }
                          }}
                          fullWidth
                          variant="outlined"
                          size="small"
                          disabled={methods.length === 0}
                          helperText={methods.length === 0 ? "No hay métodos de pago disponibles" : "Selecciona un método de pago"}
                        >
                          {methods.map((method) => (
                            <MenuItem key={method.id} value={method.id}>
                              {method.payment_type} - {method.details} {method.is_default ? "(Predeterminado)" : ""}
                            </MenuItem>
                          ))}
                        </TextField>
                        <Button type="submit" variant="contained" color="primary" size="large" sx={{ mt: 2 }} disabled={methods.length === 0}>
                          Comprar Créditos
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader title="Tarifas y Beneficios" avatar={<CreditCard color="primary" />} />
                    <CardContent>
                      <List>
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.success.light }}>
                              <Star />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="1 crédito = $1 USD" secondary="Tasa de cambio fija" />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                              <Payment />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="Múltiples métodos de pago" secondary="Tarjetas, PayPal y más" />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.warning.light }}>
                              <Security />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="Transacciones seguras" secondary="Encriptación SSL" />
                        </ListItem>
                      </List>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}

          {tabValue === 6 && (
            <Box>
              <Box component="form" onSubmit={handleAddIntegration} sx={{ mb: 2 }}>
                <TextField label="Nombre" value={newIntegration.name} onChange={(e) => setNewIntegration({ ...newIntegration, name: e.target.value })} />
                <TextField label="Webhook URL" value={newIntegration.webhook_url} onChange={(e) => setNewIntegration({ ...newIntegration, webhook_url: e.target.value })} />
                <TextField label="Tipo de Evento" value={newIntegration.event_type} onChange={(e) => setNewIntegration({ ...newIntegration, event_type: e.target.value })} />
                <Button type="submit" variant="contained">Añadir</Button>
              </Box>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Nombre</TableCell>
                    <TableCell>Estado</TableCell>
                    <TableCell>Acciones</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {integrations.map((integration) => (
                    <TableRow key={integration.id}>
                      <TableCell>{integration.name}</TableCell>
                      <TableCell>{integration.active ? "Activo (Admin)" : "Pendiente"}</TableCell>
                      <TableCell>
                        <IconButton onClick={() => handleDeleteIntegration(integration.id)} color="error">
                          <Delete />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Box>
          )}
        </Box>
      </Box>

      {/* Notifications */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box >
  );
}


// frontend/src/app/admin/dashboard/page.tsx
// Panel de administración principal para configuración y gestión
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { AnimatePresence, motion } from "framer-motion";
import {
  Tabs,
  Tab,
  Card,
  CardContent,
  TextField,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Typography,
  IconButton,
  Snackbar,
  Alert,
  Avatar,
  Chip,
  Divider,
  List,
  ListItem,
  ListItemText,
  Badge as MuiBadge,
  Paper,
  useTheme,
  styled,
  Box,
  Switch,
  FormControlLabel,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Dialog,
  DialogTitle,
  DialogContent,
  Select,
  MenuItem,
} from "@mui/material";
import Grid from "@mui/material/Grid";
import {
  AddCircle,
  Delete,
  ExpandMore,
  Settings,
  Public,
  Link,
  Webhook,
  CheckCircle,
  Cancel,
  Security,
  PersonAdd,
  LockPerson,
  PeopleOutline,
  AttachMoney,
  Edit,
  EmojiEvents,
  MonetizationOn,
  LocalActivity
} from "@mui/icons-material";
import { SiteSetting, Integration, EventType, Badge, PaymentProvider, Coupon, CouponType } from "@/lib/types";
import { AdminGradientCard, ConfigGlassCard, FeatureCard } from '@/components/ui/Styled';

interface AllowedOrigin {
  id: number;
  origin: string;
}

export default function ConfigurePage() {
  const { user } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [activeTab, setActiveTab] = useState(0);
  const [settingsByTag, setSettingsByTag] = useState<Record<string, SiteSetting[]>>({});
  const [origins, setOrigins] = useState<string[]>([]); // Inicializar como array vacío
  const [integrations, setIntegrations] = useState<Integration[]>([]);
  const [newOrigin, setNewOrigin] = useState("");
  const [newIntegration, setNewIntegration] = useState({ name: "", webhook_url: "", event_type: "" });
  const [features, setFeatures] = useState({
    enable_registration: true,
    enable_social_login: true,
    disable_anonymous_users: false,
    disable_credits: false,
    enable_payment_methods: true,
    enable_points: true,
    enable_badges: true,
    enable_coupons: true,
  });

  const [eventTypes, setEventTypes] = useState<EventType[]>([]);
  const [badges, setBadges] = useState<Badge[]>([]);
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>([]);
  const [editEventType, setEditEventType] = useState<EventType | null>(null);
  const [editBadge, setEditBadge] = useState<Badge | null>(null);
  const [editPaymentProvider, setEditPaymentProvider] = useState<PaymentProvider | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [expandedSettings, setExpandedSettings] = useState<Record<string, boolean>>({});
  const [allSettingsExpanded, setAllSettingsExpanded] = useState(false);
  const [coupons, setCoupons] = useState<Coupon[]>([]);
  const [editCoupon, setEditCoupon] = useState<Coupon | null>(null);
  const [couponTypes, setCouponTypes] = useState<CouponType[]>([]);
  const [editCouponType, setEditCouponType] = useState<CouponType | null>(null);
  const [corsEnabled, setCorsEnabled] = useState<boolean | null>(null); // Inicializamos como null para indicar que aún no se ha cargado el estado.


  const [selectedUserId, setSelectedUserId] = useState<number | null>(null);

  // Agregamos un estado de carga para controlar el renderizado inicial del panel.
  const [loadingPanel, setLoadingPanel] = useState(true);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const { data } = await fetchAPI<PaymentProvider[]>("/v1/payment-providers");
        setPaymentProviders(data || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar proveedores");
      }
    };
    fetchData();
  }, []);



  useEffect(() => {
    if (!user || user.rol !== "admin") {
      router.push("/");
      return;
    }

    const fetchData = async () => {
      try {
        const settingsRes = await fetchAPI<SiteSetting[]>("/v1/settings/admin/config");
        const grouped = settingsRes.data?.reduce((acc, setting) => {
          const tag = setting.tag || "General";
          if (!acc[tag]) acc[tag] = [];
          acc[tag].push(setting);
          return acc;
        }, {} as Record<string, SiteSetting[]>);
        setSettingsByTag(grouped || {});

        // Initialize expanded state for settings
        if (grouped) {
          const initialExpandedState = Object.keys(grouped).reduce((acc, tag) => {
            acc[tag] = false;
            return acc;
          }, {} as Record<string, boolean>);
          setExpandedSettings(initialExpandedState);
        }

        const originsRes = await fetchAPI<string[]>("/v1/settings/allowed_origins");
        setOrigins(originsRes.data || []);

        const integrationsRes = await fetchAPI<Integration[]>("/v1/integrations/");
        setIntegrations(integrationsRes.data || []);

        const eventTypesRes = await fetchAPI<EventType[]>("/v1/gamification/event-types");
        setEventTypes(eventTypesRes.data || []);

        const badgesRes = await fetchAPI<Badge[]>("/v1/gamification/badges");
        setBadges(badgesRes.data || []);

        const paymentProvidersRes = await fetchAPI<PaymentProvider[]>("/v1/payment-providers");
        setPaymentProviders(paymentProvidersRes.data || []);


        const couponTypesRes = await fetchAPI<CouponType[]>("/v1/coupons/types");
        setCouponTypes(couponTypesRes.data || []);

        const couponsRes = await fetchAPI<Coupon[]>("/v1/coupons/");
        setCoupons(couponsRes.data || []);

        const featuresRes = await Promise.all([
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_social_login"),
          fetchAPI("/v1/settings/disable_anonymous_users"),
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_payment_methods"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_badges"),
          fetchAPI("/v1/settings/enable_coupons"),
        ]);
        setFeatures({
          enable_registration: featuresRes[0].data === "true",
          enable_social_login: featuresRes[1].data === "true",
          disable_anonymous_users: featuresRes[2].data === "true",
          disable_credits: featuresRes[3].data === "true",
          enable_payment_methods: featuresRes[4].data === "true",
          enable_points: featuresRes[5].data === "true",
          enable_badges: featuresRes[6].data === "true",
          enable_coupons: featuresRes[7].data === "true",
        });
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [user, router]);

  useEffect(() => {
    const fetchCorsSettings = async () => {
      try {
        console.log("Fetching CORS settings..."); // Depuración
        const { data: corsEnabledData } = await fetchAPI("/v1/settings/cors_enabled");
        console.log("CORS enabled data:", corsEnabledData); // Depuración
        const enabled = corsEnabledData === "true";
        setCorsEnabled(enabled);

        console.log("Fetching origins..."); // Depuración
        const { data: originsData } = await fetchAPI<AllowedOrigin[]>("/v1/origins");
        console.log("Origins data:", originsData); // Depuración
        setOrigins(Array.isArray(originsData) ? originsData.map(o => o.origin) : []);
      } catch (err) {
        console.error("Error fetching CORS settings or origins:", err); // Depuración
        setError(err instanceof Error ? err.message : "Error al cargar configuración de CORS");
      } finally {
        setLoadingPanel(false); // Finalizamos el estado de carga del panel
      }
    };
    fetchCorsSettings();
  }, []); // Cambiar dependencia a [] para que solo se ejecute una vez al montar el componente

  // Asegurarse de que origins sea siempre un array válido
  useEffect(() => {
    if (!Array.isArray(origins)) {
      setOrigins([]);
    }
  }, [origins]);

  const handleToggleCors = async () => {
    try {
      const { data } = await fetchAPI<{ key: string; value: boolean }>("/v1/settings/admin/config", {
        method: "POST",
        data: { key: "allowed_origins", value: !corsEnabled },
      });
      setCorsEnabled(data!.value);
      setSuccess(`CORS ${data!.value ? "activado" : "desactivado"}`);
      refreshOrigins(); // Asegurar que se refresque la lista de orígenes después de cambiar el estado de CORS
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar CORS");
    }
  };


  //const handleToggleIntegration = async (id: number, active: boolean) => {
  //  await fetchAPI(`/v1/integrations/${id}/toggle`, { method: "PUT" });
  // Actualizar estado local
  //};

  const groupedBadges = badges.reduce((acc, badge) => {
    const key = badge.event_type_id;
    if (!acc[key]) acc[key] = [];
    acc[key].push(badge);
    return acc;
  }, {} as Record<number, Badge[]>);

  const toggleAllSettings = () => {
    const newState = !allSettingsExpanded;
    setAllSettingsExpanded(newState);
    const updatedExpandedSettings = Object.keys(expandedSettings).reduce((acc, tag) => {
      acc[tag] = newState;
      return acc;
    }, {} as Record<string, boolean>);
    setExpandedSettings(updatedExpandedSettings);
  };

  const handleSaveSetting = async (key: string, newValue: string) => {
    try {
      await fetchAPI("/v1/settings/admin/config", { method: "POST", data: { key, value: newValue } });
      setSettingsByTag((prev) => {
        const updated = { ...prev };
        for (const tag in updated) {
          updated[tag] = updated[tag].map((s) => (s.key === key ? { ...s, value: newValue } : s));
        }
        return updated;
      });
      setSuccess("Configuración actualizada");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al guardar configuración");
    }
  };

  const refreshOrigins = async () => {
    try {
      console.log("Refreshing origins..."); // Depuración
      const { data: originsData } = await fetchAPI<AllowedOrigin[]>("/v1/origins");
      console.log("Refreshed origins data:", originsData); // Depuración
      setOrigins(Array.isArray(originsData) ? originsData.map(o => o.origin) : []);
    } catch (err) {
      console.error("Error refreshing origins:", err); // Depuración
      setError(err instanceof Error ? err.message : "Error al refrescar orígenes");
    }
  };

  const handleAddOrigin = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await fetchAPI("/v1/settings/allowed-origins", { method: "POST", data: { origin: newOrigin } });
      setNewOrigin("");
      setSuccess("Origen añadido con éxito");
      refreshOrigins(); // Refrescar la lista de orígenes
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir origen");
    }
  };

  const handleDeleteOrigin = async (origin: string) => {
    try {
      await fetchAPI(`/v1/settings/allowed-origins/${encodeURIComponent(origin)}`, { method: "DELETE" });
      setSuccess("Origen eliminado con éxito");
      refreshOrigins(); // Refrescar la lista de orígenes
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar origen");
    }
  };

  const handleAddIntegration = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Integration>("/v1/integrations/", {
        method: "POST",
        data: { name: newIntegration.name, webhook_url: newIntegration.webhook_url, event_type: newIntegration.event_type },
      });
      setIntegrations([...integrations, data]);
      setNewIntegration({ name: "", webhook_url: "", event_type: "" });
      setSuccess("Integración creada con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear integración");
    }
  };

  const handleToggleIntegration = async (id: number, active: boolean) => {
    try {
      const { data } = await fetchAPI<{ id: number; active: boolean }>(`/v1/integrations/${id}/toggle`, {
        method: "PUT",
      });
      setIntegrations((prev) =>
        prev.map((integration) =>
          integration.id === id ? { ...integration, active: data!.active } : integration
        )
      );
      setSuccess(`Integración ${data!.active ? "activada" : "desactivada"}`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar integración");
    }
  };

  const handleDeleteIntegration = async (id: number) => {
    try {
      await fetchAPI(`/v1/integrations/${id}`, { method: "DELETE" });
      setIntegrations(integrations.filter(i => i.id !== id));
      setSuccess("Integración eliminada con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar integración");
    }
  };

  const handleToggleFeature = async (feature: string, enabled: boolean) => {
    try {
      await fetchAPI("/v1/settings/admin/config", { method: "POST", data: { key: feature, value: enabled.toString() } });
      setFeatures((prev) => ({ ...prev, [feature]: enabled }));
      setSuccess(`Funcionalidad ${enabled ? "activada" : "desactivada"} con éxito`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar funcionalidad");
    }
  };

  const handleCreateEventType = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<EventType>("/v1/gamification/event-types", { method: "POST", data: editEventType });
      setEventTypes([...eventTypes, data!]);
      setEditEventType(null);
      setSuccess("Tipo de evento creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear tipo de evento");
    }
  };

  const handleUpdateEventType = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editEventType?.id) return;
    try {
      const { data } = await fetchAPI<EventType>(`/v1/gamification/event-types/${editEventType.id}`, { method: "PUT", data: editEventType });
      setEventTypes(eventTypes.map((et) => (et.id === data!.id ? data! : et)));
      setEditEventType(null);
      setSuccess("Tipo de evento actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar tipo de evento");
    }
  };

  const handleDeleteEventType = async (id: number) => {
    try {
      await fetchAPI(`/v1/gamification/event-types/${id}`, { method: "DELETE" });
      setEventTypes(eventTypes.filter((et) => (et.id !== id)));
      setSuccess("Tipo de evento eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar tipo de evento");
    }
  };

  const handleCreateBadge = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Badge>("/v1/gamification/badges", { method: "POST", data: editBadge });
      setBadges([...badges, data!]);
      setEditBadge(null);
      setSuccess("Badge creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear badge");
    }
  };

  const handleUpdateBadge = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editBadge?.id) return;
    try {
      const { data } = await fetchAPI<Badge>(`/v1/gamification/badges/${editBadge.id}`, { method: "PUT", data: editBadge });
      setBadges(badges.map((b) => (b.id === data!.id ? data! : b)));
      setEditBadge(null);
      setSuccess("Badge actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar badge");
    }
  };

  const handleDeleteBadge = async (id: number) => {
    try {
      await fetchAPI(`/v1/gamification/badges/${id}`, { method: "DELETE" });
      setBadges(badges.filter((b) => b.id !== id));
      setSuccess("Badge eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar badge");
    }
  };

  const handleTogglePaymentProvider = async (id: number, active: boolean) => {
    try {
      const provider = paymentProviders.find(p => p.id === id);
      if (!provider) throw new Error("Proveedor no encontrado");
      const updatedProvider = { ...provider, active: !active }; // Invertir el estado
      const { data } = await fetchAPI<PaymentProvider>(`/v1/payment-providers/${id}`, {
        method: "PUT",
        data: updatedProvider,
      });
      setPaymentProviders(paymentProviders.map((p) => (p.id === data!.id ? data! : p)));
      setSuccess(`Proveedor ${!active ? "activado" : "desactivado"}`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar proveedor");
    }
  };

  const handleCreatePaymentProvider = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentProvider>("/v1/payment-providers", { method: "POST", data: editPaymentProvider });
      setPaymentProviders([...paymentProviders, data!]);
      setEditPaymentProvider(null);
      setSuccess("Proveedor creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear proveedor");
    }
  };

  const handleUpdatePaymentProvider = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editPaymentProvider?.id) return;
    try {
      const { data } = await fetchAPI<PaymentProvider>(`/v1/payment-providers/${editPaymentProvider.id}`, {
        method: "PUT",
        data: editPaymentProvider,
      });
      setPaymentProviders(paymentProviders.map((p) => (p.id === data!.id ? data! : p)));
      setEditPaymentProvider(null);
      setSuccess("Proveedor actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar proveedor");
    }
  };

  const handleDeletePaymentProvider = async (id: number) => {
    try {
      await fetchAPI(`/v1/payment-providers/${id}`, { method: "DELETE" });
      setPaymentProviders(paymentProviders.filter((p) => p.id !== id));
      setSuccess("Proveedor eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar proveedor");
    }
  };


  // Funciones para manejar cupones
  const handleSubmitCouponType = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editCouponType) return;
    try {
      if (editCouponType.id) {
        const { data } = await fetchAPI<CouponType>(`/v1/coupons/types/${editCouponType.id}`, {
          method: "PUT",
          data: editCouponType,
        });
        setCouponTypes(couponTypes.map(ct => ct.id === data!.id ? data! : ct));
      } else {
        const { data } = await fetchAPI<CouponType>("/v1/coupons/types", {
          method: "POST",
          data: editCouponType,
        });
        setCouponTypes([...couponTypes, data!]);
      }
      setEditCouponType(null);
      setSuccess("Tipo de cupón guardado con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al guardar tipo de cupón");
    }
  };

  const handleDeleteCoupon = async (id: number) => {
    try {
      await fetchAPI(`/v1/coupons/${id}`, { method: "DELETE" });
      setCoupons(coupons.filter((c) => c.id !== id));
      setSuccess("Cupón eliminado con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar cupón");
    }
  };

  if (loading) return (
    <Box sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h6" color="textSecondary">Cargando panel de administración...</Typography>
      </motion.div>
    </Box>
  );

  // Modificamos el renderizado del panel para manejar el estado de carga inicial
  if (loadingPanel) {
    return <Typography>Cargando panel de administración...</Typography>;
  }

  return (
    <Box sx={{
      p: { xs: 2, md: 4 },
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <Box sx={{ maxWidth: '1400px', mx: 'auto' }}>
        {/* Header Section */}
        <Box sx={{
          display: 'flex',
          flexDirection: { xs: 'column', md: 'row' },
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 4,
          gap: 2
        }}>
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                display: 'inline-block'
              }}
            >
              Panel de Administración
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Gestiona la configuración del sistema
            </Typography>
          </motion.div>

          <MuiBadge
            overlap="circular"
            badgeContent={
              <Chip
                label="Admin"
                size="small"
                color="primary"
                sx={{
                  position: 'absolute',
                  top: -10,
                  right: -10,
                  fontWeight: 'bold'
                }}
              />
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.error.main,
                fontSize: '2rem',
                boxShadow: theme.shadows[6]
              }}
            >
              {user?.username?.charAt(0).toUpperCase()}
            </Avatar>
          </MuiBadge>
        </Box>

        {/* Stats Cards */}
        <Box sx={{ display: 'flex', gap: 3, mb: 4, flexWrap: 'wrap' }}>
          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Configuraciones
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {Object.values(settingsByTag).flat().length}
                  </Typography>
                </Box>
                <Settings sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Orígenes Permitidos
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {origins.length}
                  </Typography>
                </Box>
                <Public sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Integraciones
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {integrations.length}
                  </Typography>
                </Box>
                <Webhook sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Gamificación
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {eventTypes.length}
                  </Typography>
                </Box>
                <EmojiEvents sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Pagos
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {paymentProviders.length}
                  </Typography>
                </Box>
                <MonetizationOn sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>
        </Box>

        {/* Tabs Navigation */}
        <Paper sx={{ mb: 3, borderRadius: '12px', overflow: 'hidden' }}>
          <Tabs
            value={activeTab}
            onChange={(_, newValue) => setActiveTab(newValue)}
            variant="scrollable"
            scrollButtons="auto"
            indicatorColor="primary"
            textColor="primary"
          >
            <Tab label="Funcionalidades" icon={<LockPerson />} iconPosition="start" />
            <Tab label="Orígenes" icon={<Security />} iconPosition="start" />
            <Tab label="Integraciones" icon={<Link />} iconPosition="start" />
            <Tab label="Gamificación" icon={<EmojiEvents />} iconPosition="start" />
            <Tab label="Cupones" icon={<LocalActivity />} iconPosition="start" />
            <Tab label="Pagos" icon={<MonetizationOn />} iconPosition="start" />
            <Tab label="Configuraciones" icon={<Settings />} iconPosition="start" />
          </Tabs>
        </Paper>

        {/* Tab Content */}
        <motion.div
          key={activeTab}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* Funcionalidades Tab */}
          {activeTab === 0 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <LockPerson sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Control de Funcionalidades del Sistema
                  </Typography>

                  <Grid container spacing={3}>
                    {/* Tarjeta para Registro */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_registration ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PersonAdd sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_registration ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Registro de Usuarios</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Controla si los nuevos usuarios pueden registrarse
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_registration ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_registration ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_registration}
                              onChange={(e) => handleToggleFeature('enable_registration', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_registration')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Login Social */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_social_login ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PeopleOutline sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_social_login ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Login Social</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Permite inicio de sesión con redes sociales
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_social_login ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_social_login ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_social_login}
                              onChange={(e) => handleToggleFeature('enable_social_login', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_social_login')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Usuarios Anónimos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.disable_anonymous_users ? theme.palette.error.main : theme.palette.success.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <Security sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.disable_anonymous_users ? theme.palette.error.main : theme.palette.success.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Usuarios Anónimos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Controla el acceso de usuarios no registrados
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.disable_anonymous_users ? "Bloqueados" : "Permitidos"}
                                size="small"
                                color={features.disable_anonymous_users ? "error" : "success"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.disable_anonymous_users}
                              onChange={(e) => handleToggleFeature('disable_anonymous_users', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('disable_anonymous_users')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Sistema de Créditos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.disable_credits ? theme.palette.error.main : theme.palette.success.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <AttachMoney sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.disable_credits ? theme.palette.error.main : theme.palette.success.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Créditos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita/deshabilita el uso de créditos
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.disable_credits ? "Desactivado" : "Activado"}
                                size="small"
                                color={features.disable_credits ? "error" : "success"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={!features.disable_credits}
                              onChange={(e) => handleToggleFeature('disable_credits', !e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('disable_credits')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Métodos de Pago */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_payment_methods ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <MonetizationOn sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_payment_methods ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Métodos de Pago</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita diferentes opciones de pago
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_payment_methods ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_payment_methods ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_payment_methods}
                              onChange={(e) => handleToggleFeature('enable_payment_methods', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_payment_methods')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Sistema de Puntos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_points ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_points ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Puntos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Activa puntos por actividades
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_points ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_points ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_points}
                              onChange={(e) => handleToggleFeature('enable_points', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_points')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Insignias */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_badges ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_badges ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Insignias</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Permite la obtención de insignias
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_badges ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_badges ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_badges}
                              onChange={(e) => handleToggleFeature('enable_badges', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_badges')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Cupones */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_coupons ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_coupons ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Cupones</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita el sistema de cupones
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_coupons ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_coupons ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_coupons}
                              onChange={(e) => handleToggleFeature('enable_coupons', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_coupons')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                  </Grid>
                </CardContent>
              </ConfigGlassCard>
            </Box>
          )}

          {/* Orígenes Permitidos Tab */}
          {activeTab === 1 && (
            <Box>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}>
                <Typography variant="h6">Orígenes Permitidos</Typography>
                {corsEnabled === null ? (
                  <Typography>Cargando configuración de CORS...</Typography>
                ) : (
                  <Switch checked={corsEnabled} onChange={handleToggleCors} />
                )}
              </Box>
              {corsEnabled && (
                <Box component="form" onSubmit={handleAddOrigin} sx={{ mb: 2 }}>
                  <TextField
                    label="Nuevo Origen"
                    value={newOrigin}
                    onChange={(e) => setNewOrigin(e.target.value)}
                    fullWidth
                    variant="outlined"
                    size="small"
                  />
                  <Button type="submit" variant="contained" color="primary" sx={{ mt: 1 }}>
                    Añadir Origen
                  </Button>
                </Box>
              )}
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Origen</TableCell>
                    <TableCell>Acciones</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {(origins || []).map((origin) => (
                    <TableRow key={origin}>
                      <TableCell>{origin}</TableCell>
                      <TableCell>
                        {corsEnabled ? (
                          <IconButton onClick={() => handleDeleteOrigin(origin)} color="error">
                            <Delete />
                          </IconButton>
                        ) : (
                          <Typography color="textSecondary">Desactivado</Typography>
                        )}
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Box>
          )}

          {/* Integraciones Tab */}
          {activeTab === 2 && (
            <Box>
              <Select
                value={selectedUserId || ""}
                onChange={(e) => setSelectedUserId(e.target.value ? Number(e.target.value) : null)}
                displayEmpty
                fullWidth
                sx={{ mb: 2 }}
              >
                <MenuItem value="">Todos los usuarios</MenuItem>
                {/* Añadir opciones dinámicas de usuarios */}
              </Select>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Nombre</TableCell>
                    <TableCell>Usuario</TableCell>
                    <TableCell>Estado</TableCell>
                    <TableCell>Acciones</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {integrations.filter(i => selectedUserId ? i.user_id === selectedUserId : true).map((integration) => (
                    <TableRow key={integration.id}>
                      <TableCell>{integration.name}</TableCell>
                      <TableCell>{integration.user_id}</TableCell>
                      <TableCell>
                        <Switch
                          checked={integration.active}
                          onChange={() => handleToggleIntegration(integration.id, integration.active)}
                        />
                      </TableCell>
                      <TableCell>
                        <IconButton onClick={() => handleDeleteIntegration(integration.id)} color="error">
                          <Delete />
                        </IconButton>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Box>
          )}

          {/* Gamificación Tab */}
          {activeTab === 3 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <EmojiEvents sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Gamificación
                  </Typography>

                  {/* Event Types Section */}
                  <ConfigGlassCard sx={{ mb: 4, p: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6">Tipos de Evento</Typography>
                      <Button
                        variant="contained"
                        startIcon={<AddCircle />}
                        onClick={() => setEditEventType({ id: 0, name: '', description: '', points_per_event: 0 })}
                      >
                        Nuevo Tipo
                      </Button>
                    </Box>

                    <Table>
                      <TableHead>
                        <TableRow>
                          <TableCell>Nombre</TableCell>
                          <TableCell>Descripción</TableCell>
                          <TableCell>Puntos</TableCell>
                          <TableCell>Acciones</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {eventTypes.map((et) => (
                          <TableRow key={et.id}>
                            <TableCell>{et.name}</TableCell>
                            <TableCell>{et.description}</TableCell>
                            <TableCell>{et.points_per_event}</TableCell>
                            <TableCell>
                              <IconButton onClick={() => setEditEventType(et)} color="primary">
                                <Edit />
                              </IconButton>
                              <IconButton onClick={() => handleDeleteEventType(et.id)} color="error">
                                <Delete />
                              </IconButton>
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </ConfigGlassCard>

                  {/* Badges Section */}
                  <ConfigGlassCard sx={{ p: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6">Insignias</Typography>
                      <Button
                        variant="contained"
                        startIcon={<AddCircle />}
                        onClick={() => setEditBadge({
                          id: 0,
                          name: '',
                          description: '',
                          event_type_id: eventTypes[0]?.id || 0,
                          required_points: 0,
                          user_type: 'both'
                        })}
                        disabled={eventTypes.length === 0}
                      >
                        Nueva Insignia
                      </Button>
                    </Box>

                    {eventTypes.map((eventType) => (
                      <Accordion key={eventType.id} sx={{ background: 'transparent', boxShadow: 'none' }}>
                        <AccordionSummary expandIcon={<ExpandMore />}>
                          <Typography>{eventType.name} (ID: {eventType.id})</Typography>
                        </AccordionSummary>
                        <AccordionDetails>
                          <Table>
                            <TableHead>
                              <TableRow>
                                <TableCell>Nombre</TableCell>
                                <TableCell>Puntos Requeridos</TableCell>
                                <TableCell>Tipo Usuario</TableCell>
                                <TableCell>Acciones</TableCell>
                              </TableRow>
                            </TableHead>
                            <TableBody>
                              {(groupedBadges[eventType.id] || []).map((badge) => (
                                <TableRow key={badge.id}>
                                  <TableCell>{badge.name}</TableCell>
                                  <TableCell>{badge.required_points}</TableCell>
                                  <TableCell>{badge.user_type}</TableCell>
                                  <TableCell>
                                    <IconButton onClick={() => setEditBadge(badge)} color="primary">
                                      <Edit />
                                    </IconButton>
                                    <IconButton onClick={() => handleDeleteBadge(badge.id)} color="error">
                                      <Delete />
                                    </IconButton>
                                  </TableCell>
                                </TableRow>
                              ))}
                            </TableBody>
                          </Table>
                        </AccordionDetails>
                      </Accordion>
                    ))}
                  </ConfigGlassCard>
                </CardContent>
              </ConfigGlassCard>

              {/* Event Type Dialog */}
              <Dialog open={!!editEventType} onClose={() => setEditEventType(null)}>
                <DialogTitle>{editEventType?.id ? 'Editar Tipo de Evento' : 'Nuevo Tipo de Evento'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editEventType?.id ? handleUpdateEventType : handleCreateEventType} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editEventType?.name || ''}
                      onChange={(e) => setEditEventType({ ...editEventType!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editEventType?.description || ''}
                      onChange={(e) => setEditEventType({ ...editEventType!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Puntos por evento"
                      type="number"
                      fullWidth
                      value={editEventType?.points_per_event || 0}
                      onChange={(e) => setEditEventType({ ...editEventType!, points_per_event: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editEventType?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Badge Dialog */}
              <Dialog open={!!editBadge} onClose={() => setEditBadge(null)}>
                <DialogTitle>{editBadge?.id ? 'Editar Insignia' : 'Nueva Insignia'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editBadge?.id ? handleUpdateBadge : handleCreateBadge} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editBadge?.name || ''}
                      onChange={(e) => setEditBadge({ ...editBadge!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editBadge?.description || ''}
                      onChange={(e) => setEditBadge({ ...editBadge!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Puntos Requeridos"
                      type="number"
                      fullWidth
                      value={editBadge?.required_points || 0}
                      onChange={(e) => setEditBadge({ ...editBadge!, required_points: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <TextField
                      label="Tipo de Evento"
                      select
                      fullWidth
                      value={editBadge?.event_type_id || 0}
                      onChange={(e) => setEditBadge({ ...editBadge!, event_type_id: parseInt(e.target.value) })}
                      margin="normal"
                      SelectProps={{ native: true }}
                    >
                      {eventTypes.map((et) => (
                        <option key={et.id} value={et.id}>{et.name}</option>
                      ))}
                    </TextField>
                    <TextField
                      label="Tipo de Usuario"
                      select
                      fullWidth
                      value={editBadge?.user_type || 'both'}
                      onChange={(e) => setEditBadge({ ...editBadge!, user_type: e.target.value as any })}
                      margin="normal"
                      SelectProps={{ native: true }}
                    >
                      <option value="anonymous">Anónimo</option>
                      <option value="registered">Registrado</option>
                      <option value="both">Ambos</option>
                    </TextField>
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editBadge?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* CUpones Tab */}

          {activeTab === 4 && (
            <Box sx={{ mb: 4 }}>
              <Typography variant="h6" sx={{ mb: 2 }}>Tipos de Cupones</Typography>
              <Button
                variant="contained"
                startIcon={<AddCircle />}
                onClick={() => setEditCouponType({ id: 0, name: '', description: '', credits: 0, active: true })}
              >
                Nuevo Tipo de Cupón
              </Button>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Nombre</TableCell>
                    <TableCell>Descripción</TableCell>
                    <TableCell>Créditos</TableCell>
                    <TableCell>Activo</TableCell>
                    <TableCell>Acciones</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {couponTypes.map((ct) => (
                    <TableRow key={ct.id}>
                      <TableCell>{ct.name}</TableCell>
                      <TableCell>{ct.description || 'Sin descripción'}</TableCell>
                      <TableCell>{ct.credits}</TableCell>
                      <TableCell>
                        <Chip label={ct.active ? "Activo" : "Inactivo"} color={ct.active ? "success" : "error"} />
                      </TableCell>
                      <TableCell>
                        <IconButton onClick={() => setEditCouponType(ct)} color="primary">
                          <Edit />
                        </IconButton>
                        <Button
                          variant="outlined"
                          size="small"
                          startIcon={<LocalActivity />}
                          onClick={async () => {
                            try {
                              const { data } = await fetchAPI<Coupon>("/v1/coupons/test", {
                                method: "POST",
                                data: { coupon_type_id: ct.id },
                              });
                              if (data) {
                                setCoupons([...coupons, data]);
                                setSuccess("Cupón de prueba generado con éxito");
                                setTimeout(() => setSuccess(null), 3000);
                              }
                            } catch (err) {
                              setError(err instanceof Error ? err.message : "Error al generar cupón de prueba");
                            }
                          }}
                        >
                          Generar Prueba
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </Box>
          )}

          {/* Pagos Tab */}
          {activeTab === 5 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <MonetizationOn sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Pagos
                  </Typography>

                  <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                    <Button
                      variant="contained"
                      startIcon={<AddCircle />}
                      onClick={() => setEditPaymentProvider({ id: 0, name: '', active: true })}
                    >
                      Nuevo Proveedor
                    </Button>
                  </Box>

                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>Nombre</TableCell>
                        <TableCell>Estado</TableCell>
                        <TableCell>Acciones</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {paymentProviders.map((provider) => (
                        <TableRow key={provider.id}>
                          <TableCell>{provider.name}</TableCell>
                          <TableCell>
                            <Switch
                              checked={provider.active}
                              onChange={(e) => handleTogglePaymentProvider(provider.id, provider.active)}
                            />
                          </TableCell>
                          <TableCell>
                            <IconButton onClick={() => setEditPaymentProvider(provider)} color="primary">
                              <Edit />
                            </IconButton>
                            <IconButton onClick={() => handleDeletePaymentProvider(provider.id)} color="error">
                              <Delete />
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </CardContent>
              </ConfigGlassCard>

              {/* Payment Provider Dialog */}
              <Dialog open={!!editPaymentProvider} onClose={() => setEditPaymentProvider(null)}>
                <DialogTitle>{editPaymentProvider?.id ? 'Editar Proveedor' : 'Nuevo Proveedor'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editPaymentProvider?.id ? handleUpdatePaymentProvider : handleCreatePaymentProvider} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editPaymentProvider?.name || ''}
                      onChange={(e) => setEditPaymentProvider({ ...editPaymentProvider!, name: e.target.value })}
                      margin="normal"
                    />
                    <FormControlLabel
                      control={
                        <Switch
                          checked={editPaymentProvider?.active || false}
                          onChange={(e) => setEditPaymentProvider({ ...editPaymentProvider!, active: e.target.checked })}
                          color="primary"
                        />
                      }
                      label="Activo"
                      sx={{ mt: 2 }}
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editPaymentProvider?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* Configuraciones Tab */}
          {activeTab === 6 && (
            <Box sx={{ mb: 4 }}>
              <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                <Button
                  variant="outlined"
                  onClick={toggleAllSettings}
                  startIcon={<ExpandMore />}
                  sx={{ borderRadius: '12px' }}
                >
                  {allSettingsExpanded ? 'Contraer Todo' : 'Expandir Todo'}
                </Button>
              </Box>

              {Object.entries(settingsByTag).map(([tag, settings]) => (
                <ConfigGlassCard key={tag} sx={{ mb: 2 }}>
                  <Accordion
                    sx={{ background: 'transparent', boxShadow: 'none' }}
                    expanded={expandedSettings[tag] || false}
                    onChange={() => setExpandedSettings(prev => ({ ...prev, [tag]: !prev[tag] }))}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar sx={{ bgcolor: theme.palette.primary.main, width: 32, height: 32 }}>
                          <Settings sx={{ fontSize: 16 }} />
                        </Avatar>
                        <Typography variant="h6">{tag}</Typography>
                        <Chip label={`${settings.length} configs`} size="small" color="primary" variant="outlined" />
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Grid container spacing={2}>
                        {settings.map((setting) => (
                          <Grid item xs={12} md={6} key={setting.key}>
                            <TextField
                              label={setting.key}
                              defaultValue={setting.value}
                              onBlur={(e) => handleSaveSetting(setting.key, e.target.value)}
                              fullWidth
                              variant="outlined"
                              size="small"
                              helperText={setting.description}
                              InputProps={{ sx: { borderRadius: '12px' } }}
                            />
                          </Grid>
                        ))}
                      </Grid>
                    </AccordionDetails>
                  </Accordion>
                </ConfigGlassCard>
              ))}
            </Box>
          )}
        </motion.div>
      </Box>

      {/* Notificaciones */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box>
  );
}

// Función auxiliar para descripciones de características
const getFeatureDescription = (key: string) => {
  const descriptions: Record<string, string> = {
    enable_registration: 'Permite a nuevos usuarios registrarse en la plataforma. Si se desactiva, solo los administradores podrán crear cuentas.',
    enable_social_login: 'Permite el inicio de sesión con proveedores sociales como Google, Facebook, etc. Requiere configuración previa de las APIs.',
    disable_anonymous_users: 'Impide el acceso a usuarios no registrados. Todos los visitantes deberán iniciar sesión para usar la plataforma.',
    disable_credits: 'Deshabilita el sistema de créditos en la plataforma. Los usuarios no podrán comprar ni gastar créditos.',
    enable_payment_methods: 'Habilita diferentes métodos de pago como tarjetas, PayPal, etc. Requiere configuración previa de cada proveedor.',
    enable_points: 'Activa el sistema de puntos por actividades. Los usuarios ganarán puntos por completar acciones en la plataforma.',
    enable_badges: 'Permite la obtención de insignias al alcanzar ciertos logros. Configura los requisitos en la pestaña de Gamificación.',
    enable_coupons: 'Permite la creación y uso de cupones de descuento. Los usuarios podrán canjear cupones para obtener descuentos en compras.'
  };
  return descriptions[key] || 'Funcionalidad del sistema';
};

// Renderización de la tabla de orígenes
const renderOriginsTable = () => {
  return (
    <Table>
      <TableHead>
        <TableRow>
          <TableCell>Origen</TableCell>
          <TableCell>Acciones</TableCell>
        </TableRow>
      </TableHead>
      <TableBody>
        {(origins || []).map((origin) => (
          <TableRow key={origin}>
            <TableCell>{origin}</TableCell>
            <TableCell>
              {corsEnabled ? (
                <IconButton onClick={() => handleDeleteOrigin(origin)} color="error">
                  <Delete />
                </IconButton>
              ) : (
                <Typography color="textSecondary">Desactivado</Typography>
              )}
            </TableCell>
          </TableRow>
        ))}
      </TableBody>
    </Table>
  );
};

// Asegurar que las variables y funciones estén definidas
const corsEnabled = true; // Valor por defecto para evitar errores

const handleDeleteOrigin = (origin: string) => {
  console.error(`handleDeleteOrigin no implementado. Intentando eliminar: ${origin}`);
};

const origins: string[] = []; // Inicializar como un array vacío para evitar errores


# backend/services/auth_service.py
# Módulo de servicio de autenticación.
from os import getenv
from uuid import uuid4
from sqlalchemy.orm import Session
from models.user import User, subscriptionEnum
from models.token import PasswordResetToken, RevokedToken
from core.security import (
    get_password_hash, verify_password, create_access_token, 
    create_refresh_token, decode_token
)
from core.logging import configure_logging
from core.security import google_client, meta_client

from datetime import datetime, timedelta
from fastapi import HTTPException
import requests
from threading import Lock
from threading import Lock
from datetime import datetime, timedelta
from fastapi import HTTPException
from threading import Lock
import jwt

refresh_lock = Lock()

logger = configure_logging()

def register_user(
    db: Session, 
    email: str, 
    username: str, 
    password: str, 
    ciudad: str = None, 
    website: str = None, 
    subscription: str = "freemium"
):
    try:
        if db.query(User).filter(User.email == email).first():
            logger.warning(f"Intento de registro con email duplicado: {email}")
            raise HTTPException(status_code=400, detail="El email ya está registrado")
        if db.query(User).filter(User.username == username).first():
            logger.warning(f"Intento de registro con username duplicado: {username}")
            raise HTTPException(status_code=400, detail="El username ya está registrado")
        
        hashed_password = get_password_hash(password)
        user = User(
            email=email,
            username=username,
            password_hash=hashed_password,
            ciudad=ciudad,
            website=website,
            subscription=subscriptionEnum(subscription),
            credits=100, 
            renewal=datetime.utcnow(),
            create_at=datetime.utcnow()
        )
        db.add(user)
        db.commit()
        db.refresh(user)
        
        access_token = create_access_token({"sub": str(user.id), "type": "registered"})
        refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
        logger.info(f"Usuario registrado ID {user.id} con subscription {subscription}")
        return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en registro de usuario {email}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al registrar usuario")

def login_user(db: Session, email: str, password: str, ip: str):
    try:
        user = db.query(User).filter(User.email == email).first()
        if not user or not verify_password(password, user.password_hash):
            logger.error(f"Intento de login fallido para email {email} desde IP {ip}")
            raise HTTPException(status_code=401, detail="Credenciales inválidas")
        if not user.activo:
            logger.warning(f"Intento de login con usuario inactivo ID {user.id} desde IP {ip}")
            raise HTTPException(status_code=403, detail="Usuario inactivo")
        
        user.last_ip = ip
        db.commit()
        
        # Añadir log para inspeccionar los datos del usuario
        logger.debug(f"Usuario encontrado: ID={user.id}, email={user.email}, subscription={user.subscription}, type={type(user.subscription)}")
        
        # Generar el token
        access_token = create_access_token({"sub": str(user.id), "type": "registered"})
        refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
        logger.info(f"Login exitoso para usuario ID {user.id} desde IP {ip}")
        return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}
    except Exception as e:
        logger.critical(f"Error inesperado en login para {email} desde IP {ip}: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail="Error al iniciar sesión")





def refresh_access_token(db: Session, refresh_token: str):
    if not refresh_token or len(refresh_token) < 10:
        raise HTTPException(status_code=401, detail="Refresh token inválido")

    with refresh_lock:
        try:
            # 1. Decodificar primero sin verificar revocación
            try:
                payload = jwt.decode(
                    refresh_token,
                    getenv("SECRET_KEY"),
                    algorithms=["HS256"],
                    options={"verify_exp": True}
                )
            except jwt.ExpiredSignatureError:
                logger.warning("Refresh token expirado")
                raise HTTPException(status_code=401, detail="Refresh token expirado")
            except Exception as e:
                logger.warning(f"Error decodificando token: {str(e)}")
                raise HTTPException(status_code=401, detail="Token inválido")

            # 2. Verificar si el token fue revocado DESPUÉS de decodificar
            if db.query(RevokedToken).filter(RevokedToken.token == refresh_token).first():
                logger.warning("Refresh token ya revocado")
                raise HTTPException(status_code=401, detail="Refresh token revocado")

            # 3. Validar claims
            if payload.get("type") != "refresh":
                raise HTTPException(status_code=401, detail="Tipo de token incorrecto")

            user_id = payload.get("sub")
            if not user_id:
                raise HTTPException(status_code=401, detail="Falta sub claim")

            # 4. Verificar usuario
            user = db.query(User).filter(User.id == int(user_id)).first()
            if not user or not user.activo:
                raise HTTPException(status_code=403, detail="Usuario inválido")

            # 5. Revocar el token actual
            db.add(RevokedToken(token=refresh_token, user_id=user.id))
            
            # 6. Crear nuevos tokens
            new_access_token = create_access_token({"sub": str(user.id), "type": "registered"})
            new_refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
            
            db.commit()  # Hacer commit después de crear los nuevos tokens
            
            return {
                "access_token": new_access_token,
                "refresh_token": new_refresh_token,
                "token_type": "bearer"
            }

        except HTTPException:
            db.rollback()
            raise
        except Exception as e:
            db.rollback()
            logger.error(f"Error crítico: {str(e)}")
            raise HTTPException(status_code=500, detail="Error interno")

        
def logout_user(db: Session, token: str): #_estimate ?
    payload = decode_token(token)
    if not payload:
        raise HTTPException(status_code=401, detail="Token inválido")
    
    revoked_token = RevokedToken(token=token)
    db.add(revoked_token)
    db.commit()
    return {"message": "Sesión cerrada"}

def request_password_reset(db: Session, email: str):
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise HTTPException(status_code=404, detail="Email no encontrado")
    
    token = str(uuid4())
    reset_token = PasswordResetToken(user_id=user.id, token=token)
    db.add(reset_token)
    db.commit()
    
    logger.info(f"Token de reseteo generado para usuario ID {user.id}: {token}")
    return {"message": "Solicitud de recuperación enviada", "token": token}

def confirm_password_reset(db: Session, token: str, new_password: str):
    reset_token = db.query(PasswordResetToken).filter(PasswordResetToken.token == token).first()
    if not reset_token:
        raise HTTPException(status_code=400, detail="Token inválido")
    if reset_token.expires_at < datetime.utcnow():
        raise HTTPException(status_code=400, detail="Token expirado")
    
    user = db.query(User).filter(User.id == reset_token.user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    
    user.password_hash = get_password_hash(new_password)
    db.delete(reset_token)
    db.commit()
    return {"message": "Contraseña actualizada con éxito"}

def change_user_password(db: Session, user_id: int, current_password: str, new_password: str):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="Usuario no encontrado")
    if not verify_password(current_password, user.password_hash):
        raise HTTPException(status_code=400, detail="Contraseña actual incorrecta")
    
    user.password_hash = get_password_hash(new_password)
    db.commit()
    return {"message": "Contraseña actualizada con éxito"}

def login_with_provider(db: Session, provider: str, code: str, ip: str):
    if provider == "google":
        token_url = "https://oauth2.googleapis.com/token"
        client_id = getenv("GOOGLE_CLIENT_ID")
        client_secret = getenv("GOOGLE_CLIENT_SECRET")
        redirect_uri = getenv("GOOGLE_REDIRECT_URI")
    elif provider == "meta":
        token_url = "https://graph.facebook.com/v13.0/oauth/access_token"
        client_id = getenv("META_CLIENT_ID")
        client_secret = getenv("META_CLIENT_SECRET")
        redirect_uri = getenv("META_REDIRECT_URI")
    else:
        raise HTTPException(status_code=400, detail="Proveedor no soportado")

    token_data = {
        "code": code,
        "client_id": client_id,
        "client_secret": client_secret,
        "redirect_uri": redirect_uri,
        "grant_type": "authorization_code"
    }
    response = requests.post(token_url, data=token_data)
    if response.status_code != 200:
        logger.error(f"Error al obtener token de {provider}: {response.text}")
        raise HTTPException(status_code=400, detail="Error al autenticar con el proveedor")

    token_info = response.json()
    user_info_url = "https://www.googleapis.com/oauth2/v3/userinfo" if provider == "google" else "https://graph.facebook.com/me?fields=id,email"
    user_response = requests.get(user_info_url, headers={"Authorization": f"Bearer {token_info['access_token']}"})
    user_data = user_response.json()

    email = user_data.get("email")
    provider_id = user_data.get("id") or user_data.get("sub")
    user = db.query(User).filter(User.email == email).first()

    if not user:
        user = User(
            email=email,
            username=email.split("@")[0],
            auth_provider=provider,
            provider_id=provider_id,
            credits= 200, # Comprobar si es cuando hace login o cuando se registra por primera vez con otro proveedor
            create_at=datetime.utcnow()
        )
        db.add(user)
        db.commit()
        db.refresh(user)
    else:
        if user.auth_provider != provider or user.provider_id != provider_id:
            logger.warning(f"Conflicto de proveedor para email {email}")
            raise HTTPException(status_code=400, detail="Email ya registrado con otro proveedor")

    user.last_ip = ip
    user.last_login = datetime.utcnow()
    db.commit()

    access_token = create_access_token({"sub": str(user.id), "type": "registered"})
    refresh_token = create_refresh_token({"sub": str(user.id), "type": "registered"})
    logger.info(f"Login con {provider} exitoso para usuario ID {user.id}")
    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}

    # backend/schemas/user.py
# Esquemas Pydantic para usuarios y perfiles

from pydantic import BaseModel, EmailStr
from datetime import datetime
from typing import Optional

class RegisterRequest(BaseModel):
    email: EmailStr
    username: str
    password: str
    ciudad: Optional[str] = None
    website: Optional[str] = None

class UpdateProfileRequest(BaseModel):
    email: Optional[EmailStr] = None
    username: Optional[str] = None
    ciudad: Optional[str] = None
    website: Optional[str] = None

class UserResponse(BaseModel):
    id: int
    email: EmailStr
    username: str
    rol: str
    activo: bool
    subscription: str  # Esto funciona porque Pydantic automáticamente usa el .value de los Enum
    ciudad: Optional[str] = None
    website: Optional[str] = None
    credits: int
    create_at: datetime
    last_ip: Optional[str] = None

    class Config:
        from_attributes = True  # Esto reemplaza a orm_mode = True en Pydantic v2

# backend/services/settings_service.py
# Servicio para gestión de configuración del sistema
import json
from sqlalchemy.orm import Session
from models.site_settings import SiteSettings
from core.logging import configure_logging
from fastapi import HTTPException

logger = configure_logging()

def update_setting(db: Session, admin_id: str, key: str, value: str, description: str = None, tag: str = None):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden modificar ajustes")
        
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        if setting:
            setting.value = value
            setting.description = description
            setting.tag = tag
            setting.updated_by = admin_id
        else:
            setting = SiteSettings(key=key, value=value, description=description, tag=tag, updated_by=admin_id)
            db.add(setting)
        db.commit()
        logger.info(f"Ajuste {key} actualizado por admin ID {admin_id}")
        return {"key": key, "value": value, "tag": tag}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al actualizar ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al actualizar ajuste")

def get_all_settings(db: Session, admin_id: str):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden ver configuraciones")
        
        settings = db.query(SiteSettings).all()
        return settings
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al obtener ajustes para admin {admin_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener ajustes")

def get_setting(db: Session, key: str) -> dict | list | int | str | None:
    try:
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        if not setting:
            return None
        value = setting.value
        try:
            return json.loads(value)  # Intentar deserializar como JSON
        except json.JSONDecodeError:
            # Si falla, intentar limpiar comillas adicionales y devolver la cadena
            cleaned_value = value.strip('"')
            try:
                return json.loads(cleaned_value)  # Reintentar con el valor limpio
            except json.JSONDecodeError:
                return cleaned_value  # Devolver la cadena limpia si no es JSON válido
    except Exception as e:
        logger.error(f"Error al obtener ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener ajuste")

def set_setting(db: Session, key: str, value: any, admin_id: str, description: str = None):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden modificar configuraciones")
        
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        serialized_value = json.dumps(value)  # Serializar a JSON
        if setting:
            setting.value = serialized_value
            setting.description = description or setting.description
        else:
            setting = SiteSettings(key=key, value=serialized_value, description=description)
            db.add(setting)
        db.commit()
        logger.info(f"Configuración '{key}' actualizada por admin {admin_id}: {value}")
        return {"key": key, "value": value}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al establecer ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al establecer ajuste")

#def get_all_settings(db: Session, admin_id: str) -> dict:
#    from models.user import User
#    admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
#    if not admin:
#        raise HTTPException(status_code=403, detail="Solo administradores pueden ver configuraciones")
#    
#    settings = db.query(SiteSettings).all()
#    return {s.key: json.loads(s.value) for s in settings}


# backend/services/payment_service.py
# Servicio para pagos y métodos de pago de usuarios
from sqlalchemy.orm import Session
from schemas.payment import PaymentMethodResponse
from models.payment_method import PaymentMethod
from models.user import User
from core.logging import configure_logging
from models.credit_transaction import CreditTransaction
from fastapi import HTTPException, status

logger = configure_logging()

class StripeSimulator:
    @staticmethod
    def create_payment_intent(amount: float, currency: str = "usd"):
        return {"id": "pi_simulated", "status": "succeeded"}

stripe = StripeSimulator()

def purchase_credits(db: Session, user_id: int, credits: int, payment_amount: float, payment_method: str = "stripe"):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Usuario no encontrado")

        transaction = CreditTransaction(
            user_type="registered",  # ¡Añadimos esto explícitamente!
            user_id=user_id,
            amount=credits,
            transaction_type="purchase",
            payment_amount=payment_amount,
            payment_method=payment_method,
            payment_status="pending"
        )
        db.add(transaction)
        db.commit()
        db.refresh(transaction)

        payment_intent = stripe.create_payment_intent(payment_amount)
        if payment_intent["status"] == "succeeded":
            transaction.payment_status = "completed"
            user.credits += credits
            db.commit()
            logger.info(f"Compra de {credits} créditos completada para usuario {user_id}")
            return {"transaction_id": transaction.id, "credits_added": credits, "new_balance": user.credits}
        else:
            transaction.payment_status = "failed"
            db.commit()
            raise HTTPException(status_code=status.HTTP_402_PAYMENT_REQUIRED, detail="Error al procesar el pago")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al procesar compra de créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar compra")

def add_payment_method(db: Session, user_id: int, payment_type: str, details: str, is_default: bool = False):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        if is_default:
            db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id, PaymentMethod.is_default == True).update({"is_default": False})
        
        payment_method = PaymentMethod(
            user_id=user_id,
            payment_type=payment_type,
            details=details,
            is_default=is_default
        )
        db.add(payment_method)
        db.commit()
        logger.info(f"Método de pago añadido para usuario ID {user_id}: {payment_type}")
        return payment_method
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al añadir método de pago para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al añadir método de pago")

def get_payment_methods(db: Session, user_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        return db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id).all()
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al listar métodos de pago para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al listar métodos de pago")

def set_default_payment_method(db: Session, user_id: int, payment_method_id: int):
    try:
        user = db.query(User).filter(User.id == user_id).first()
        if not user:
            raise HTTPException(status_code=404, detail="Usuario no encontrado")
        
        payment_method = db.query(PaymentMethod).filter(PaymentMethod.id == payment_method_id, PaymentMethod.user_id == user_id).first()
        if not payment_method:
            raise HTTPException(status_code=404, detail="Método de pago no encontrado")
        
        db.query(PaymentMethod).filter(PaymentMethod.user_id == user_id, PaymentMethod.is_default == True).update({"is_default": False})
        payment_method.is_default = True
        db.commit()
        logger.info(f"Método de pago ID {payment_method_id} establecido como predeterminado para usuario ID {user_id}")
        return payment_method
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al establecer método de pago predeterminado para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al establecer método de pago")

def get_credit_transactions(db: Session, user_id: int):
    try:
        return db.query(CreditTransaction).filter(CreditTransaction.user_id == user_id).all()
    except Exception as e:
        logger.error(f"Error al obtener transacciones de créditos para usuario {user_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener transacciones")
    
    
def update_payment_method(db: Session, user_id: int, method_id: int, payment_type: str, details: str) -> PaymentMethodResponse:
    method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id, PaymentMethod.user_id == user_id).first()
    if not method:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado")
    method.payment_type = payment_type
    method.details = details
    db.commit()
    db.refresh(method)
    return PaymentMethodResponse.from_orm(method)

def delete_payment_method(db: Session, user_id: int, method_id: int):
    method = db.query(PaymentMethod).filter(PaymentMethod.id == method_id, PaymentMethod.user_id == user_id).first()
    if not method:
        raise HTTPException(status_code=404, detail="Método de pago no encontrado")
    if method.is_default:
        raise HTTPException(status_code=400, detail="No se puede eliminar el método de pago predeterminado")
    db.delete(method)
    db.commit()


# backend/services/payment_provider_service.py
# Servicio para gestión de proveedores de pago

from sqlalchemy.orm import Session
from models.payment_provider import PaymentProvider
from schemas.payment import PaymentProviderCreate
from fastapi import HTTPException

def create_payment_provider(db: Session, provider: PaymentProviderCreate):
    existing = db.query(PaymentProvider).filter(PaymentProvider.name == provider.name).first()
    if existing:
        raise HTTPException(status_code=400, detail="Payment provider already exists")
    db_provider = PaymentProvider(**provider.dict())
    db.add(db_provider)
    db.commit()
    db.refresh(db_provider)
    return db_provider

def get_payment_providers(db: Session):
    return db.query(PaymentProvider).all()

def update_payment_provider(db: Session, provider_id: int, provider_update: PaymentProviderCreate):
    provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()
    if not provider:
        raise HTTPException(status_code=404, detail="Payment provider not found")
    for key, value in provider_update.dict().items():
        setattr(provider, key, value)
    db.commit()
    db.refresh(provider)
    return provider

def delete_payment_provider(db: Session, provider_id: int):
    provider = db.query(PaymentProvider).filter(PaymentProvider.id == provider_id).first()
    if not provider:
        raise HTTPException(status_code=404, detail="Payment provider not found")
    db.delete(provider)
    db.commit()
    return {"message": "Payment provider deleted"}

# backend/schemas/payment.py
# Esquemas Pydantic para pagos y métodos de pago

from pydantic import BaseModel
from datetime import datetime
from typing import Optional


class PurchaseRequest(BaseModel):
    credits: int
    payment_amount: float
    payment_method: Optional[str] = "stripe"

class PurchaseResponse(BaseModel):
    transaction_id: int
    credits_added: int
    new_balance: int

class PaymentMethodCreate(BaseModel):
    payment_type: str
    details: str
    is_default: bool = False

class PaymentMethodResponse(BaseModel):
    id: int
    payment_type: str
    details: str
    is_default: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class CreditTransactionResponse(BaseModel):
    id: int
    amount: int
    transaction_type: str
    payment_amount: Optional[float] = None
    payment_method: Optional[str] = None
    payment_status: Optional[str] = None
    timestamp: datetime

    class Config:
        from_attributes = True  # Permite mapear desde objetos SQLAlchemy
        
class PaymentProviderBase(BaseModel):
    name: str
    active: bool = True

class PaymentProviderCreate(PaymentProviderBase):
    pass

class PaymentProviderResponse(PaymentProviderBase):
    id: int

    class Config:
        from_attributes = True


# backend/schemas/credit_transaction.py
# Esquema Pydantic para transacciones de crédito

from pydantic import BaseModel
from datetime import datetime

class CreditTransactionBase(BaseModel):
    user_id: int | None
    session_id: str | None
    amount: int
    transaction_type: str
    payment_amount: float | None
    payment_method: str | None
    payment_status: str
    timestamp: datetime

class CreditTransactionResponse(CreditTransactionBase):
    id: int

    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

# backend/models/site_settings.py
# Modelo de configuración del sitio y sus claves

from sqlalchemy import Column, Integer, String, Boolean, DateTime
from datetime import datetime
from core.database import Base

class SiteSettings(Base):
    __tablename__ = "site_settings"
    
    id = Column(Integer, primary_key=True, index=True)
    key = Column(String(50), unique=True, nullable=False)
    value = Column(String(255), nullable=False)
    description = Column(String(255), nullable=True)
    tag = Column(String(50), nullable=True) # Nuevo atributo
    updated_by = Column(Integer, nullable=True)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Claves esperadas (documentación):
    # - token_expiration: int (segundos)
    # - refresh_token_expiration: int (segundos)
    # - rate_limit_auth: {"times": int, "seconds": int}
    # - rate_limit_api: {"times": int, "seconds": int}
    # - rate_limit_admin: {"times": int, "seconds": int}
    # - cache_ttl: int (segundos)
    # - cache_enabled: bool
    # - allowed_origins: bool indica si CORS está habilitado o no
    # Los valores de los orígenes permitidos se gestionan en la tabla AllowedOrigin
    # - celery_workers: int
    # - celery_task_timeout: int (segundos)
    # - db_pool_size: int
    # - db_max_overflow: int
    # - db_pool_timeout: int (segundos)
    # - freemium_credits: int
    # - premium_credits: int
    # - credit_reset_interval: int (días)
    # - log_level: str ("DEBUG", "INFO", "WARNING", "ERROR")

# backend/models/credit_transaction.py
# Modelo de transacciones de crédito en la base de datos
from sqlalchemy import CheckConstraint, Column, Integer, String, ForeignKey, DateTime, Float
from models.user import Base
from datetime import datetime


class CreditTransaction(Base):
    __tablename__ = "credit_transactions"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36),
                        ForeignKey("sesiones_anonimas.id"),
                        nullable=True)
    user_type = Column(String(20), nullable=False) #, default="anonymous") # "registered" o "anonymous"
    amount = Column(Integer, nullable=False)
    transaction_type = Column(String(50), nullable=False)
    description = Column(String(255), nullable=True)
    payment_amount = Column(Float, nullable=True)
    payment_method = Column(String(50), nullable=True)
    payment_status = Column(String(20), default="pending")
    timestamp = Column(DateTime, default=datetime.utcnow)

    # Restricción para asegurar que solo uno de user_id o session_id esté presente
    __table_args__ = (CheckConstraint(
        "(user_id IS NOT NULL AND session_id IS NULL AND user_type = 'registered') OR "
        "(user_id IS NULL AND session_id IS NOT NULL AND user_type = 'anonymous')",
        name="check_user_or_session"), )


# backend/dependencies/auth.py
# Módulo de dependencias de autenticación y contexto de usuario
from models.coupon_type import CouponType
from fastapi import Depends, HTTPException, Request
from sqlalchemy.orm import Session
from core.database import get_db
from models.user import User
from models.guests import GuestsSession
from models.token import RevokedToken
from core.security import decode_token
from core.logging import configure_logging
from services.coupon_service import create_coupon
from schemas.coupon import CouponCreate
from uuid import uuid4
from datetime import datetime
from pydantic import BaseModel
from fastapi import Response
import random
import string

logger = configure_logging()

class UserContext(BaseModel):
    user_id: str
    email: str
    username: str
    user_type: str  # "registered" o "anonymous"
    subscription: str
    credits: int
    rol: str
    session_id: str | None = None

    class Config:
        from_attributes = True

def generate_unique_username(db: Session) -> str:
    while True:
        random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        username = f"Guest_{random_chars}"
        if not db.query(GuestsSession).filter(GuestsSession.username == username).first():
            return username

async def get_user_context(request: Request, response: Response, db: Session = Depends(get_db)):
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
    session_id = request.headers.get("X-Session-ID")  # Leer de header en lugar de cookie
    client_ip = request.client.host
    logger.info(f"Procesando solicitud: token={bool(token)}, session_id={session_id}, ip={client_ip}")

    try:
        if token:
            # Lógica para usuarios registrados (sin cambios)
            if db.query(RevokedToken).filter(RevokedToken.token == token).first():
                logger.warning(f"Intento de uso de token revocado desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token revocado")
            payload = decode_token(token)
            if not payload or payload.get("type") != "access":
                logger.error(f"Token inválido recibido desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token inválido o no es de acceso")
            user = db.query(User).filter(User.id == int(payload["sub"])).first()
            if not user:
                logger.error(f"Usuario no encontrado para token desde IP {client_ip}")
                raise HTTPException(status_code=404, detail="Usuario no encontrado")
            if not user.activo:
                logger.warning(f"Intento de acceso con usuario inactivo ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=403, detail="Usuario inactivo")
            if user.token_valid_until and user.token_valid_until < datetime.utcnow():
                logger.warning(f"Token expirado manualmente para usuario ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token no válido")
            
            user.last_ip = client_ip
            user.last_login = datetime.utcnow()
            db.commit()
            logger.info(f"Usuario registrado ID {user.id} autenticado desde IP {client_ip}")
            return UserContext(
                user_type="registered",
                user_id=str(user.id),
                email=user.email,
                username=user.username,
                credits=user.credits,
                subscription=user.subscription.value,
                rol=user.rol
            )

        if not session_id:
            logger.info("No hay session_id en header, creando nueva sesión anónima")
            session_id = str(uuid4())
            username = generate_unique_username(db)  # Generar apodo único
            new_session = GuestsSession(
                id=session_id,
                username=username,  # Asignar el apodo
                credits=10,
                create_at=datetime.utcnow(),
                ultima_actividad=datetime.utcnow(),
                last_ip=client_ip
            )
            db.add(new_session)
            db.commit()

            # Crear cupón de bienvenida
            coupon_type = db.query(CouponType).filter(CouponType.name == "Bienvenida").first()
            if not coupon_type:
                logger.error("Tipo de cupón 'Bienvenida' no encontrado")
                raise HTTPException(status_code=500, detail="Tipo de cupón 'Bienvenida' no encontrado")

            coupon_data = CouponCreate(
                name="Bienvenida",
                description="Cupón de bienvenida para usuarios anónimos",
                credits=5,
                active=True,
                session_id=session_id,
                user_id=session_id,
                expires_at=None,
                issued_at=datetime.utcnow(),
                redeemed_at=None,
                status="active",
                unique_identifier=f"WELCOME-{session_id[:8]}",
                coupon_type_id=coupon_type.id  # Asignar el ID del tipo de cupón
            )
            create_coupon(db, coupon_data, user_id=None, session_id=session_id) 
            logger.info(f"Cupón de bienvenida creado para sesión {session_id}")

        
            logger.info(f"Nueva sesión anónima creada ID {session_id} con username {username} desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session_id,
                email="anonymous@example.com",
                username=username,  # Usar el apodo generado
                credits=10,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )
        else:
            logger.info(f"Buscando sesión anónima con ID {session_id} desde header")
            session = db.query(GuestsSession).filter(GuestsSession.id == session_id).first()
            if not session:
                logger.warning(f"Sesión anónima inválida ID {session_id} desde IP {client_ip}")
                raise HTTPException(status_code=400, detail="Sesión anónima inválida")
            
            session.last_ip = client_ip
            session.ultima_actividad = datetime.utcnow()
            db.commit()
            logger.info(f"Sesión anónima ID {session_id} actualizada desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session.id,
                email="anonymous@example.com",
                username=session.username,  # Usar el username de la sesión
                credits=session.credits,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )

        logger.error(f"No autorizado: sin token ni sesión válida desde IP {client_ip}")
        raise HTTPException(status_code=401, detail="No autorizado")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en get_user_context desde IP {client_ip}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar la autenticación")

# backend/core/security.py
# Seguridad y autenticación OAuth2 y JWT

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from oauthlib.oauth2 import WebApplicationClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jwt import encode, decode, PyJWTError
from os import getenv
from datetime import datetime, timedelta
from typing import Optional
from core.logging import configure_logging
from core.database import get_db
from services.settings_service import get_setting

logger = configure_logging()

# Configuración de OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/v1/auth/token")
google_client = WebApplicationClient(getenv("GOOGLE_CLIENT_ID"))
meta_client = WebApplicationClient(getenv("META_CLIENT_ID"))

# Configuración de hash de contraseñas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_token(user_id: str, user_type: str = "registered"):
    payload = {
        "sub": str(user_id),
        "type": user_type,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, getenv("SECRET_KEY"), algorithm="HS256")

def decode_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, getenv("SECRET_KEY"), algorithms=["HS256"])
        # Validación adicional del payload
        if not payload.get("sub") or not payload.get("type"):
            logger.warning(f"Token inválido: falta sub o type en el payload")
            return None
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token expirado")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Token inválido: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Error inesperado al decodificar token: {str(e)}")
        return None

def create_access_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "token_expiration") or "3600")
        if expiration < 300:  # Mínimo 5 minutos
            expiration = 3600
            logger.warning("Token expiration too low, using default 1h")
    except Exception as e:
        logger.error(f"Error token_expiration: {str(e)}")
        expiration = 3600
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

def create_refresh_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "refresh_token_expiration") or "604800")
        if expiration < 86400:  # Mínimo 1 día
            expiration = 604800
            logger.warning("Refresh token expiration too low, using default 7d")
    except Exception as e:
        logger.error(f"Error refresh_token_expiration: {str(e)}")
        expiration = 604800
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")


def create_refresh_token(data: dict):
    db = next(get_db())
    expiration_str = get_setting(db, "refresh_token_expiration") or "604800"  # Valor por defecto: 7 días
    try:
        expiration = int(str(expiration_str))  # Convertir a cadena primero y luego a entero
    except ValueError:
        logger.error(f"Valor inválido para refresh_token_expiration: {expiration_str}")
        expiration = 604800  # Valor por defecto si falla
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

    
def get_oauth2_redirect_url(provider: str) -> str:
    if provider == "google":
        return google_client.prepare_request_uri(
            "https://accounts.google.com/o/oauth2/v2/auth",
            redirect_uri=getenv("GOOGLE_REDIRECT_URI"),
            scope=["openid", "email", "profile"]
        )
    elif provider == "meta":
        return meta_client.prepare_request_uri(
            "https://www.facebook.com/v13.0/dialog/oauth",
            redirect_uri=getenv("META_REDIRECT_URI"),
            scope=["email"]
        )
    raise ValueError("Proveedor no soportado")

Ya esta. EN principio no hecho nada en falta para esta primera actuación.

En cuanto al desarrollo tecnico a la hora de generar el codifo fuente de los cambios solicitados, debes seguir estas indicaciones:

los criterios a seguir son: usabilidad, legibilidad, jerarquia de contenidos, facilidad, orden, sentido comun, visualización

- reutiliza elementos visuales y componentes visuales / UI a la hora de programar, manteniendo la robusted y solidez del codigo fuente actual que ya has estudiado.

- haz tu codigo fuente modular y escalable

- no rompas el desarrollo actual

- recuerda organizar de forma modular y escalable las carpetas y ficheros de la app que crees nuevos

- NO ROMPAS el proyecto actual,estamos ampliando no cambiando.

Si necesitas más ayuda o necesitas código adicional que ver, no dudes en decírmelo. A ver como te desenvuelves con mi software.

Se que es muchiiiisima información, por favor leela toda con detenimiento. Si es mucho separa tu respuesta en partes. Solicitame los archivos que necesites ver. 


Respeta la logica actual para no romper ningun servicio activo. 
Es importante esta parte que salga bien, tomate tu tiempo.
Pideme los archivos que necesites ver para una mejor implantación.

Para la parte del frontend, al ser en nextjs, ten en mente la reutilización y reuso de componentes reutilizables y modulares.

Recuerda generar codigo completo.

Solicita cualquier archivo que necesites.


Ya puedes proceder paso a paso con tu respuesta.
