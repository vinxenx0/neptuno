Excelente, yo tb he tomado nota de todas tus sugerencias, las he ordenado y jerarquizado y puesto en el roadmap.

Tambien voy a resolver las dudas tecnicas que has tenido durante todos tu feedback, aqui estan tus dudas:

Observación: La configuración es sólida para producción, pero noto que algunas variables de entorno (env_file) están comentadas. 
¿Las estás manejando manualmente o hay un archivo .env específico para producción que no me has pasado aún?

Esas variables están comentadas porque no están implantadas aun en el backend, pero está previsto hacerlo, la configuración
esta en los archivos .env de frontend y backend y en backend/core/config.py :

# backend/core/config.py
# Módulo de configuración de la aplicación.
from dotenv import load_dotenv
import os

load_dotenv()

class Settings:
    PROJECT_NAME = "Neptuno"
    SECRET_KEY = os.getenv("SECRET_KEY")
    ENVIRONMENT = os.getenv("ENVIRONMENT", "development")  # "development" o "production"
    
    # Configuración de bases de datos
    SQLITE_URL = os.getenv("SQLITE_URL","sqlite:///dev.db")  # SQLite en desarrollo
    MYSQL_URL = os.getenv("MYSQL_URL")  # MySQL en producción (definido en .env)
    
    @property
    def DATABASE_URL(self):
        return self.SQLITE_URL if self.ENVIRONMENT == "development" else self.MYSQL_URL

settings = Settings()


Observación: El uso de output: "export" en next.config.ts sugiere que podrías estar generando un sitio estático, pero estás ejecutando next start. 
Esto podría ser intencional para SSR (Server-Side Rendering). ¿Confirmamos qué modo estás usando en producción?

En produccion utilizamos: npx next start pero generamos el sitio estatico para comprobar que no tenemos errores, por otro lado tenemos en roadmap
implantar SSR para SEO. EN cualquier caso el como servimos las paginas podemos discutirlo mas adelante.

   Entorno de producción vs. desarrollo:
        ¿Hay diferencias específicas en la configuración que deba tener en cuenta (por ejemplo, más workers en producción, caching habilitado)?
        El .env del backend mezcla configs de desarrollo (SQLITE_URL) y producción (MYSQL_URL). ¿Cómo alternas entre ellos? 

Respuesta: cuando clonamos el repositorio en producción comentamos o descomentamos el motor de db que vamos a usar (sqlite o mariadb)

    Dependencias externas:
        Veo referencias a Google y Meta OAuth. ¿Hay otras integraciones (Stripe, CRM, etc.) que deba conocer?
        ¿Usas Redis (mencionado en el .env) para caching o colas?

        Esta previsto implantar oatuh para login social por eso aparece.

    Mejoras propuestas:
        Rendimiento: Podríamos ajustar los workers de Gunicorn y habilitar caching en Nginx para la feria, donde esperas más tráfico.
        Seguridad: Revisar CORS y añadir más headers de seguridad en Nginx (como CSP o X-Frame-Options).
        Monitoreo: ¿Tienes logs centralizados o métricas (Prometheus, Grafana) que quieras mejorar?

    Dudas técnicas:
        ¿El frontend usa SSR o es estático? Esto afecta cómo optimizamos para SEO y rendimiento.

        Usa SSR por ahora pero queremos calibrar que rendimiento es mas optimo en produccion.

        ¿Cómo manejas las réplicas de MariaDB? No están activas en el docker-compose.yml.

        NO están activas porque se activarán desde el panel de control del frontend.

Espero que esto resuelva tus dudas: antes de pedirte las primeras ampliaciones que van a continuación

- repasa todo lo que has visto, front, back ahora que tienes todas las dudas resueltas
- cuando implantemos nuevas logicas y funcionalidades revisa como funciona la logica existente para
inspirarte o replicar las logicas que ya funcionan


y ahora por fin te voy a solicitar las siguientes mejoras en la aplicación:

MEJORA 1: Ampliación de las funcionalidades (o modulos) disponibles en el BaaS con un sistema de CUPONES

Vamos a implantar la gestión de cupones que el usuario podrá canjear por creditos.

La logica será la siguiente: el usuario puede obtener cupones por completar eventos (los eventos de la gamificación)
o acciones (se genera un cupon desde la api al realizar una acción como pulsar un boton), 

los cupones tendrán los siguientes atributos: 
- un nombre que identifica al cupon
- descripción
- un identificador unico
- fecha de emisión 
- fecha de expiración (puede no expirar)
- fecha de canje
- activo (true o false)
- situación (expirado, canjeado, en vigor, desactivado)
- creditos (los creditos que incluye)

Las logicas que debes implantar permitirán que los usuarios:

- Canjeen cupones activos (y reciban los creditos de su valor en su cuenta de creditos)
- Puedan consultar su historial de cupones (recibidos, expirados, canjeados, etc)
- EL usuario verá un icono en navbar para los cupones con un badge-notificación arriba a la derecha
del icono con el numero de cupones disponibles, como el resto de botones, que se actualizará cuando
reciba o caduque un cupon

Por el lado del administrador la logica de los cupones le debe permitir:

- Crear cupones: nombre, creditos, fecha de expiración, activo o no y descripción opcional.
- Modificar, borrar y cambiar estados de los cupones
- Habilitar o deshabilitar la funcionalidad de "CUPONES" desde el panel de control de admin
- Consultar el historial o logs de cupones canjeados de todos los usuarios del sitio 


TEndras que generar Para el backend: 
- los endpoints necesarios en la API actual para gestionar toda la logica de los cupones
- las dependencias, si procede, que requerira la logica para los cupones
- middleware para los cupones si lo consideras necesario, que quizas no sea el caso
- modelo completo de datos con todos los atributos y relaciones necesarias si las hubiere
- shemas pydantic necesarios para la implantación correcta del sistema de cupones
- servicios necesarios para la implantación robusta y fiable de la logica de los cupones
- algunos cupones de ejemplo para insertarlos en los datos iniciales
- crear un Site_setting necesario para poder habilitar y deshabilitar los cupones
- actualizar todos los archivos necesarios como main.py o los afectados para la implantación de la logica.

por ultimo, por motivos de demostración tendrás que hacer un endpoint donde el usuario pueda generar cupones aleatorios de la cantidad
de creditos elegida sin ser admin (para que usuarios anonimos prueben en nuestro landing como ya sabes)

TEndras que generar Para el frontend:

- añadir a la botonera de navbar un icono mas para los cupones que notificará de los cupones para el usuario activo en ese momento
- una pagina en /users/coupon/ que se accederá pinchando desde el icono de cupones de la botonera de navbar que nos llevará a una pagina donde se mostrará
todo el historial de cupones del usuario y donde podrá canejar los cupones activos
- actualizaremos el dashboard de usuario añadiendo una pestaña mas a la barra de opciones: después de la pestaña TRANSACCIONES, pondemos la pestaña "CUPONES"
donde el usuario podra ver si historial de cupones y canjearlos.
- actualizaremos el dashboard de administrador añadiendo: en la pestaña de funcionalidades añadiremos la nueva tarjeta para activar o desactivar la 
funcionalidad de los cupones.
- actualizaremos el dashboard de administrador añadiendo una nueva pestaña al menu: CUPONES, en esa pestaña el administrador podrá: añadir nuevos cupones,
gestionar, modificar y borrar los existentes, asi como visualizarlos.
- crear los tipados, funciones, handles, constantes, y todo lo que necesites



Ahora te paso los archivos que considero relevantes para que los conozcas y ya sea que apliques los cambios necesarios o los tomes 
como guia o referencia para aplicar logicas generales. Aquilos tienes, solicita los que necesites si yo no te los he proporcionado:

Primero de todo la estructura actual, por si necesitas algo:

Primero de todo, el arbol de archivos├── neptuno
│   ├── alembic.ini
│   ├── backend
│   │   ├── api
│   │   │   ├── __init__.py
│   │   │   └── v1
│   │   │       ├── anonymous_sessions.py
│   │   │       ├── api_logs.py
│   │   │       ├── auth.py
│   │   │       ├── auth.py.old
│   │   │       ├── credit_transactions.py
│   │   │       ├── endpoints.py
│   │   │       ├── error_logs.py
│   │   │       ├── gamification.py
│   │   │       ├── __init__.py
│   │   │       ├── integrations.py
│   │   │       ├── payment_providers.py
│   │   │       ├── payments.py
│   │   │       ├── site_settings.py
│   │   │       └── users.py
│   │   ├── app.log
│   │   ├── background.sh
│   │   ├── check_db.sh
│   │   ├── core
│   │   │   ├── config.py
│   │   │   ├── database.py
│   │   │   ├── __init__.py
│   │   │   ├── logging.py
│   │   │   └── security.py
│   │   ├── create_db.original.sql
│   │   ├── create_db.sql
│   │   ├── dependencies
│   │   │   ├── auth.py
│   │   │   ├── credits.py
│   │   │   └── __init__.py
│   │   ├── dev.db
│   │   ├── Dockerfile
│   │   ├── env.local
│   │   ├── env.prod
│   │   ├── env.vpn
│   │   ├── initial_data.py
│   │   ├── __init__.py
│   │   ├── main.py
│   │   ├── middleware
│   │   │   ├── credits_middleware.py
│   │   │   ├── gamification.py
│   │   │   ├── __init__.py
│   │   │   └── logging.py
│   │   ├── models
│   │   │   ├── allowed_origin.py
│   │   │   ├── credit_transaction.py
│   │   │   ├── error_log.py
│   │   │   ├── gamification.py
│   │   │   ├── guests.py
│   │   │   ├── guests.stage.py
│   │   │   ├── __init__.py
│   │   │   ├── integration.py
│   │   │   ├── log.py
│   │   │   ├── payment_method.py
│   │   │   ├── payment_provider.py
│   │   │   ├── site_settings.py
│   │   │   ├── token.py
│   │   │   └── user.py
│   │   ├── requirements.txt
│   │   ├── schemas
│   │   │   ├── anonymous_session.py
│   │   │   ├── api_log.py
│   │   │   ├── auth.py
│   │   │   ├── credit_transaction.py
│   │   │   ├── error_log.py
│   │   │   ├── gamification.py
│   │   │   ├── integration.py
│   │   │   ├── payment.py
│   │   │   ├── site_settings.py
│   │   │   └── user.py
│   │   ├── services
│   │   │   ├── auth_service.py
│   │   │   ├── credits_service.py
│   │   │   ├── gamification_service.py
│   │   │   ├── __init__.py
│   │   │   ├── integration_service.py
│   │   │   ├── origin_service.py
│   │   │   ├── payment_provider_service.py
│   │   │   ├── payment_service.py
│   │   │   ├── settings_service.py
│   │   │   └── user_service.py
│   │   ├── tasks.py
│   │   └── up_api.sh
│   ├── docker-compose.yml
│   ├── frontend
│   │   ├── deploy.sh
│   │   ├── Dockerfile
│   │   ├── env.local
│   │   ├── env.prod
│   │   ├── env.vbox
│   │   ├── eslint.config.mjs
│   │   ├── next.config.ts
│   │   ├── package.json
│   │   ├── package-lock.json
│   │   ├── postcss.config.js
│   │   ├── public
│   │   │   ├── apple-touch-icon.ico
│   │   │   ├── favicon-16x16.ico
│   │   │   ├── favicon.ico
│   │   │   └── logo.png
│   │   ├── reinstall.sh
│   │   ├── src
│   │   │   ├── app
│   │   │   │   ├── about
│   │   │   │   │   ├── layout.tsx
│   │   │   │   │   └── [page]
│   │   │   │   │       ├── contact.tsx
│   │   │   │   │       ├── page.tsx
│   │   │   │   │       ├── policy.tsx
│   │   │   │   │       ├── privacy.tsx
│   │   │   │   │       └── us.tsx
│   │   │   │   ├── admin
│   │   │   │   │   ├── dashboard
│
│   │   │   │   │   │   └── page.tsx
│   │   │   │   │   ├── registry
│   │   │   │   │   │   └── page.tsx
│   │   │   │   │   ├── reset-credits
│   │   │   │   │   │   └── page.tsx
│   │   │   │   │   └── users
│   │   │   │   │       └── page.tsx
│   │   │   │   ├── ejemplos
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── global.color.css
│   │   │   │   ├── global.css
│   │   │   │   ├── layout.tsx
│   │   │   │   ├── page.bnw.tsx
│   │   │   │   ├── page.copy.tsx
│   │   │   │   ├── page.tsx
│   │   │   │   ├── rankings
│   │   │   │   │   └── page.tsx
│   │   │   │   ├── sitemap.ts.example
│   │   │   │   └── user
│   │   │   │       ├── auth
│   │   │   │       │   ├── layout.tsx
│   │   │   │       │   └── page.tsx
│   │   │   │       ├── badges
│   │   │   │       │   └── page.tsx
│   │   │   │       ├── change-password
│   │   │   │       │   └── page.tsx
│   │   │   │       ├── dashboard
│   │   │   │       ├── points
│   │   │   │       │   └── page.tsx
│   │   │   │       └── transactions
│   │   │   │           └── page.tsx
│   │   │   ├── components
│   │   │   │   ├── admin
│   │   │   │   │   ├── AdminUsersPage.copy.tsx
│   │   │   │   │   └── AdminUsersPage.tsx
│   │   │   │   ├── seo
│   │   │   │   │   ├── MetaTags.tsx
│   │   │   │   │   └── ShemaMarkup.tsx
│   │   │   │   ├── ui
│   │   │   │   │   └── index.tsx
│   │   │   │   └── web│   │   │   │       ├── Footer.tsx
│   │   │   │       └── Navbar.tsx
│   │   │   └── lib
│   │   │       ├── api.ts
│   │   │       ├── auth
│   │   │       │   └── context.tsx
│   │   │       ├── payments
│   │   │       │   ├── example.tsx
│   │   │       │   ├── manager.ts
│   │   │       │   └── stripe.ts
│   │   │       ├── payments.ts
│   │   │       └── types.ts
│   │   ├── tailwind.config.js
│   │   ├── tsconfig.json
│   │   └── up_front.sh└── tree.txt



archivos que te paso para las modificaciones Para el backend:

# backend/main.py
# Punto de entrada principal de la aplicación.
from api.v1 import payment_providers
from models.gamification import EventType
from schemas.gamification import GamificationEventCreate, GamificationEventResponse, UserGamificationResponse
from services.gamification_service import get_user_gamification, register_event
from fastapi import Depends, FastAPI, HTTPException, Request, Depends
from fastapi.responses import JSONResponse
from sqlalchemy import text
from api.v1 import auth, endpoints, payments, site_settings, integrations, payments
from api.v1 import anonymous_sessions, credit_transactions, error_logs
from api.v1 import api_logs
from api.v1 import users
from api.v1 import gamification
from dependencies.credits import check_credits
from models.credit_transaction import CreditTransaction
# from models.guests import GuestsSession
from models.user import User
from services.integration_service import trigger_webhook
from middleware.credits_middleware import require_credits
from middleware.logging import LoggingMiddleware
from dependencies.auth import UserContext, get_user_context
from services.settings_service import get_setting
from services.origin_service import get_allowed_origins
from core.database import Base, engine, get_db
from core.logging import configure_logging
from core.config import settings
from services.credits_service import reset_credits
from models.error_log import ErrorLog
from sqlalchemy.orm import Session
from fastapi.middleware.cors import CORSMiddleware
from fastapi_limiter import FastAPILimiter
from fastapi_limiter.depends import RateLimiter

app = FastAPI(
    title=settings.PROJECT_NAME,
    docs_url="/docs" if settings.ENVIRONMENT == "development" else None,
    redoc_url=None,
    #root_path="/api"
    proxy_headers=True  # Necesario para X-Forwarded-*

    #servers=[{"url": "/api", "description": "Local server"}],

    #openapi_url="/api/openapi.json",

    #swagger_ui_parameters={"url": "/api/openapi.json"}
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # En desarrollo (en producción usa dominios exactos)
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["*"]  # Añade esto para headers personalizados
)

logger = configure_logging()
# app.add_middleware(LoggingMiddleware)

# Middleware para confiar en el proxy
# app.add_middleware(TrustedHostMiddleware, allowed_hosts=["*"])

db = next(get_db())
#app.add_middleware(
#    CORSMiddleware,
#    allow_origins=["*", #
#        "https://172.18.0.2:8000",
#        "https://localhost:8000",
#        "https://localhost:3000",
#        "http://localhost:8000",
#        "http://localhost:3000",
#        "https://neptuno.ciberpunk.es",
#        "http://neptuno.ciberpunk.es",
#        "127.0.0.0.1",
        #"194.164.164.177",
        #"neptuno.ciberpunk.es",
        #"172.18.0.3"
    #],  # Lista explícita de dominios permitidos
    #allow_origins=["*"], #allowed_origins = get_setting(db, "allowed_origins") or ["https://localhost:3000"]  # Valor por defecto
    #allow_credentials=True,
    #allow_methods=["*"],
#    allow_headers=["*"]
#)


Base.metadata.create_all(bind=engine)



@app.on_event("startup")
async def startup_event():

    try:
        admin_id = 1
        logger.info(f"Iniciando {settings.PROJECT_NAME} en entorno {settings.ENVIRONMENT}")
        logger.info("Ejecutando renovación de créditos automática al iniciar")
        reset_credits(db, admin_id)
    except HTTPException as e:
        logger.error(f"Error HTTP en startup: {e.detail}")
    except Exception as e:
        logger.error(f"Error inesperado en startup: {str(e)}")
    finally:
        db.close()
        
rate_limit_auth = get_setting(db, "rate_limit_auth") or {"times": 20, "seconds": 60}
rate_limit_api = get_setting(db, "rate_limit_api") or {"times": 100, "seconds": 60}
rate_limit_admin = get_setting(db, "rate_limit_admin") or {"times": 50, "seconds": 60}

async def get_rate_limit_key(request: Request, user: UserContext = Depends(get_user_context)):
        if user.user_type == "registered":
            return f"user:{user.user_id}"
        return f"ip:{request.client.host}"

app.include_router(auth.router, prefix="/v1/auth", tags=["auth"])
app.include_router(users.router, prefix="/v1/users", tags=["users"])
app.include_router(endpoints.router, prefix="/v1/api", tags=["api"])
app.include_router(payments.router, prefix="/v1/payments", tags=["payments"])
app.include_router(site_settings.router, prefix="/v1/settings", tags=["site_settings"])
app.include_router(integrations.router, prefix="/v1/integrations", tags=["integrations"])
#app.include_router(payments.router, prefix="/v1/payments", tags=["payments"], dependencies=[Depends(RateLimiter(**rate_limit_api, identifier=get_rate_limit_key))])
app.include_router(error_logs.router, prefix="/v1/errors", tags=["Errors"])
app.include_router(anonymous_sessions.router, prefix="/v1/sessions", tags=["Sessions"])
app.include_router(credit_transactions.router, prefix="/v1/transactions", tags=["Transactions"])
app.include_router(api_logs.router, prefix="/v1/logs", tags=["Logs"])
app.include_router(gamification.router, prefix="/v1/gamification", tags=["Gamification"])
app.include_router(payment_providers.router, prefix="/v1/payment-providers", tags=["Payment Providers"])



@app.exception_handler(HTTPException)
async def http_exception_handler(request: Request, exc: HTTPException) -> JSONResponse:
    db = next(get_db())
    try:
        logger.error(f"HTTP Error {exc.status_code} en {request.method} {request.url}: {exc.detail}")
        error_log = ErrorLog(
            error_code=exc.status_code,
            message=exc.detail,
            url=str(request.url),
            method=request.method,
            ip_address=request.client.host
        )
        db.add(error_log)
        db.commit()
    finally:
        db.close()
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": {"code": exc.status_code, "message": exc.detail}}
    )

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception) -> JSONResponse:
    db = next(get_db())
    try:
        logger.critical(f"Error inesperado en {request.method} {request.url}: {str(exc)}")
        error_log = ErrorLog(
            error_code=500,
            message="Error interno del servidor",
            details=str(exc),
            url=str(request.url),
            method=request.method,
            ip_address=request.client.host
        )
        db.add(error_log)
        db.commit()
    finally:
        db.close()
    return JSONResponse(
        status_code=500,
        content={"error": {"code": 500, "message": "Error interno del servidor"}}
    )
    
# Health check endpoint para despliegue
@app.get("/health")
async def health_check(db: Session = Depends(get_db)):
    try:
        # Ejecuta una consulta SQL simple utilizando text()
        db.execute(text("SELECT 1"))
        logger.info("Base de datos accesible")
        return {"status": "healthy", "environment": settings.ENVIRONMENT}
    except Exception as e:
        logger.error(f"Error en health check: {str(e)}")
        raise HTTPException(status_code=503, detail="Database unavailable")
    
@app.get("/")
async def root():
    return {"message": "Bienvenido a la API Backend"}

@app.get("/no-login/")
async def no_login_test(user: UserContext = Depends(check_credits), db: Session = Depends(get_db)):
    """
    Endpoint para probar la API sin necesidad de login.
    Consume créditos si están activos.
    """
    # Preparar la respuesta
    response = {"message": "Consulta realizada sin necesidad de login", "user_type": user.user_type}
    if user.user_type == "anonymous":
        response["session_id"] = user.user_id  # Incluir session_id en la respuesta

    # Consumir créditos si no están desactivados
    disable_credits = get_setting(db, "disable_credits")
    if disable_credits != "true":
        try:
            if user.user_type == "registered":
                user_db = db.query(User).filter(User.id == int(user.user_id)).first()
                user_db.credits -= 1
                transaction = CreditTransaction(
                    user_id=user_db.id,
                    user_type="registered",  # Especificar explícitamente
                    amount=-1,
                    transaction_type="usage",
                    description="Consulta realizada"
                )
                credits_remaining = user_db.credits
            else:
                session_db = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
                session_db.credits -= 1
                transaction = CreditTransaction(
                    session_id=session_db.id,
                    user_type="anonymous",  # Especificar explícitamente para claridad
                    amount=-1,
                    transaction_type="usage",
                    description="Consulta realizada por anónimo"
                )
                credits_remaining = session_db.credits
            
            db.add(transaction)
            db.commit()

            trigger_webhook(db, "credit_usage", {
                "user_id": user.user_id,
                "user_type": user.user_type,
                "credits_remaining": credits_remaining
            })
            logger.debug(f"Créditos actualizados para {user.user_type} ID {user.user_id}: {credits_remaining}")
        except Exception as e:
            logger.error(f"Error al consumir créditos para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")

    return response

@app.get("/restricted")
async def restricted_test(user: UserContext = Depends(check_credits), db: Session = Depends(get_db)):
    """
    Endpoint restringido que requiere login.
    Consume créditos si están activos.
    """
    if user.user_type != "registered":
        raise HTTPException(status_code=401, detail="Se requiere autenticación")

    # Preparar la respuesta
    response = {"message": "Consulta realizada con login", "user_type": user.user_type}

    # Consumir créditos si no están desactivados
    disable_credits = get_setting(db, "disable_credits")
    if disable_credits != "true":
        try:
            user_db = db.query(User).filter(User.id == int(user.user_id)).first()
            user_db.credits -= 1
            transaction = CreditTransaction(
                user_id=user_db.id,
                user_type="registered",  # Especificar explícitamente
                amount=-1,
                transaction_type="usage",
                description="Consulta realizada"
            )
            db.add(transaction)
            db.commit()

            trigger_webhook(db, "credit_usage", {
                "user_id": user.user_id,
                "user_type": user.user_type,
                "credits_remaining": user_db.credits
            })
            logger.debug(f"Créditos actualizados para {user.user_type} ID {user.user_id}: {user_db.credits}")
        except Exception as e:
            logger.error(f"Error al consumir créditos para {user.user_type} ID {user.user_id}: {str(e)}")
            raise HTTPException(status_code=500, detail="Error al procesar los créditos")

    return response

@app.get("/info")
async def get_info(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_anonymous = get_setting(db, "disable_anonymous_users")
    base_info = {
        "user_id": user.user_id,
        "email": user.email,
        "username": user.username,
        "user_type": user.user_type,
        "subscription": user.subscription,
        "credits": user.credits,
        "rol": user.rol,
        "session_id": user.session_id if user.user_type == "anonymous" else None
    }

    gamification = get_user_gamification(db, user)
    gamification_data = [
        UserGamificationResponse.from_orm(g) for g in gamification
    ]

    return {**base_info, "gamification": gamification_data}


@app.post("/test-event", response_model=GamificationEventResponse)
def test_gamification_event(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    event_type = db.query(EventType).filter(EventType.name == "test_api").first()
    if not event_type:
        raise HTTPException(status_code=404, detail="Event type 'test_api' not found")
    event = GamificationEventCreate(event_type_id=event_type.id)
    return register_event(db, event, user)


para la gestión de las configuraciones (crearemos la nueva que habilite el modulo de coupon)

# backend/services/settings_service.py
import json
from sqlalchemy.orm import Session
from models.site_settings import SiteSettings
from core.logging import configure_logging
from fastapi import HTTPException

logger = configure_logging()

def update_setting(db: Session, admin_id: str, key: str, value: str, description: str = None, tag: str = None):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden modificar ajustes")
        
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        if setting:
            setting.value = value
            setting.description = description
            setting.tag = tag
            setting.updated_by = admin_id
        else:
            setting = SiteSettings(key=key, value=value, description=description, tag=tag, updated_by=admin_id)
            db.add(setting)
        db.commit()
        logger.info(f"Ajuste {key} actualizado por admin ID {admin_id}")
        return {"key": key, "value": value, "tag": tag}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al actualizar ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al actualizar ajuste")

def get_all_settings(db: Session, admin_id: str):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden ver configuraciones")
        
        settings = db.query(SiteSettings).all()
        return settings
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al obtener ajustes para admin {admin_id}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener ajustes")

def get_setting(db: Session, key: str) -> dict | list | int | str | None:
    try:
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        if not setting:
            return None
        value = setting.value
        try:
            return json.loads(value)  # Intentar deserializar como JSON
        except json.JSONDecodeError:
            # Si falla, intentar limpiar comillas adicionales y devolver la cadena
            cleaned_value = value.strip('"')
            try:
                return json.loads(cleaned_value)  # Reintentar con el valor limpio
            except json.JSONDecodeError:
                return cleaned_value  # Devolver la cadena limpia si no es JSON válido
    except Exception as e:
        logger.error(f"Error al obtener ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al obtener ajuste")

def set_setting(db: Session, key: str, value: any, admin_id: str, description: str = None):
    try:
        from models.user import User
        admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
        if not admin:
            raise HTTPException(status_code=403, detail="Solo administradores pueden modificar configuraciones")
        
        setting = db.query(SiteSettings).filter(SiteSettings.key == key).first()
        serialized_value = json.dumps(value)  # Serializar a JSON
        if setting:
            setting.value = serialized_value
            setting.description = description or setting.description
        else:
            setting = SiteSettings(key=key, value=serialized_value, description=description)
            db.add(setting)
        db.commit()
        logger.info(f"Configuración '{key}' actualizada por admin {admin_id}: {value}")
        return {"key": key, "value": value}
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.error(f"Error al establecer ajuste {key}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al establecer ajuste")

#def get_all_settings(db: Session, admin_id: str) -> dict:
#    from models.user import User
#    admin = db.query(User).filter(User.id == admin_id, User.rol == "admin").first()
#    if not admin:
#        raise HTTPException(status_code=403, detail="Solo administradores pueden ver configuraciones")
#    
#    settings = db.query(SiteSettings).all()
#    return {s.key: json.loads(s.value) for s in settings}

# backend/schemas/site_settings.py
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class SiteSettingBase(BaseModel):
    key: str
    value: str
    description: Optional[str] = None
    tag: Optional[str] = None

class SiteSettingCreate(SiteSettingBase):
    pass

class SiteSettingResponse(SiteSettingBase):
    id: int
    updated_by: Optional[int] = None
    updated_at: datetime

    class Config:
        orm_mode = True


# backend/dependencies/auth.py
# Módulo de dependencias de autenticación.
# backend/dependencies/auth.py
from fastapi import Depends, HTTPException, Request
from sqlalchemy.orm import Session
from core.database import get_db
from models.user import User
# from models.guests import GuestsSession
from models.token import RevokedToken
from core.security import decode_token
from core.logging import configure_logging
from uuid import uuid4
from datetime import datetime
from pydantic import BaseModel
from fastapi import Response
import random
import string

logger = configure_logging()

class UserContext(BaseModel):
    user_id: str
    email: str
    username: str
    user_type: str  # "registered" o "anonymous"
    subscription: str
    credits: int
    rol: str
    session_id: str | None = None

    class Config:
        from_attributes = True

def generate_unique_username(db: Session) -> str:
    while True:
        random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        username = f"Guest_{random_chars}"
        if not db.query(GuestsSession).filter(GuestsSession.username == username).first():
            return username

async def get_user_context(request: Request, response: Response, db: Session = Depends(get_db)):
    token = request.headers.get("Authorization", "").replace("Bearer ", "")
    session_id = request.headers.get("X-Session-ID")  # Leer de header en lugar de cookie
    client_ip = request.client.host
    logger.info(f"Procesando solicitud: token={bool(token)}, session_id={session_id}, ip={client_ip}")

    try:
        if token:
            # Lógica para usuarios registrados (sin cambios)
            if db.query(RevokedToken).filter(RevokedToken.token == token).first():
                logger.warning(f"Intento de uso de token revocado desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token revocado")
            payload = decode_token(token)
            if not payload or payload.get("type") != "access":
                logger.error(f"Token inválido recibido desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token inválido o no es de acceso")
            user = db.query(User).filter(User.id == int(payload["sub"])).first()
            if not user:
                logger.error(f"Usuario no encontrado para token desde IP {client_ip}")
                raise HTTPException(status_code=404, detail="Usuario no encontrado")
            if not user.activo:
                logger.warning(f"Intento de acceso con usuario inactivo ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=403, detail="Usuario inactivo")
            if user.token_valid_until and user.token_valid_until < datetime.utcnow():
                logger.warning(f"Token expirado manualmente para usuario ID {user.id} desde IP {client_ip}")
                raise HTTPException(status_code=401, detail="Token no válido")
            
            user.last_ip = client_ip
            user.last_login = datetime.utcnow()
            db.commit()
            logger.info(f"Usuario registrado ID {user.id} autenticado desde IP {client_ip}")
            return UserContext(
                user_type="registered",
                user_id=str(user.id),
                email=user.email,
                username=user.username,
                credits=user.credits,
                subscription=user.subscription.value,
                rol=user.rol
            )

        if not session_id:
            logger.info("No hay session_id en header, creando nueva sesión anónima")
            session_id = str(uuid4())
            username = generate_unique_username(db)  # Generar apodo único
            new_session = GuestsSession(
                id=session_id,
                username=username,  # Asignar el apodo
                credits=10,
                create_at=datetime.utcnow(),
                ultima_actividad=datetime.utcnow(),
                last_ip=client_ip
            )
            db.add(new_session)
            db.commit()
            logger.info(f"Nueva sesión anónima creada ID {session_id} con username {username} desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session_id,
                email="anonymous@example.com",
                username=username,  # Usar el apodo generado
                credits=10,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )
        else:
            logger.info(f"Buscando sesión anónima con ID {session_id} desde header")
            session = db.query(GuestsSession).filter(GuestsSession.id == session_id).first()
            if not session:
                logger.warning(f"Sesión anónima inválida ID {session_id} desde IP {client_ip}")
                raise HTTPException(status_code=400, detail="Sesión anónima inválida")
            
            session.last_ip = client_ip
            session.ultima_actividad = datetime.utcnow()
            db.commit()
            logger.info(f"Sesión anónima ID {session_id} actualizada desde IP {client_ip}")
            return UserContext(
                user_type="anonymous",
                user_id=session.id,
                email="anonymous@example.com",
                username=session.username,  # Usar el username de la sesión
                credits=session.credits,
                subscription="basic",
                rol="anonymous",
                session_id=session_id
            )

        logger.error(f"No autorizado: sin token ni sesión válida desde IP {client_ip}")
        raise HTTPException(status_code=401, detail="No autorizado")
    except HTTPException as e:
        raise e
    except Exception as e:
        logger.critical(f"Error inesperado en get_user_context desde IP {client_ip}: {str(e)}")
        raise HTTPException(status_code=500, detail="Error al procesar la autenticación")

recuerda que tenemos dos modelos de usuario: guest y registered


# backend/models/user.py
# Módulo del modelo de usuario.
from datetime import datetime
from sqlalchemy import Column, Float, Integer, String, DateTime, Boolean, Enum
from core.database import Base
from sqlalchemy.orm import relationship
import enum

class subscriptionEnum(enum.Enum):
    FREEMIUM = "freemium"
    PREMIUM = "premium"
    CORPORATE = "corporate"

class User(Base):
    __tablename__ = "usuarios"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String(255), unique=True, index=True, nullable=False)
    username = Column(String(50), unique=True, index=True, nullable=False)
    password_hash = Column(String(255), nullable=True)  # Nullable para terceros
    auth_provider = Column(String(20), nullable=True)  # "local", "google", "meta", etc.
    provider_id = Column(String(255), nullable=True)  # ID único del proveedor
    rol = Column(String(20), default="user")  # "user" o "admin"
    activo = Column(Boolean, default=True)  # Estado de la cuenta
    subscription = Column(Enum(subscriptionEnum), default=subscriptionEnum.FREEMIUM)  # subscription de suscripción
    #ciudad = Column(String(100), nullable=True)  # Para perfil
    website = Column(String(255), nullable=True)  # URL de avatar o perfil
    credits = Column(Integer, default=10)  # Créditos disponibles
    #create_at = Column(DateTime, default=datetime.utcnow)  # Fecha de registro
    renewal = Column(DateTime, nullable=True)  # Última renovación de créditos
    last_ip = Column(String(45), nullable=True)  # Última IP conocida (IPv4/IPv6)
    last_login = Column(DateTime, nullable=True)  # Último inicio de sesión
    token_valid_until = Column(DateTime, nullable=True)  # Fecha de expiración del token actual
    
    
    gamification_events = relationship("GamificationEvent", back_populates="user")
    gamification = relationship("UserGamification", back_populates="user")
    
    
    
      # 📌 Ubicación y demografía
    #pais = Column(String(100), nullable=True)  
    ciudad = Column(String(100), nullable=True)  
    #zona_horaria = Column(String(50), nullable=True)  
    #idioma = Column(String(20), nullable=True)  

    # 📌 Datos de empresa
    #empresa = Column(String(255), nullable=True)  
    #industria = Column(String(100), nullable=True)  
    #tamaño_empresa = Column(String(50), nullable=True)  # Startup, PYME, Enterprise
    #num_empleados = Column(Integer, nullable=True)  
    #ingresos_anuales = Column(Float, nullable=True)  
    #presupuesto_estimado = Column(Float, nullable=True)  

    # 📌 Datos técnicos y uso
    #tecnologias_usadas = Column(String(255), nullable=True)  
    #nivel_digitalizacion = Column(String(50), nullable=True)  
    #dispositivo_frecuente = Column(String(50), nullable=True)  
    #engagement = Column(Float, nullable=True)  # % de funciones utilizadas  
    #tiempo_en_plataforma = Column(Integer, nullable=True)  # Minutos activos por mes  

    # 📌 Ciclo de vida
    create_at = Column(DateTime, default=datetime.utcnow)  
    #ultima_actividad = Column(DateTime, nullable=True)  
    #historial_pagos = Column(String(255), nullable=True)  
    #probabilidad_churn = Column(Float, nullable=True)  

    # 📌 Datos comerciales
    #volumen_transacciones = Column(Float, nullable=True)  
    #origen_lead = Column(String(100), nullable=True)  
    #clientes_referidos = Column(Integer, nullable=True)  

# backend/api/v1/anonymous_sessions.py
from fastapi import APIRouter, Depends, HTTPException, Query
from sqlalchemy.orm import Session
from typing import List
# from models.guests import GuestsSession
from schemas.anonymous_session import GuestsSessionResponse  # Asegúrate de que este esquema existe
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from math import ceil

router = APIRouter(tags=["Sessions"])

@router.get("/", response_model=dict)
def get_anonymous_sessions(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    user=Depends(get_user_context),
    db: Session = Depends(get_db)
):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="Solo los administradores pueden acceder a este recurso")
    
    offset = (page - 1) * limit
    query = db.query(GuestsSession)
    total_items = query.count()
    sessions = query.offset(offset).limit(limit).all()
    
    # Convertir los modelos SQLAlchemy a esquemas Pydantic
    sessions_data = [GuestsSessionResponse.from_orm(session) for session in sessions]
    
    return {
        "data": sessions_data,  # Usar los datos serializados
        "total_items": total_items,
        "total_pages": ceil(total_items / limit),
        "current_page": page
    }

@router.get("/credits", response_model=dict)
async def get_anonymous_credits(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.user_type != "anonymous":
        raise HTTPException(status_code=403, detail="Solo para usuarios anónimos")
    session = db.query(GuestsSession).filter(GuestsSession.id == user.user_id).first()
    if not session:
        raise HTTPException(status_code=404, detail="Sesión no encontrada")
    return {"credits": session.credits}


# backend/api/v1/anonymous_sessions.py
from pydantic import BaseModel
from datetime import datetime

class GuestsSessionBase(BaseModel):
    id: str
    username: str  # Nuevo campo
    credits: int
    create_at: datetime
    ultima_actividad: datetime | None
    last_ip: str | None

class GuestsSessionResponse(GuestsSessionBase):
    class Config:
        from_attributes = True  # Reemplaza orm_mode = True

# backend/schemas/gamification.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List

class EventTypeBase(BaseModel):
    name: str
    description: Optional[str] = None
    points_per_event: int = 0

class EventTypeCreate(EventTypeBase):
    pass

class EventTypeResponse(EventTypeBase):
    id: int

    class Config:
        from_attributes = True

class BadgeBase(BaseModel):
    name: str
    description: Optional[str] = None
    event_type_id: int
    required_points: int
    user_type: str = "both"

class BadgeCreate(BadgeBase):
    pass

class BadgeResponse(BadgeBase):
    id: int

    class Config:
        from_attributes = True

class GamificationEventBase(BaseModel):
    event_type_id: int

class GamificationEventCreate(GamificationEventBase):
    pass

class GamificationEventResponse(GamificationEventBase):
    id: int
    user_id: Optional[int]
    session_id: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

class UserGamificationBase(BaseModel):
    points: int
    badge_id: Optional[int]

class UserGamificationResponse(UserGamificationBase):
    event_type_id: int
    user_id: Optional[int]
    session_id: Optional[str]
    event_type: EventTypeResponse
    badge: Optional[BadgeResponse]

    class Config:
        from_attributes = True
        
        
class RankingResponse(BaseModel):
    username: str
    points: int
    badges_count: int
    user_type: str

    class Config:
        from_attributes = True

Recuerda que te estoy pasando archivos para que veas como estan generados otros modulos. Cualquier duda pregunta.

# backend/core/security.py
# Usar OAuth2 con Password Flow para autenticación segur

from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import jwt
from oauthlib.oauth2 import WebApplicationClient
from passlib.context import CryptContext
from datetime import datetime, timedelta
from jwt import encode, decode, PyJWTError
from os import getenv
from datetime import datetime, timedelta
from typing import Optional
from core.logging import configure_logging
from core.database import get_db
from services.settings_service import get_setting

logger = configure_logging()

# Configuración de OAuth2
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/v1/auth/token")
google_client = WebApplicationClient(getenv("GOOGLE_CLIENT_ID"))
meta_client = WebApplicationClient(getenv("META_CLIENT_ID"))

# Configuración de hash de contraseñas
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_token(user_id: str, user_type: str = "registered"):
    payload = {
        "sub": str(user_id),
        "type": user_type,
        "exp": datetime.utcnow() + timedelta(hours=24)
    }
    return jwt.encode(payload, getenv("SECRET_KEY"), algorithm="HS256")

def decode_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, getenv("SECRET_KEY"), algorithms=["HS256"])
        # Validación adicional del payload
        if not payload.get("sub") or not payload.get("type"):
            logger.warning(f"Token inválido: falta sub o type en el payload")
            return None
        return payload
    except jwt.ExpiredSignatureError:
        logger.warning("Token expirado")
        return None
    except jwt.InvalidTokenError as e:
        logger.warning(f"Token inválido: {str(e)}")
        return None
    except Exception as e:
        logger.error(f"Error inesperado al decodificar token: {str(e)}")
        return None

def create_access_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "token_expiration") or "3600")
        if expiration < 300:  # Mínimo 5 minutos
            expiration = 3600
            logger.warning("Token expiration too low, using default 1h")
    except Exception as e:
        logger.error(f"Error token_expiration: {str(e)}")
        expiration = 3600
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "access"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

def create_refresh_token(data: dict):
    db = next(get_db())
    try:
        # Validar y convertir a entero
        expiration = int(get_setting(db, "refresh_token_expiration") or "604800")
        if expiration < 86400:  # Mínimo 1 día
            expiration = 604800
            logger.warning("Refresh token expiration too low, using default 7d")
    except Exception as e:
        logger.error(f"Error refresh_token_expiration: {str(e)}")
        expiration = 604800
    
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode = data.copy()
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")


def create_refresh_token(data: dict):
    db = next(get_db())
    expiration_str = get_setting(db, "refresh_token_expiration") or "604800"  # Valor por defecto: 7 días
    try:
        expiration = int(str(expiration_str))  # Convertir a cadena primero y luego a entero
    except ValueError:
        logger.error(f"Valor inválido para refresh_token_expiration: {expiration_str}")
        expiration = 604800  # Valor por defecto si falla
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(seconds=expiration)
    to_encode.update({"exp": expire, "type": "refresh"})
    return jwt.encode(to_encode, getenv("SECRET_KEY"), algorithm="HS256")

    
def get_oauth2_redirect_url(provider: str) -> str:
    if provider == "google":
        return google_client.prepare_request_uri(
            "https://accounts.google.com/o/oauth2/v2/auth",
            redirect_uri=getenv("GOOGLE_REDIRECT_URI"),
            scope=["openid", "email", "profile"]
        )
    elif provider == "meta":
        return meta_client.prepare_request_uri(
            "https://www.facebook.com/v13.0/dialog/oauth",
            redirect_uri=getenv("META_REDIRECT_URI"),
            scope=["email"]
        )
    raise ValueError("Proveedor no soportado")

Por ultimo te dejo como referencia la api de gamificación que es la mas completa para que veas como usamos RESTFul y nuestro codigo
de programación:

# backend/api/v1/gamification.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from dependencies.auth import UserContext, get_user_context
from core.database import get_db
from services.gamification_service import (
    create_event_type, get_badges_for_event, get_event_details, get_event_types, get_rankings, get_user_events, get_user_gamification, get_user_progress_for_event, register_event, update_event_type, delete_event_type,
    create_badge, get_badges, update_badge, delete_badge
)
from schemas.gamification import (
    EventTypeCreate, EventTypeResponse, BadgeCreate, BadgeResponse,
    GamificationEventCreate, GamificationEventResponse, UserGamificationResponse, RankingResponse
)
from typing import List

router = APIRouter(tags=["Gamification"])

# Endpoints existentes
@router.get("/rankings", response_model=List[RankingResponse])
def get_rankings_endpoint(db: Session = Depends(get_db)):
    return get_rankings(db)

@router.post("/events")
async def create_event(event: GamificationEventCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    return register_event(db, event, user)

@router.get("/me", response_model=List[UserGamificationResponse])
def get_my_gamification(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    return get_user_gamification(db, user)

@router.get("/events", response_model=List[GamificationEventResponse])
def get_my_events(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    return get_user_events(db, user)

@router.get("/events/{event_id}", response_model=GamificationEventResponse)
def get_event_details_endpoint(event_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    event = get_event_details(db, event_id, user)
    if not event:
        raise HTTPException(status_code=404, detail="Event not found")
    return event

@router.get("/event-types/{event_type_id}/badges", response_model=List[BadgeResponse])
def get_badges_for_event_endpoint(event_type_id: int, db: Session = Depends(get_db)):
    badges = get_badges_for_event(db, event_type_id)
    if not badges:
        raise HTTPException(status_code=404, detail="No badges found for this event type")
    return badges

@router.get("/progress/{event_type_id}", response_model=UserGamificationResponse)
def get_user_progress_for_event_endpoint(event_type_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    progress = get_user_progress_for_event(db, user, event_type_id)
    if not progress:
        raise HTTPException(status_code=404, detail="Progress not found for this event")
    return progress

# Nuevos endpoints para administración
@router.post("/event-types", response_model=EventTypeResponse)
def create_event_type_endpoint(event_type: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_event_type(db, event_type)

@router.get("/event-types", response_model=List[EventTypeResponse])
def get_event_types_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_event_types(db)

@router.put("/event-types/{event_type_id}", response_model=EventTypeResponse)
def update_event_type_endpoint(event_type_id: int, event_type_update: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_event_type(db, event_type_id, event_type_update)

@router.delete("/event-types/{event_type_id}")
def delete_event_type_endpoint(event_type_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_event_type(db, event_type_id)

@router.post("/badges", response_model=BadgeResponse)
def create_badge_endpoint(badge: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_badge(db, badge)

@router.get("/badges", response_model=List[BadgeResponse])
def get_badges_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_badges(db)

@router.put("/badges/{badge_id}", response_model=BadgeResponse)
def update_badge_endpoint(badge_id: int, badge_update: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_badge(db, badge_id, badge_update)

@router.delete("/badges/{badge_id}")
def delete_badge_endpoint(badge_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_badge(db, badge_id)


@router.post("/event-types", response_model=EventTypeResponse)
def create_event_type_endpoint(event_type: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_event_type(db, event_type)

@router.get("/event-types", response_model=List[EventTypeResponse])
def get_event_types_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_event_types(db)

@router.put("/event-types/{event_type_id}", response_model=EventTypeResponse)
def update_event_type_endpoint(event_type_id: int, event_type_update: EventTypeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_event_type(db, event_type_id, event_type_update)

@router.delete("/event-types/{event_type_id}")
def delete_event_type_endpoint(event_type_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_event_type(db, event_type_id)

# Endpoints para Badge
@router.post("/badges", response_model=BadgeResponse)
def create_badge_endpoint(badge: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return create_badge(db, badge)

@router.get("/badges", response_model=List[BadgeResponse])
def get_badges_endpoint(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return get_badges(db)

@router.put("/badges/{badge_id}", response_model=BadgeResponse)
def update_badge_endpoint(badge_id: int, badge_update: BadgeCreate, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return update_badge(db, badge_id, badge_update)

@router.delete("/badges/{badge_id}")
def delete_badge_endpoint(badge_id: int, user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    if user.rol != "admin":
        raise HTTPException(status_code=403, detail="No autorizado")
    return delete_badge(db, badge_id)



Si necesitas algun archivo de referencia del backend pidemelo, recuerda que en el backend debes generar Para el backend: 

- los endpoints necesarios en la API actual para gestionar toda la logica de los cupones
- las dependencias, si procede, que requerira la logica para los cupones
- middleware para los cupones si lo consideras necesario, que quizas no sea el caso
- modelo completo de datos con todos los atributos y relaciones necesarias si las hubiere
- shemas pydantic necesarios para la implantación correcta del sistema de cupones
- servicios necesarios para la implantación robusta y fiable de la logica de los cupones
- algunos cupones de ejemplo para insertarlos en los datos iniciales
- crear un Site_setting necesario para poder habilitar y deshabilitar los cupones
- actualizar todos los archivos necesarios como main.py o los afectados para la implantación de la logica.
. cualquier otra cosa que necesites implantar

por ultimo, por motivos de demostración tendrás que hacer un endpoint donde el usuario pueda generar cupones aleatorios de la cantidad
de creditos elegida sin ser admin (para que usuarios anonimos prueben en nuestro landing como ya sabes)

Ahora te paso los archivos que necesitaras para el frontend:

Primero el mas importante: el contexto:

// src/lib/auth/context.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge  } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // Añadimos gamificación al contexto
  setCredits: (credits: number) => void; // Añadido
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  setGamification: (gamification: Gamification) => void; // Añadido
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}



const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(10); // Valor por defecto para anónimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificación
  const [loading, setLoading] = useState(true);
  const router = useRouter();


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<UserInfo>("/info");
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
            localStorage.setItem("anonUsername", data.username!);
          } else {
            setUser(null);
            setCredits(0);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          }
  
          // Procesar datos de gamificación
          const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
          if (gamificationData && Array.isArray(gamificationData)) {
            const totalPoints = gamificationData.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationData.map(g => g.badge).filter(b => b !== null) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        localStorage.removeItem("session_id");
        localStorage.removeItem("anonUsername");
      } finally {
        setLoading(false);
      }
    };
  
    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesión
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesión
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operación
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits,gamification, setGamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// src/lib/types.ts
export interface User {
  id: number;
  email: string;
  username: string;
  rol: string;
  activo: boolean;
  subscription: string;
  ciudad?: string;
  website?: string;
  credits: number;
  create_at: string;  // ISO string (e.g., "2023-10-01T12:00:00Z")
  last_ip?: string;
  last_login: string;
  user_type: string;
}

export interface TokenResponse {
  access_token: string;
  refresh_token: string;
  token_type: string;
}



export interface RegisterRequest {
  email: string;
  username: string;
  password: string;
  ciudad?: string;
  website?: string;
}

export interface UpdateProfileRequest {
  email?: string;
  username?: string;
  ciudad?: string;
  website?: string;
}

export interface PurchaseRequest {
  credits: number;
  payment_amount: number;
  payment_method?: string;
}

export interface PurchaseResponse {
  transaction_id: string;
  credits_added: number;
  new_balance: number;
}

export interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
  created_at: string;  // ISO string
  updated_at: string;  // ISO string
}

export interface HTTPValidationError {
  detail: ValidationError[];
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status?: string;
  timestamp: string; // ISO string
}

export interface Integration {
  id: number;
  name: string;
  webhook_url: string;
  event_type: string;
  active: boolean;
  created_at: string;
  last_triggered: string | null;
}

export interface SiteSetting {
    id: number;
    key: string;
    value: string;
    description?: string;
    tag?: string;
    updated_by?: number;
    updated_at: string; // ISO string
}

export interface FetchResponse<T> {
  data: T | null;
  error: string | HTTPValidationError | null;
  total_pages?: number;
}

// src/lib/types.ts
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string;
  gamification: UserGamificationResponse[]; // Actualizado para reflejar /info
}

export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[];
}

export interface GamificationEventCreate {
  event_type_id: number;
}

export interface GamificationEventResponse {
  id: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  timestamp: string; // ISO string
}

export interface UserGamificationResponse {
  points: number;
  badge_id?: number;
  event_type_id: number;
  user_id?: number;
  session_id?: string;
  event_type: EventType;
  badge?: Badge;
}
export interface RankingResponse {
  username: string;
  points: number;
  badges_count: number;
  user_type: string;
}

export interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}



export interface InfoResponse {
  credits: number;
  gamification: { points: number; badge: Badge | null }[];
}


export interface BadgeWithEventType extends Badge {
  event_type: EventType;
}


el navbar importante:

// src/components/web/Navbar.tsx
// src/components/web/Navbar.tsx
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import { usePathname } from "next/navigation";
import fetchAPI from "@/lib/api";
import {
  Button,
  Avatar,
  IconButton,
  Menu,
  MenuItem,
  useTheme,
  styled,
  Box,
  Typography,
  Snackbar,
  Alert,
  Drawer,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Tooltip
} from "@mui/material";
import {
  MonetizationOn,
  Settings,
  ListAlt,
  People,
  Dashboard,
  Login,
  PersonAdd,
  Person,
  Home,
  Star,
  EmojiEvents,
  Leaderboard,
  School,
  Menu as MenuIcon,
  ContactMail,
  Close,
  Key
} from "@mui/icons-material";
import Image from "next/image";

const GlassNavbar = styled("nav")(({ theme }) => ({
  background: "rgba(255, 255, 255, 0.1)",
  backdropFilter: "blur(10px)",
  borderBottom: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1, 2),
  position: "fixed",
  top: 0,
  left: 0,
  right: 0,
  zIndex: 1000,
}));

const NavContainer = styled(Box)(({ theme }) => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  maxWidth: "1200px",
  margin: "0 auto",
  [theme.breakpoints.down("md")]: {
    flexDirection: "row",
    alignItems: "center",
    gap: 1
  },
}));

export default function Navbar() {
  const theme = useTheme();
  const pathname = usePathname();
  const { user, credits, gamification, setCredits, setGamification, logout } = useAuth();
  const [settingsAnchorEl, setSettingsAnchorEl] = useState<null | HTMLElement>(null);
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [disableCredits, setDisableCredits] = useState(false);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const [enablePoints, setEnablePoints] = useState(true);
  const [enableBadges, setEnableBadges] = useState(true);
  const [enablePaymentMethods, setEnablePaymentMethods] = useState(true);
  const [anonUsername, setAnonUsername] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [newBadge, setNewBadge] = useState<string | null>(null);

  useEffect(() => {
    const storedAnonUsername = localStorage.getItem("anonUsername");
    setAnonUsername(storedAnonUsername);
  }, []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const [
          disableCreditsRes,
          enableRegistrationRes,
          enablePointsRes,
          enableBadgesRes,
          enablePaymentMethodsRes,
        ] = await Promise.all([
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_badges"),
          fetchAPI("/v1/settings/enable_payment_methods"),
        ]);
        setDisableCredits(disableCreditsRes.data === "true" || disableCreditsRes.data === true);
        setEnableRegistration(enableRegistrationRes.data === "true" || enableRegistrationRes.data === true);
        setEnablePoints(enablePointsRes.data === "true" || enablePointsRes.data === true);
        setEnableBadges(enableBadgesRes.data === "true" || enableBadgesRes.data === true);
        setEnablePaymentMethods(enablePaymentMethodsRes.data === "true" || enablePaymentMethodsRes.data === true);
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
      }
    };
    fetchSettings();
  }, []);

  interface InfoData {
    credits: number;
  }

  useEffect(() => {
    if (!enablePoints && !enableBadges) return;

    const interval = setInterval(async () => {
      try {
        const { data: infoData } = await fetchAPI<InfoData>("/info");
        if (infoData) {
          setCredits(infoData.credits);
        }

        const { data: gamificationData } = await fetchAPI("/v1/gamification/me");
        if (gamificationData && Array.isArray(gamificationData)) {
          const totalPoints = enablePoints
            ? gamificationData.reduce((sum, g) => sum + g.points, 0)
            : 0;
          const badges = enableBadges
            ? gamificationData.map((g) => g.badge).filter((b) => b !== null)
            : [];

          const previousBadges = JSON.parse(localStorage.getItem("badges") || "[]");
          const currentBadgeIds = badges.map((b) => b.id);
          const newBadges = currentBadgeIds.filter((id) => !previousBadges.includes(id));
          if (newBadges.length > 0 && enableBadges) {
            const badge = badges.find((b) => b.id === newBadges[0]);
            setNewBadge(badge?.name || "Nuevo badge");
            setSnackbarOpen(true);
            localStorage.setItem("badges", JSON.stringify(currentBadgeIds));
          }

          setGamification({ points: totalPoints, badges });
        }
      } catch (err) {
        console.error("Error al actualizar datos:", err);
      }
    }, 30000);

    return () => clearInterval(interval);
  }, [setCredits, setGamification, enablePoints, enableBadges]);

  const handleSettingsMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchorEl(event.currentTarget);
  };

  const handleSettingsMenuClose = () => {
    setSettingsAnchorEl(null);
  };

  const handleDrawerOpen = () => {
    setDrawerOpen(true);
  };

  const handleDrawerClose = () => {
    setDrawerOpen(false);
  };

  return (
    <GlassNavbar>
      <NavContainer>
        {/* Sección izquierda: Logo y menú hamburguesa */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
          <IconButton
            onClick={handleDrawerOpen}
            sx={{ display: { xs: "block", md: "none" } }}
          >
            <MenuIcon />
          </IconButton>

          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            <Link href="/" passHref>
              <Box sx={{ 
                display: "flex", 
                alignItems: "center",
                gap: 1,
                cursor: "pointer"
              }}>
                <Image 
                  src="/logo.png" 
                  alt="Logo Neptuno" 
                  width={40} 
                  height={40}
                  style={{ borderRadius: "50%" }}
                />
                <Typography
                  variant="h6"
                  component="span"
                  className="app-logo"
                  sx={{
                    fontWeight: "bold",
                    display: {
                      xs: 'none', // Oculto en móvil
                      md: 'block' // Visible en desktop
                    }
                  }}
                >
                  Neptuno
                </Typography>
              </Box>
            </Link>
          </Box>
        </Box>

        {/* Sección derecha: Todos los elementos */}
        <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
          {/* Enlaces desktop + iconos */}
          <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
            {/* Enlaces desktop */}
            <Box sx={{ display: { xs: "none", md: "flex" }, gap: 2, mr: 1 }}>
              <Button
                component={Link}
                href="/ejemplos"
                className={pathname === '/ejemplos' ? 'active-link' : ''}
              >
                Ejemplos
              </Button>
              <Button
                component={Link}
                href="/rankings"
                className={pathname === '/rankings' ? 'active-link' : ''}
              >
                Rankings
              </Button>
            </Box>

            {/* Iconos de notificaciones */}
            <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
              {!disableCredits && credits > 0 && (
                <Link href="/user/transactions" passHref>
                  <IconButton className="notification-icon">
                    <MonetizationOn />
                    <span className="notification-badge credits-badge">{credits}</span>
                  </IconButton>
                </Link>
              )}

              {gamification && (
                <>
                  {enablePoints && (
                    <Link href="/user/points" passHref>
                      <IconButton className="notification-icon">
                        <Star />
                        <span className="notification-badge points-badge">{gamification.points}</span>
                      </IconButton>
                    </Link>
                  )}
                  {enableBadges && (
                    <Link href="/user/badges" passHref>
                      <IconButton className="notification-icon">
                        <EmojiEvents />
                        <span className="notification-badge badges-badge">{gamification.badges.length}</span>
                      </IconButton>
                    </Link>
                  )}
                </>
              )}
            </Box>
          </Box>

          {/* Menú admin y usuario */}
          <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
            {user?.rol === "admin" && (
              <>
                <IconButton
                  onClick={handleSettingsMenuOpen}
                  sx={{ color: "inherit" }}
                >
                  <Settings />
                </IconButton>
                <Menu
                  anchorEl={settingsAnchorEl}
                  open={Boolean(settingsAnchorEl)}
                  onClose={handleSettingsMenuClose}
                  PaperProps={{
                    sx: {
                      background: "rgba(255, 255, 255, 0.9)",
                      backdropFilter: "blur(10px)",
                      borderRadius: "12px",
                      mt: 1,
                      minWidth: "200px",
                    },
                  }}
                >
                  <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/dashboard">
                    <Dashboard sx={{ mr: 1 }} /> Dashboard
                  </MenuItem>
                  <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/registry">
                    <ListAlt sx={{ mr: 1 }} /> Registros
                  </MenuItem>
                  <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/users">
                    <People sx={{ mr: 1 }} /> Usuarios
                  </MenuItem>
                </Menu>
              </>
            )}

            {/* Avatar de usuario */}
            {user ? (
              <Tooltip title={user.username} arrow>
                <IconButton
                  component={Link}
                  href="/user/dashboard"
                  className="user-avatar"
                >
                  <Avatar sx={{
                    bgcolor: theme.palette.primary.main,
                    width: 40,
                    height: 40,
                    fontSize: '1rem'
                  }}>
                    {user.username[0].toUpperCase()}
                  </Avatar>
                </IconButton>
              </Tooltip>
            ) : (
              <Tooltip title={anonUsername ? "Iniciar sesión" : "Registrarse"} arrow>
                <Box sx={{ position: 'relative' }}>
                  <IconButton 
                    component={Link}
                    href={anonUsername ? "/user/auth/#login" : "/user/auth/#register"}
                    className="user-avatar"
                  >
                    <Avatar sx={{
                      bgcolor: theme.palette.grey[500],
                      width: 40,
                      height: 40,
                      color: theme.palette.common.white
                    }}>
                      {anonUsername ? <Person /> : <Key />}
                    </Avatar>
                  </IconButton>
                  {anonUsername && (
                    <Box sx={{
                      position: 'absolute',
                      top: 0,
                      right: 0,
                      backgroundColor: theme.palette.secondary.main,
                      borderRadius: '50%',
                      width: 20,
                      height: 20,
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      border: `2px solid ${theme.palette.background.paper}`
                    }}>
                      <Key sx={{ fontSize: 12, color: theme.palette.common.white }} />
                    </Box>
                  )}
                </Box>
              </Tooltip>
            )}
          </Box>
        </Box>

        {/* Menú hamburguesa */}
        <Drawer anchor="left" open={drawerOpen} onClose={handleDrawerClose}>
          <List>
            {/* Header del menú */}
            <Box sx={{
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'space-between',
              p: 2,
              borderBottom: `1px solid ${theme.palette.divider}`
            }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Image 
                  src="/logo.png" 
                  alt="Logo Neptuno" 
                  width={40} 
                  height={40}
                  style={{ borderRadius: "50%" }}
                />
                <Typography
                  variant="h6"
                  sx={{
                    fontWeight: "bold",
                    background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                    WebkitBackgroundClip: "text",
                    WebkitTextFillColor: "transparent",
                    display: "inline-block",
                  }}
                >
                  Neptuno
                </Typography>
              </Box>
              <IconButton onClick={handleDrawerClose}>
                <Close />
              </IconButton>
            </Box>

            <ListItem component={Link} href="/">
              <ListItemIcon><Home /></ListItemIcon>
              <ListItemText primary="Inicio" />
            </ListItem>
            <ListItem component={Link} href="/ejemplos">
              <ListItemIcon><School /></ListItemIcon>
              <ListItemText primary="Ejemplos" />
            </ListItem>
            <ListItem component={Link} href="/rankings">
              <ListItemIcon><Leaderboard /></ListItemIcon>
              <ListItemText primary="Rankings" />
            </ListItem>
            <ListItem component={Link} href="/about/contact">
              <ListItemIcon><ContactMail /></ListItemIcon>
              <ListItemText primary="Contacto" />
            </ListItem>

            {user?.rol === "admin" && (
              <>
                <ListItem component={Link} href="/admin/dashboard">
                  <ListItemIcon><Dashboard /></ListItemIcon>
                  <ListItemText primary="Dashboard" />
                </ListItem>
                <ListItem component={Link} href="/admin/registry">
                  <ListItemIcon><ListAlt /></ListItemIcon>
                  <ListItemText primary="Registros" />
                </ListItem>
                <ListItem component={Link} href="/admin/users">
                  <ListItemIcon><People /></ListItemIcon>
                  <ListItemText primary="Usuarios" />
                </ListItem>
              </>
            )}
            {user ? (
              <ListItem component={Link} href="/user/dashboard">
                <ListItemIcon><Person /></ListItemIcon>
                <ListItemText primary={user.username} />
              </ListItem>
            ) : (
              <>
                <ListItem component={Link} href="/user/auth/#login">
                  <ListItemIcon><Login /></ListItemIcon>
                  <ListItemText primary="Iniciar Sesión" />
                </ListItem>
                {enableRegistration && (
                  <ListItem component={Link} href="/user/auth/#register">
                    <ListItemIcon><PersonAdd /></ListItemIcon>
                    <ListItemText primary="Registrarse" />
                  </ListItem>
                )}
              </>
            )}
          </List>
        </Drawer>
      </NavContainer>

      <Snackbar open={snackbarOpen} autoHideDuration={6000} onClose={() => setSnackbarOpen(false)}>
        <Alert onClose={() => setSnackbarOpen(false)} severity="success" sx={{ width: "100%" }}>
          ¡Felicidades! Has obtenido el badge: {newBadge}
        </Alert>
      </Snackbar>
    </GlassNavbar>
  );
}

dashboard del usuario:

// src/app/user/dashboard/page.tsx
// src/app/user/dashboard/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { Dialog, DialogTitle, DialogContent, DialogActions } from "@mui/material";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box, Grid, Card, CardContent, CardHeader, TextField, Button, Accordion, AccordionSummary, AccordionDetails, Typography, IconButton,
  Snackbar, Alert, MenuItem, Avatar, Chip, Divider, List, ListItem, ListItemAvatar, ListItemText, Badge, Paper, Tabs, Tab, useTheme, styled
} from "@mui/material";
import {
  AccountCircle, Lock, Payment, CreditCard, AddCircle, Delete, ExpandMore, Edit, History, AttachMoney, Security, Logout, Person,
  LocationOn, Language, Star, StarBorder
} from "@mui/icons-material";

// Styled Components
const GradientCard = styled(Card)(({ theme }) => ({
  background: `linear-gradient(135deg, var(--primary) 0%, var(--primary-hover) 100%)`,
  color: 'white',
  borderRadius: '16px',
  boxShadow: theme.shadows[4]
}));

const GlassCard = styled(Card)(({ theme }) => ({
  background: 'rgba(248, 249, 250, 0.8)',
  backdropFilter: 'blur(10px)',
  border: '1px solid rgba(222, 226, 230, 0.5)',
  borderRadius: '16px',
  boxShadow: theme.shadows[2]
}));

interface PaymentMethod {
  id: number;
  payment_type: string;
  details: string;
  is_default: boolean;
}

interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string;
}

interface PaymentProvider {
  id: number;
  name: string;
  active: boolean;
}

export default function UserDashboard() {
  const { user, logout, updateProfile } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [editMode, setEditMode] = useState(false);
  const [formData, setFormData] = useState({ email: "", username: "", ciudad: "", website: "" });
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [methods, setMethods] = useState<PaymentMethod[]>([]);
  const [newMethod, setNewMethod] = useState({ payment_type: "", details: "", is_default: false });
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>([]);
  const [credits, setCredits] = useState("");
  const [paymentAmount, setPaymentAmount] = useState("");
  const [currentPassword, setCurrentPassword] = useState("");
  const [newPassword, setNewPassword] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [tabValue, setTabValue] = useState(0);
  const [editMethod, setEditMethod] = useState<PaymentMethod | null>(null);
  const [deleteMethodId, setDeleteMethodId] = useState<number | null>(null);

  useEffect(() => {
    if (!user) {
      router.push("/");
      return;
    }
    setFormData({
      email: user.email || "",
      username: user.username || "",
      ciudad: user.ciudad || "",
      website: user.website || "",
    });

    const fetchData = async () => {
      try {
        const [transRes, methRes, providersRes] = await Promise.all([
          fetchAPI<CreditTransaction[]>("/v1/payments/transactions"),
          fetchAPI<PaymentMethod[]>("/v1/payments/methods"),
          fetchAPI<PaymentProvider[]>("/v1/payment-providers"),
        ]);
        setTransactions(transRes.data || []);
        setMethods(methRes.data || []);
        setPaymentProviders(providersRes.data?.filter(p => p.active) || []);
        if (providersRes.data && providersRes.data.length > 0) {
          setNewMethod(prev => ({ ...prev, payment_type: providersRes.data.find(p => p.active)?.name || "" }));
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      }
    };
    fetchData();
  }, [user, router]);

  const handleEditMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!editMethod) return;
    try {
      const { data } = await fetchAPI<PaymentMethod>(`/v1/payments/methods/${editMethod.id}`, {
        method: "PUT",
        data: editMethod,
      });
      setMethods(methods.map((m) => (m.id === data!.id ? data! : m)));
      setEditMethod(null);
      setSuccess("Método actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar método");
    }
  };

  const handleDeleteMethod = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}`, { method: "DELETE" });
      setMethods(methods.filter((m) => m.id !== id));
      setDeleteMethodId(null);
      setSuccess("Método eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar método");
    }
  };

  const handleUpdate = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await updateProfile(formData);
      setSuccess("Perfil actualizado");
      setEditMode(false);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar perfil");
    }
  };

  const handleChangePassword = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<{ message: string }>("/v1/auth/me/password", {
        method: "PUT",
        data: { current_password: currentPassword, new_password: newPassword },
      });
      setSuccess(data?.message || "Contraseña actualizada");
      setCurrentPassword("");
      setNewPassword("");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al cambiar contraseña");
    }
  };

  const handlePurchase = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<CreditTransaction>("/v1/payments/purchase", {
        method: "POST",
        data: { credits: parseInt(credits), payment_amount: parseFloat(paymentAmount), payment_method: "stripe" },
      });
      setTransactions([data!, ...transactions]);
      setCredits("");
      setPaymentAmount("");
      setSuccess("Créditos comprados");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al comprar créditos");
    }
  };

  const handleAddMethod = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentMethod>("/v1/payments/methods", {
        method: "POST",
        data: newMethod,
      });
      setMethods([...methods, data!]);
      setNewMethod({ payment_type: paymentProviders[0]?.name || "", details: "", is_default: false });
      setSuccess("Método añadido");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir método");
    }
  };

  const handleSetDefault = async (id: number) => {
    try {
      await fetchAPI(`/v1/payments/methods/${id}/default`, { method: "PUT" });
      setMethods(methods.map((m) => ({ ...m, is_default: m.id === id })));
      setSuccess("Método predeterminado actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al establecer predeterminado");
    }
  };

  const handleDeleteAccount = async () => {
    if (confirm("¿Estás seguro de eliminar tu cuenta? Esta acción es irreversible.")) {
      try {
        await fetchAPI("/v1/users/me", { method: "DELETE" });
        await logout();
        router.push("/user/auth/#login");
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al eliminar cuenta");
      }
    }
  };

  if (!user) return (
    <Box sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h6" color="textSecondary">Cargando tu perfil...</Typography>
      </motion.div>
    </Box>
  );

  return (
    <Box sx={{
      p: { xs: 2, md: 4 },
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <Box sx={{ maxWidth: '1400px', mx: 'auto' }}>
        {/* Header Section */}
        <Box sx={{
          display: 'flex',
          flexDirection: { xs: 'column', md: 'row' },
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 4,
          gap: 2
        }}>
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                display: 'inline-block'
              }}
            >
              Hola, {user.username}!
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Bienvenido a tu panel de control
            </Typography>
          </motion.div>

          <Badge
            overlap="circular"
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
            badgeContent={
              <IconButton onClick={() => setEditMode(true)} size="small" sx={{ bgcolor: 'primary.main', color: 'white' }}>
                <Edit fontSize="small" />
              </IconButton>
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.primary.main,
                fontSize: '2rem',
                boxShadow: theme.shadows[6]
              }}
            >
              {user.username.charAt(0).toUpperCase()}
            </Avatar>
          </Badge>
        </Box>

        {/* Stats Cards */}
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5, delay: 0.1 }}
        >
          <Grid container spacing={3} sx={{ mb: 4 }}>
            {/* Credits Card */}
            <Grid item xs={12} md={4}>
              <GradientCard>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Tus Créditos
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {user.credits ?? 0}
                      </Typography>
                    </Box>
                    <AttachMoney sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Transactions Card */}
            <Grid item xs={12} md={4}>
              <GradientCard sx={{ background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)' }}>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Transacciones
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {transactions.length}
                      </Typography>
                    </Box>
                    <History sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>

            {/* Payment Methods Card */}
            <Grid item xs={12} md={4}>
              <GradientCard sx={{ background: 'linear-gradient(135deg, #a6c1ee 0%, #fbc2eb 100%)' }}>
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                    <Box>
                      <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                        Métodos de Pago
                      </Typography>
                      <Typography variant="h3" sx={{ fontWeight: 'bold' }}>
                        {methods.length}
                      </Typography>
                    </Box>
                    <Payment sx={{ fontSize: 48, opacity: 0.8 }} />
                  </Box>
                </CardContent>
              </GradientCard>
            </Grid>
          </Grid>
        </motion.div>

        {/* Tabs Navigation */}
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          <Paper sx={{ mb: 3, borderRadius: '12px', overflow: 'hidden' }}>
            <Tabs
              value={tabValue}
              onChange={(_, newValue) => setTabValue(newValue)}
              variant="scrollable"
              scrollButtons="auto"
              indicatorColor="primary"
              textColor="primary"
            >
              <Tab label="Perfil" icon={<Person />} iconPosition="start" />
              <Tab label="Seguridad" icon={<Security />} iconPosition="start" />
              <Tab label="Transacciones" icon={<History />} iconPosition="start" />
              <Tab label="Métodos de Pago" icon={<Payment />} iconPosition="start" />
              <Tab label="Comprar Créditos" icon={<CreditCard />} iconPosition="start" />
            </Tabs>
          </Paper>
        </motion.div>

        {/* Tab Content */}
        <Box sx={{ mb: 4 }}>
          {/* Profile Tab */}
          {tabValue === 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Información Personal"
                      avatar={<AccountCircle color="primary" />}
                      action={
                        <IconButton onClick={() => setEditMode(!editMode)}>
                          <Edit color="primary" />
                        </IconButton>
                      }
                    />
                    <CardContent>
                      <AnimatePresence mode="wait">
                        {editMode ? (
                          <Box
                            component={motion.form}
                            key="edit"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                            onSubmit={handleUpdate}
                            sx={{ display: "flex", flexDirection: "column", gap: 2 }}
                          >
                            <TextField
                              label="Email"
                              type="email"
                              value={formData.email}
                              onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Username"
                              type="text"
                              value={formData.username}
                              onChange={(e) => setFormData({ ...formData, username: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                            />
                            <TextField
                              label="Ciudad"
                              type="text"
                              value={formData.ciudad}
                              onChange={(e) => setFormData({ ...formData, ciudad: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: <LocationOn color="action" sx={{ mr: 1 }} />
                              }}
                            />
                            <TextField
                              label="Website"
                              type="text"
                              value={formData.website}
                              onChange={(e) => setFormData({ ...formData, website: e.target.value })}
                              fullWidth
                              variant="outlined"
                              size="small"
                              InputProps={{
                                startAdornment: <Language color="action" sx={{ mr: 1 }} />
                              }}
                            />
                            <Box sx={{ display: "flex", gap: 2, mt: 2 }}>
                              <Button
                                type="submit"
                                variant="contained"
                                color="primary"
                                sx={{ flex: 1 }}
                              >
                                Guardar Cambios
                              </Button>
                              <Button
                                onClick={() => setEditMode(false)}
                                variant="outlined"
                                sx={{ flex: 1 }}
                              >
                                Cancelar
                              </Button>
                            </Box>
                          </Box>
                        ) : (
                          <Box
                            component={motion.div}
                            key="view"
                            initial={{ opacity: 0 }}
                            animate={{ opacity: 1 }}
                            exit={{ opacity: 0 }}
                          >
                            <List>
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.primary.light }}>
                                    <Person />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Username"
                                  secondary={user.username || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                                    <AccountCircle />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Email"
                                  secondary={user.email || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.success.light }}>
                                    <LocationOn />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Ciudad"
                                  secondary={user.ciudad || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                              <Divider variant="inset" component="li" />
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{ bgcolor: theme.palette.warning.light }}>
                                    <Language />
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary="Website"
                                  secondary={user.website || "No especificado"}
                                  secondaryTypographyProps={{ color: "textPrimary" }}
                                />
                              </ListItem>
                            </List>
                          </Box>
                        )}
                      </AnimatePresence>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Actividad Reciente"
                      avatar={<History color="primary" />}
                    />
                    <CardContent>
                      {transactions.slice(0, 3).length > 0 ? (
                        <List>
                          {transactions.slice(0, 3).map((t) => (
                            <motion.div
                              key={t.id}
                              initial={{ opacity: 0 }}
                              animate={{ opacity: 1 }}
                              transition={{ duration: 0.3 }}
                            >
                              <ListItem>
                                <ListItemAvatar>
                                  <Avatar sx={{
                                    bgcolor: t.amount > 0 ? theme.palette.success.light : theme.palette.error.light
                                  }}>
                                    {t.amount > 0 ? "+" : "-"}
                                  </Avatar>
                                </ListItemAvatar>
                                <ListItemText
                                  primary={`${t.transaction_type}`}
                                  secondary={`${new Date(t.timestamp).toLocaleString()} • ${t.payment_status}`}
                                />
                                <Typography variant="body2" color={t.amount > 0 ? "success.main" : "error.main"}>
                                  {t.amount > 0 ? "+" : ""}{t.amount} créditos
                                </Typography>
                              </ListItem>
                              <Divider variant="inset" component="li" />
                            </motion.div>
                          ))}
                        </List>
                      ) : (
                        <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 2 }}>
                          No hay actividad reciente
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(2)}
                      >
                        Ver todas las transacciones
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>

              {/* Danger Zone moved to Profile Tab */}
              <GlassCard sx={{ mt: 3 }}>
                <CardHeader
                  title="Zona Peligrosa"
                  avatar={<Security color="error" />}
                />
                <CardContent>
                  <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
                    Estas acciones son irreversibles. Por favor, procede con precaución.
                  </Typography>
                  <Box sx={{ display: 'flex', gap: 2 }}>
                    <Button
                      onClick={logout}
                      variant="outlined"
                      color="secondary"
                      startIcon={<Logout />}
                      sx={{ flex: 1 }}
                    >
                      Cerrar Sesión
                    </Button>
                    <Button
                      onClick={handleDeleteAccount}
                      variant="contained"
                      color="error"
                      startIcon={<Delete />}
                      sx={{ flex: 1 }}
                    >
                      Eliminar Cuenta
                    </Button>
                  </Box>
                </CardContent>
              </GlassCard>
            </motion.div>
          )}

          {/* Security Tab */}
          {tabValue === 1 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Cambiar Contraseña"
                      avatar={<Lock color="primary" />}
                    />
                    <CardContent>
                      <Box
                        component="form"
                        onSubmit={handleChangePassword}
                        sx={{ display: "flex", flexDirection: "column", gap: 2 }}
                      >
                        <TextField
                          label="Contraseña Actual"
                          type="password"
                          value={currentPassword}
                          onChange={(e) => setCurrentPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: <Lock color="action" sx={{ mr: 1 }} />
                          }}
                        />
                        <TextField
                          label="Nueva Contraseña"
                          type="password"
                          value={newPassword}
                          onChange={(e) => setNewPassword(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{
                            startAdornment: <Security color="action" sx={{ mr: 1 }} />
                          }}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          sx={{ mt: 1 }}
                        >
                          Actualizar Contraseña
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader
                      title="Métodos de Pago"
                      subheader={`${methods.length} configurados`}
                      avatar={<Payment color="primary" />}
                    />
                    <CardContent>
                      {methods.length > 0 ? (
                        <List>
                          {methods.slice(0, 2).map((m) => (
                            <ListItem key={m.id}>
                              <ListItemAvatar>
                                <Avatar sx={{ bgcolor: m.is_default ? theme.palette.success.light : theme.palette.grey[300] }}>
                                  {m.is_default ? <Star /> : <StarBorder />}
                                </Avatar>
                              </ListItemAvatar>
                              <ListItemText
                                primary={m.payment_type}
                                secondary={m.details}
                              />
                            </ListItem>
                          ))}
                        </List>
                      ) : (
                        <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 2 }}>
                          No hay métodos de pago configurados
                        </Typography>
                      )}
                      <Button
                        fullWidth
                        variant="outlined"
                        sx={{ mt: 2 }}
                        onClick={() => setTabValue(3)}
                      >
                        {methods.length > 0 ? 'Gestionar métodos' : 'Añadir método'}
                      </Button>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}

          {/* Transactions Tab */}
          {tabValue === 2 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              transition={{ duration: 0.3 }}
            >
              <GlassCard>
                <CardHeader
                  title="Historial de Transacciones"
                  avatar={<History color="primary" />}
                  action={
                    <Chip
                      label={`${transactions.length} transacciones`}
                      color="primary"
                      variant="outlined"
                    />
                  }
                />
                <CardContent>
                  {transactions.length === 0 ? (
                    <Typography variant="body2" color="textSecondary" sx={{ textAlign: 'center', py: 4 }}>
                      No hay transacciones registradas
                    </Typography>
                  ) : (
                    <List sx={{ maxHeight: '500px', overflow: 'auto' }}>
                      {transactions.map((t) => (
                        <motion.div
                          key={t.id}
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          transition={{ duration: 0.2 }}
                        >
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{
                                bgcolor: t.amount > 0 ? theme.palette.success.light : theme.palette.error.light
                              }}>
                                {t.amount > 0 ? "+" : "-"}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={t.transaction_type}
                              secondary={`${new Date(t.timestamp).toLocaleString()} • ${t.payment_status}`}
                            />
                            <Box sx={{ display: 'flex', flexDirection: 'column', alignItems: 'flex-end' }}>
                              <Typography
                                variant="subtitle1"
                                color={t.amount > 0 ? "success.main" : "error.main"}
                                fontWeight="bold"
                              >
                                {t.amount > 0 ? "+" : ""}{t.amount} créditos
                              </Typography>
                              <Typography variant="caption" color="textSecondary">
                                {t.payment_amount ? `$${t.payment_amount.toFixed(2)}` : 'N/A'} via {t.payment_method || 'N/A'}
                              </Typography>
                            </Box>
                          </ListItem>
                          <Divider variant="inset" component="li" />
                        </motion.div>
                      ))}
                    </List>
                  )}
                </CardContent>
              </GlassCard>
            </motion.div>
          )}

          {/* Payment Methods Tab */}
          {tabValue === 3 && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
              <GlassCard>
                <CardHeader
                  title="Métodos de Pago"
                  avatar={<Payment color="primary" />}
                  subheader="Gestiona tus métodos de pago asociados"
                />
                <CardContent>
                  {methods.length > 0 && (
                    <List sx={{ mb: 3 }}>
                      {methods.map((m) => (
                        <Paper key={m.id} elevation={2} sx={{ mb: 2, borderRadius: "8px", overflow: "hidden" }}>
                          <ListItem>
                            <ListItemAvatar>
                              <Avatar sx={{ bgcolor: m.is_default ? theme.palette.success.main : theme.palette.grey[300] }}>
                                {m.is_default ? <Star /> : <CreditCard />}
                              </Avatar>
                            </ListItemAvatar>
                            <ListItemText
                              primary={
                                <Box sx={{ display: "flex", alignItems: "center" }}>
                                  <Typography sx={{ mr: 1 }}>{m.payment_type}</Typography>
                                  {m.is_default && (
                                    <Chip label="Predeterminado" size="small" color="success" variant="outlined" />
                                  )}
                                </Box>
                              }
                              secondary={m.details}
                            />
                            <Box sx={{ display: "flex", gap: 1 }}>
                              <IconButton onClick={() => setEditMethod(m)} color="primary">
                                <Edit />
                              </IconButton>
                              <IconButton onClick={() => setDeleteMethodId(m.id)} color="error">
                                <Delete />
                              </IconButton>
                              {!m.is_default && (
                                <Button
                                  onClick={() => handleSetDefault(m.id)}
                                  variant="outlined"
                                  size="small"
                                >
                                  Hacer Predeterminado
                                </Button>
                              )}
                            </Box>
                          </ListItem>
                        </Paper>
                      ))}
                    </List>
                  )}

                  {/* Formulario para añadir método */}
                  <Accordion
                    sx={{
                      background: "rgba(255, 255, 255, 0.05)",
                      boxShadow: "none",
                      border: "1px solid rgba(255, 255, 255, 0.2)",
                    }}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Typography>Añadir nuevo método de pago</Typography>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Box component="form" onSubmit={handleAddMethod} sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <TextField
                          label="Tipo"
                          select
                          value={newMethod.payment_type}
                          onChange={(e) => setNewMethod({ ...newMethod, payment_type: e.target.value })}
                          fullWidth
                          variant="outlined"
                          size="small"
                        >
                          {paymentProviders.map((provider) => (
                            <MenuItem key={provider.id} value={provider.name}>
                              {provider.name}
                            </MenuItem>
                          ))}
                        </TextField>
                        <TextField
                          label="Detalles"
                          value={newMethod.details}
                          onChange={(e) => setNewMethod({ ...newMethod, details: e.target.value })}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          multiline
                          rows={3}
                        />
                        <Button
                          type="submit"
                          variant="contained"
                          color="primary"
                          startIcon={<AddCircle />}
                          sx={{ mt: 1 }}
                        >
                          Añadir Método
                        </Button>
                      </Box>
                    </AccordionDetails>
                  </Accordion>
                </CardContent>
              </GlassCard>

              {/* Diálogo para editar método */}
              <Dialog open={!!editMethod} onClose={() => setEditMethod(null)}>
                <DialogTitle>Editar Método de Pago</DialogTitle>
                <DialogContent>
                  <Box
                    component="form"
                    onSubmit={handleEditMethod}
                    sx={{ display: "flex", flexDirection: "column", gap: 2, mt: 2 }}
                  >
                    <TextField
                      label="Tipo"
                      select
                      value={editMethod?.payment_type || ""}
                      onChange={(e) => setEditMethod({ ...editMethod!, payment_type: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                    >
                      {paymentProviders.map((provider) => (
                        <MenuItem key={provider.id} value={provider.name}>
                          {provider.name}
                        </MenuItem>
                      ))}
                    </TextField>
                    <TextField
                      label="Detalles"
                      value={editMethod?.details || ""}
                      onChange={(e) => setEditMethod({ ...editMethod!, details: e.target.value })}
                      fullWidth
                      required
                      variant="outlined"
                      size="small"
                      multiline
                      rows={3}
                    />
                    <DialogActions>
                      <Button onClick={() => setEditMethod(null)} variant="outlined">
                        Cancelar
                      </Button>
                      <Button type="submit" variant="contained" color="primary">
                        Guardar
                      </Button>
                    </DialogActions>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Diálogo para confirmar eliminación */}
              <Dialog open={!!deleteMethodId} onClose={() => setDeleteMethodId(null)}>
                <DialogTitle>¿Eliminar Método de Pago?</DialogTitle>
                <DialogContent>
                  <Typography>Esta acción es irreversible. ¿Estás seguro de eliminar este método?</Typography>
                </DialogContent>
                <DialogActions>
                  <Button onClick={() => setDeleteMethodId(null)} variant="outlined">
                    Cancelar
                  </Button>
                  <Button
                    onClick={() => handleDeleteMethod(deleteMethodId!)}
                    variant="contained"
                    color="error"
                  >
                    Eliminar
                  </Button>
                </DialogActions>
              </Dialog>
            </motion.div>
          )}

          {/* Buy Credits Tab */}
          {tabValue === 4 && (
            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} transition={{ duration: 0.3 }}>
              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader title="Comprar Créditos" avatar={<AttachMoney color="primary" />} subheader="Recarga tu saldo de créditos" />
                    <CardContent>
                      <Box component="form" onSubmit={handlePurchase} sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
                        <TextField
                          label="Cantidad de Créditos"
                          type="number"
                          value={credits}
                          onChange={(e) => setCredits(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{ startAdornment: <AttachMoney color="action" sx={{ mr: 1 }} /> }}
                        />
                        <TextField
                          label="Monto a Pagar (USD)"
                          type="number"
                          inputProps={{ step: "0.01" }}
                          value={paymentAmount}
                          onChange={(e) => setPaymentAmount(e.target.value)}
                          fullWidth
                          required
                          variant="outlined"
                          size="small"
                          InputProps={{ startAdornment: <Typography sx={{ mr: 1 }}>$</Typography> }}
                        />
                        <TextField
                          label="Método de Pago"
                          select
                          value={methods.find((m) => m.is_default)?.id || methods[0]?.id || ""}
                          onChange={(e) => {
                            const selectedMethod = methods.find((m) => m.id === parseInt(e.target.value));
                            if (selectedMethod) {
                              handleSetDefault(selectedMethod.id);
                            }
                          }}
                          fullWidth
                          variant="outlined"
                          size="small"
                          disabled={methods.length === 0}
                          helperText={methods.length === 0 ? "No hay métodos de pago disponibles" : "Selecciona un método de pago"}
                        >
                          {methods.map((method) => (
                            <MenuItem key={method.id} value={method.id}>
                              {method.payment_type} - {method.details} {method.is_default ? "(Predeterminado)" : ""}
                            </MenuItem>
                          ))}
                        </TextField>
                        <Button type="submit" variant="contained" color="primary" size="large" sx={{ mt: 2 }} disabled={methods.length === 0}>
                          Comprar Créditos
                        </Button>
                      </Box>
                    </CardContent>
                  </GlassCard>
                </Grid>

                <Grid item xs={12} md={6}>
                  <GlassCard>
                    <CardHeader title="Tarifas y Beneficios" avatar={<CreditCard color="primary" />} />
                    <CardContent>
                      <List>
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.success.light }}>
                              <Star />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="1 crédito = $1 USD" secondary="Tasa de cambio fija" />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.info.light }}>
                              <Payment />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="Múltiples métodos de pago" secondary="Tarjetas, PayPal y más" />
                        </ListItem>
                        <Divider variant="inset" component="li" />
                        <ListItem>
                          <ListItemAvatar>
                            <Avatar sx={{ bgcolor: theme.palette.warning.light }}>
                              <Security />
                            </Avatar>
                          </ListItemAvatar>
                          <ListItemText primary="Transacciones seguras" secondary="Encriptación SSL" />
                        </ListItem>
                      </List>
                    </CardContent>
                  </GlassCard>
                </Grid>
              </Grid>
            </motion.div>
          )}
        </Box>
      </Box>

      {/* Notifications */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box>
  );
}

dashboard de admin:

// src/app/admin/dashboard/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { AnimatePresence, motion } from "framer-motion";
import {
  Tabs,
  Tab,
  Card,
  CardContent,
  TextField,
  Button,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Typography,
  IconButton,
  Snackbar,
  Alert,
  Avatar,
  Chip,
  Divider,
  List,
  ListItem,
  ListItemText,
  Badge as MuiBadge,
  Paper,
  useTheme,
  styled,
  Box,
  Switch,
  FormControlLabel,
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableRow,
  Dialog,
  DialogTitle,
  DialogContent,
} from "@mui/material";
import Grid from "@mui/material/Grid";
import {
  AddCircle,
  Delete,
  ExpandMore,
  Settings,
  Public,
  Link,
  Webhook,
  CheckCircle,
  Cancel,
  Security,
  PersonAdd,
  LockPerson,
  PeopleOutline,
  AttachMoney,
  Edit,
  EmojiEvents,
  MonetizationOn
} from "@mui/icons-material";
import { SiteSetting, Integration, EventType, Badge, PaymentProvider } from "@/lib/types";

const AdminGradientCard = styled(Card)(({ theme }) => ({
  background: `linear-gradient(135deg, ${theme.palette.primary.dark} 0%, ${theme.palette.secondary.dark} 100%)`,
  color: theme.palette.primary.contrastText,
  borderRadius: '16px',
  boxShadow: theme.shadows[10],
  transition: 'transform 0.3s ease',
  '&:hover': {
    transform: 'translateY(-5px)'
  }
}));

const ConfigGlassCard = styled(Card)(({ theme }) => ({
  background: 'rgba(255, 255, 255, 0.1)',
  backdropFilter: 'blur(10px)',
  border: '1px solid rgba(255, 255, 255, 0.2)',
  borderRadius: '16px',
  boxShadow: theme.shadows[5]
}));

const FeatureCard = styled(Card)(({ theme }) => ({
  borderRadius: '16px',
  boxShadow: theme.shadows[4],
  transition: 'all 0.3s ease',
  '&:hover': {
    transform: 'translateY(-5px)',
    boxShadow: theme.shadows[8]
  }
}));

export default function ConfigurePage() {
  const { user } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [activeTab, setActiveTab] = useState(0);
  const [settingsByTag, setSettingsByTag] = useState<Record<string, SiteSetting[]>>({});
  const [origins, setOrigins] = useState<string[]>([]);
  const [integrations, setIntegrations] = useState<Integration[]>([]);
  const [newOrigin, setNewOrigin] = useState("");
  const [newIntegration, setNewIntegration] = useState({ name: "", webhook_url: "", event_type: "" });
  const [features, setFeatures] = useState({
    enable_registration: true,
    enable_social_login: true,
    disable_anonymous_users: false,
    disable_credits: false,
    enable_payment_methods: true,
    enable_points: true,
    enable_badges: true,
  });
  const [eventTypes, setEventTypes] = useState<EventType[]>([]);
  const [badges, setBadges] = useState<Badge[]>([]);
  const [paymentProviders, setPaymentProviders] = useState<PaymentProvider[]>([]);
  const [editEventType, setEditEventType] = useState<EventType | null>(null);
  const [editBadge, setEditBadge] = useState<Badge | null>(null);
  const [editPaymentProvider, setEditPaymentProvider] = useState<PaymentProvider | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [expandedSettings, setExpandedSettings] = useState<Record<string, boolean>>({});
  const [allSettingsExpanded, setAllSettingsExpanded] = useState(false);

  useEffect(() => {
    if (!user || user.rol !== "admin") {
      router.push("/");
      return;
    }

    const fetchData = async () => {
      try {
        const settingsRes = await fetchAPI<SiteSetting[]>("/v1/settings/admin/config");
        const grouped = settingsRes.data?.reduce((acc, setting) => {
          const tag = setting.tag || "General";
          if (!acc[tag]) acc[tag] = [];
          acc[tag].push(setting);
          return acc;
        }, {} as Record<string, SiteSetting[]>);
        setSettingsByTag(grouped || {});

        // Initialize expanded state for settings
        if (grouped) {
          const initialExpandedState = Object.keys(grouped).reduce((acc, tag) => {
            acc[tag] = false;
            return acc;
          }, {} as Record<string, boolean>);
          setExpandedSettings(initialExpandedState);
        }

        const originsRes = await fetchAPI<string[]>("/v1/settings/allowed_origins");
        setOrigins(originsRes.data || []);

        const integrationsRes = await fetchAPI<Integration[]>("/v1/integrations/");
        setIntegrations(integrationsRes.data || []);

        const eventTypesRes = await fetchAPI<EventType[]>("/v1/gamification/event-types");
        setEventTypes(eventTypesRes.data || []);

        const badgesRes = await fetchAPI<Badge[]>("/v1/gamification/badges");
        setBadges(badgesRes.data || []);

        const paymentProvidersRes = await fetchAPI<PaymentProvider[]>("/v1/payment-providers");
        setPaymentProviders(paymentProvidersRes.data || []);

        const featuresRes = await Promise.all([
          fetchAPI("/v1/settings/enable_registration"),
          fetchAPI("/v1/settings/enable_social_login"),
          fetchAPI("/v1/settings/disable_anonymous_users"),
          fetchAPI("/v1/settings/disable_credits"),
          fetchAPI("/v1/settings/enable_payment_methods"),
          fetchAPI("/v1/settings/enable_points"),
          fetchAPI("/v1/settings/enable_badges"),
        ]);
        setFeatures({
          enable_registration: featuresRes[0].data === "true",
          enable_social_login: featuresRes[1].data === "true",
          disable_anonymous_users: featuresRes[2].data === "true",
          disable_credits: featuresRes[3].data === "true",
          enable_payment_methods: featuresRes[4].data === "true",
          enable_points: featuresRes[5].data === "true",
          enable_badges: featuresRes[6].data === "true",
        });
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar datos");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [user, router]);

  const groupedBadges = badges.reduce((acc, badge) => {
    const key = badge.event_type_id;
    if (!acc[key]) acc[key] = [];
    acc[key].push(badge);
    return acc;
  }, {} as Record<number, Badge[]>);

  const toggleAllSettings = () => {
    const newState = !allSettingsExpanded;
    setAllSettingsExpanded(newState);
    const updatedExpandedSettings = Object.keys(expandedSettings).reduce((acc, tag) => {
      acc[tag] = newState;
      return acc;
    }, {} as Record<string, boolean>);
    setExpandedSettings(updatedExpandedSettings);
  };

  const handleSaveSetting = async (key: string, newValue: string) => {
    try {
      await fetchAPI("/v1/settings/admin/config", { method: "POST", data: { key, value: newValue } });
      setSettingsByTag((prev) => {
        const updated = { ...prev };
        for (const tag in updated) {
          updated[tag] = updated[tag].map((s) => (s.key === key ? { ...s, value: newValue } : s));
        }
        return updated;
      });
      setSuccess("Configuración actualizada");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al guardar configuración");
    }
  };

  const handleAddOrigin = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await fetchAPI("/v1/settings/allowed-origins", { method: "POST", data: { origin: newOrigin } });
      setOrigins([...origins, newOrigin]);
      setNewOrigin("");
      setSuccess("Origen añadido con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al añadir origen");
    }
  };

  const handleAddIntegration = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Integration>("/v1/integrations/", {
        method: "POST",
        data: { name: newIntegration.name, webhook_url: newIntegration.webhook_url, event_type: newIntegration.event_type },
      });
      setIntegrations([...integrations, data!]);
      setNewIntegration({ name: "", webhook_url: "", event_type: "" });
      setSuccess("Integración creada con éxito");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear integración");
    }
  };

  const handleToggleFeature = async (feature: string, enabled: boolean) => {
    try {
      await fetchAPI("/v1/settings/admin/config", { method: "POST", data: { key: feature, value: enabled.toString() } });
      setFeatures((prev) => ({ ...prev, [feature]: enabled }));
      setSuccess(`Funcionalidad ${enabled ? "activada" : "desactivada"} con éxito`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar funcionalidad");
    }
  };

  const handleCreateEventType = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<EventType>("/v1/gamification/event-types", { method: "POST", data: editEventType });
      setEventTypes([...eventTypes, data!]);
      setEditEventType(null);
      setSuccess("Tipo de evento creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear tipo de evento");
    }
  };

  const handleUpdateEventType = async (e: React.FormEvent) => {
    if (!editEventType?.id) return;
    try {
      const { data } = await fetchAPI<EventType>(`/v1/gamification/event-types/${editEventType.id}`, { method: "PUT", data: editEventType });
      setEventTypes(eventTypes.map((et) => (et.id === data!.id ? data! : et)));
      setEditEventType(null);
      setSuccess("Tipo de evento actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar tipo de evento");
    }
  };

  const handleDeleteEventType = async (id: number) => {
    try {
      await fetchAPI(`/v1/gamification/event-types/${id}`, { method: "DELETE" });
      setEventTypes(eventTypes.filter((et) => et.id !== id));
      setSuccess("Tipo de evento eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar tipo de evento");
    }
  };

  const handleCreateBadge = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<Badge>("/v1/gamification/badges", { method: "POST", data: editBadge });
      setBadges([...badges, data!]);
      setEditBadge(null);
      setSuccess("Badge creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear badge");
    }
  };

  const handleUpdateBadge = async (e: React.FormEvent) => {
    if (!editBadge?.id) return;
    try {
      const { data } = await fetchAPI<Badge>(`/v1/gamification/badges/${editBadge.id}`, { method: "PUT", data: editBadge });
      setBadges(badges.map((b) => (b.id === data!.id ? data! : b)));
      setEditBadge(null);
      setSuccess("Badge actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar badge");
    }
  };

  const handleDeleteBadge = async (id: number) => {
    try {
      await fetchAPI(`/v1/gamification/badges/${id}`, { method: "DELETE" });
      setBadges(badges.filter((b) => b.id !== id));
      setSuccess("Badge eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar badge");
    }
  };

  const handleTogglePaymentProvider = async (id: number, active: boolean) => {
    try {
      const { data } = await fetchAPI<PaymentProvider>(`/v1/payment-providers/${id}`, {
        method: "PUT",
        data: { active },
      });
      setPaymentProviders(paymentProviders.map((p) => (p.id === id ? data! : p)));
      setSuccess(`Proveedor ${active ? "activado" : "desactivado"}`);
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar proveedor");
    }
  };

  const handleCreatePaymentProvider = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const { data } = await fetchAPI<PaymentProvider>("/v1/payment-providers", { method: "POST", data: editPaymentProvider });
      setPaymentProviders([...paymentProviders, data!]);
      setEditPaymentProvider(null);
      setSuccess("Proveedor creado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al crear proveedor");
    }
  };

  const handleUpdatePaymentProvider = async (e: React.FormEvent) => {
    if (!editPaymentProvider?.id) return;
    try {
      const { data } = await fetchAPI<PaymentProvider>(`/v1/payment-providers/${editPaymentProvider.id}`, {
        method: "PUT",
        data: editPaymentProvider,
      });
      setPaymentProviders(paymentProviders.map((p) => (p.id === data!.id ? data! : p)));
      setEditPaymentProvider(null);
      setSuccess("Proveedor actualizado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al actualizar proveedor");
    }
  };

  const handleDeletePaymentProvider = async (id: number) => {
    try {
      await fetchAPI(`/v1/payment-providers/${id}`, { method: "DELETE" });
      setPaymentProviders(paymentProviders.filter((p) => p.id !== id));
      setSuccess("Proveedor eliminado");
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Error al eliminar proveedor");
    }
  };

  if (loading) return (
    <Box sx={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <motion.div
        initial={{ scale: 0.8, opacity: 0 }}
        animate={{ scale: 1, opacity: 1 }}
        transition={{ duration: 0.5 }}
      >
        <Typography variant="h6" color="textSecondary">Cargando panel de administración...</Typography>
      </motion.div>
    </Box>
  );


  return (
    <Box sx={{
      p: { xs: 2, md: 4 },
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)'
    }}>
      <Box sx={{ maxWidth: '1400px', mx: 'auto' }}>
        {/* Header Section */}
        <Box sx={{
          display: 'flex',
          flexDirection: { xs: 'column', md: 'row' },
          justifyContent: 'space-between',
          alignItems: 'center',
          mb: 4,
          gap: 2
        }}>
          <motion.div
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
          >
            <Typography
              variant="h3"
              sx={{
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent',
                display: 'inline-block'
              }}
            >
              Panel de Administración
            </Typography>
            <Typography variant="subtitle1" color="textSecondary">
              Gestiona la configuración del sistema
            </Typography>
          </motion.div>

          <MuiBadge
            overlap="circular"
            badgeContent={
              <Chip
                label="Admin"
                size="small"
                color="primary"
                sx={{
                  position: 'absolute',
                  top: -10,
                  right: -10,
                  fontWeight: 'bold'
                }}
              />
            }
          >
            <Avatar
              sx={{
                width: 80,
                height: 80,
                bgcolor: theme.palette.error.main,
                fontSize: '2rem',
                boxShadow: theme.shadows[6]
              }}
            >
              {user?.username?.charAt(0).toUpperCase()}
            </Avatar>
          </MuiBadge>
        </Box>

        {/* Stats Cards */}
        <Box sx={{ display: 'flex', gap: 3, mb: 4, flexWrap: 'wrap' }}>
          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Configuraciones
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {Object.values(settingsByTag).flat().length}
                  </Typography>
                </Box>
                <Settings sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Orígenes Permitidos
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {origins.length}
                  </Typography>
                </Box>
                <Public sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Integraciones
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {integrations.length}
                  </Typography>
                </Box>
                <Webhook sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Gamificación
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {eventTypes.length}
                  </Typography>
                </Box>
                <EmojiEvents sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>

          <AdminGradientCard sx={{ flex: 1, minWidth: '200px' }}>
            <CardContent>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                <Box>
                  <Typography variant="overline" color="inherit" sx={{ opacity: 0.8 }}>
                    Pagos
                  </Typography>
                  <Typography variant="h4" sx={{ fontWeight: 'bold' }}>
                    {paymentProviders.length}
                  </Typography>
                </Box>
                <MonetizationOn sx={{ fontSize: 40, opacity: 0.8 }} />
              </Box>
            </CardContent>
          </AdminGradientCard>
        </Box>

        {/* Tabs Navigation */}
        <Paper sx={{ mb: 3, borderRadius: '12px', overflow: 'hidden' }}>
          <Tabs
            value={activeTab}
            onChange={(_, newValue) => setActiveTab(newValue)}
            variant="scrollable"
            scrollButtons="auto"
            indicatorColor="primary"
            textColor="primary"
          >
            <Tab label="Funcionalidades" icon={<LockPerson />} iconPosition="start" />
            <Tab label="Orígenes" icon={<Security />} iconPosition="start" />
            <Tab label="Integraciones" icon={<Link />} iconPosition="start" />
            <Tab label="Gamificación" icon={<EmojiEvents />} iconPosition="start" />
            <Tab label="Pagos" icon={<MonetizationOn />} iconPosition="start" />
            <Tab label="Configuraciones" icon={<Settings />} iconPosition="start" />
          </Tabs>
        </Paper>

        {/* Tab Content */}
        <motion.div
          key={activeTab}
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.3 }}
        >
          {/* Funcionalidades Tab */}
          {activeTab === 0 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <LockPerson sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Control de Funcionalidades del Sistema
                  </Typography>

                  <Grid container spacing={3}>
                    {/* Tarjeta para Registro */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_registration ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PersonAdd sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_registration ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Registro de Usuarios</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Controla si los nuevos usuarios pueden registrarse
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_registration ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_registration ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_registration}
                              onChange={(e) => handleToggleFeature('enable_registration', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_registration')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Login Social */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_social_login ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <PeopleOutline sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_social_login ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Login Social</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Permite inicio de sesión con redes sociales
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_social_login ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_social_login ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_social_login}
                              onChange={(e) => handleToggleFeature('enable_social_login', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_social_login')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Usuarios Anónimos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.disable_anonymous_users ? theme.palette.error.main : theme.palette.success.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <Security sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.disable_anonymous_users ? theme.palette.error.main : theme.palette.success.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Usuarios Anónimos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Controla el acceso de usuarios no registrados
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.disable_anonymous_users ? "Bloqueados" : "Permitidos"}
                                size="small"
                                color={features.disable_anonymous_users ? "error" : "success"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.disable_anonymous_users}
                              onChange={(e) => handleToggleFeature('disable_anonymous_users', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('disable_anonymous_users')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Sistema de Créditos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.disable_credits ? theme.palette.error.main : theme.palette.success.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <AttachMoney sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.disable_credits ? theme.palette.error.main : theme.palette.success.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Créditos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita/deshabilita el uso de créditos
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.disable_credits ? "Desactivado" : "Activado"}
                                size="small"
                                color={features.disable_credits ? "error" : "success"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={!features.disable_credits}
                              onChange={(e) => handleToggleFeature('disable_credits', !e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('disable_credits')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Métodos de Pago */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_payment_methods ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <MonetizationOn sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_payment_methods ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Métodos de Pago</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Habilita diferentes opciones de pago
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_payment_methods ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_payment_methods ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_payment_methods}
                              onChange={(e) => handleToggleFeature('enable_payment_methods', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_payment_methods')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Sistema de Puntos */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_points ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_points ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Puntos</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Activa puntos por actividades
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_points ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_points ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_points}
                              onChange={(e) => handleToggleFeature('enable_points', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_points')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>

                    {/* Tarjeta para Insignias */}
                    <Grid item xs={12} md={6} lg={4}>
                      <FeatureCard sx={{
                        borderLeft: `4px solid ${features.enable_badges ? theme.palette.success.main : theme.palette.error.main}`
                      }}>
                        <CardContent>
                          <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                            <EmojiEvents sx={{
                              fontSize: 40,
                              mr: 2,
                              color: features.enable_badges ? theme.palette.success.main : theme.palette.error.main
                            }} />
                            <Box>
                              <Typography variant="h6" sx={{ fontWeight: 'bold' }}>Sistema de Insignias</Typography>
                              <Typography variant="body2" color="textSecondary">
                                Permite la obtención de insignias
                              </Typography>
                            </Box>
                          </Box>
                          <Divider sx={{ my: 2 }} />
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Typography variant="body2" component="span">
                                Estado actual:
                              </Typography>
                              <Chip
                                label={features.enable_badges ? "Activado" : "Desactivado"}
                                size="small"
                                color={features.enable_badges ? "success" : "error"}
                                sx={{ ml: 1 }}
                              />
                            </Box>
                            <Switch
                              checked={features.enable_badges}
                              onChange={(e) => handleToggleFeature('enable_badges', e.target.checked)}
                              color="primary"
                            />
                          </Box>
                          <Typography variant="caption" color="textSecondary" sx={{ mt: 1, display: 'block' }}>
                            {getFeatureDescription('enable_badges')}
                          </Typography>
                        </CardContent>
                      </FeatureCard>
                    </Grid>
                  </Grid>
                </CardContent>
              </ConfigGlassCard>
            </Box>
          )}

          {/* Orígenes Permitidos Tab */}
          {activeTab === 1 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Box component="form" onSubmit={handleAddOrigin} sx={{ display: 'flex', gap: 2 }}>
                    <TextField
                      label="Nuevo Origen Permitido"
                      value={newOrigin}
                      onChange={(e) => setNewOrigin(e.target.value)}
                      fullWidth
                      variant="outlined"
                      size="small"
                      placeholder="https://example.com"
                      InputProps={{ startAdornment: <Public color="action" sx={{ mr: 1 }} /> }}
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      startIcon={<AddCircle />}
                      sx={{ minWidth: '120px' }}
                    >
                      Añadir
                    </Button>
                  </Box>
                </CardContent>
              </ConfigGlassCard>

              {origins.length > 0 ? (
                <Grid container spacing={2}>
                  {origins.map((origin, index) => (
                    <Grid item xs={12} sm={6} md={4} key={index}>
                      <ConfigGlassCard>
                        <CardContent sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <Public color="primary" />
                            <Typography noWrap sx={{ maxWidth: '200px' }}>{origin}</Typography>
                          </Box>
                          <IconButton color="error"><Delete /></IconButton>
                        </CardContent>
                      </ConfigGlassCard>
                    </Grid>
                  ))}
                </Grid>
              ) : (
                <ConfigGlassCard>
                  <CardContent sx={{ textAlign: 'center', py: 4 }}>
                    <Public sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
                    <Typography variant="h6" color="textSecondary">
                      No hay orígenes permitidos
                    </Typography>
                  </CardContent>
                </ConfigGlassCard>
              )}
            </Box>
          )}

          {/* Integraciones Tab */}
          {activeTab === 2 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Box component="form" onSubmit={handleAddIntegration} sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
                    <TextField
                      label="Nombre de la Integración"
                      value={newIntegration.name}
                      onChange={(e) => setNewIntegration({ ...newIntegration, name: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                      InputProps={{ startAdornment: <Link color="action" sx={{ mr: 1 }} /> }}
                    />
                    <TextField
                      label="Webhook URL"
                      value={newIntegration.webhook_url}
                      onChange={(e) => setNewIntegration({ ...newIntegration, webhook_url: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                      InputProps={{ startAdornment: <Webhook color="action" sx={{ mr: 1 }} /> }}
                    />
                    <TextField
                      label="Tipo de Evento"
                      value={newIntegration.event_type}
                      onChange={(e) => setNewIntegration({ ...newIntegration, event_type: e.target.value })}
                      fullWidth
                      variant="outlined"
                      size="small"
                      InputProps={{ startAdornment: <Settings color="action" sx={{ mr: 1 }} /> }}
                    />
                    <Button type="submit" variant="contained" color="primary" startIcon={<AddCircle />} sx={{ mt: 1 }}>
                      Crear Integración
                    </Button>
                  </Box>
                </CardContent>
              </ConfigGlassCard>

              {integrations.length > 0 ? (
                <Grid container spacing={2}>
                  {integrations.map((integration) => (
                    <Grid item xs={12} md={6} key={integration.id}>
                      <ConfigGlassCard>
                        <CardContent>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}>
                            <Typography variant="h6" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <Webhook color="primary" />
                              {integration.name}
                            </Typography>
                            <Chip
                              label={integration.active ? "Activo" : "Inactivo"}
                              color={integration.active ? "success" : "error"}
                              size="small"
                              icon={integration.active ? <CheckCircle /> : <Cancel />}
                            />
                          </Box>
                          <Typography variant="body2" color="textSecondary" sx={{ mb: 1 }}>
                            <strong>Webhook:</strong> {integration.webhook_url}
                          </Typography>
                          <Typography variant="body2" color="textSecondary">
                            <strong>Evento:</strong> {integration.event_type}
                          </Typography>
                        </CardContent>
                      </ConfigGlassCard>
                    </Grid>
                  ))}
                </Grid>
              ) : (
                <ConfigGlassCard>
                  <CardContent sx={{ textAlign: 'center', py: 4 }}>
                    <Webhook sx={{ fontSize: 48, color: 'text.secondary', mb: 1 }} />
                    <Typography variant="h6" color="textSecondary">
                      No hay integraciones configuradas
                    </Typography>
                  </CardContent>
                </ConfigGlassCard>
              )}
            </Box>
          )}

          {/* Gamificación Tab */}
          {activeTab === 3 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard sx={{ mb: 3 }}>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <EmojiEvents sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Gamificación
                  </Typography>

                  {/* Event Types Section */}
                  <ConfigGlassCard sx={{ mb: 4, p: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6">Tipos de Evento</Typography>
                      <Button
                        variant="contained"
                        startIcon={<AddCircle />}
                        onClick={() => setEditEventType({ id: 0, name: '', description: '', points_per_event: 0 })}
                      >
                        Nuevo Tipo
                      </Button>
                    </Box>

                    <Table>
                      <TableHead>
                        <TableRow>
                          <TableCell>Nombre</TableCell>
                          <TableCell>Descripción</TableCell>
                          <TableCell>Puntos</TableCell>
                          <TableCell>Acciones</TableCell>
                        </TableRow>
                      </TableHead>
                      <TableBody>
                        {eventTypes.map((et) => (
                          <TableRow key={et.id}>
                            <TableCell>{et.name}</TableCell>
                            <TableCell>{et.description}</TableCell>
                            <TableCell>{et.points_per_event}</TableCell>
                            <TableCell>
                              <IconButton onClick={() => setEditEventType(et)} color="primary">
                                <Edit />
                              </IconButton>
                              <IconButton onClick={() => handleDeleteEventType(et.id)} color="error">
                                <Delete />
                              </IconButton>
                            </TableCell>
                          </TableRow>
                        ))}
                      </TableBody>
                    </Table>
                  </ConfigGlassCard>

                  {/* Badges Section */}
                  <ConfigGlassCard sx={{ p: 3 }}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                      <Typography variant="h6">Insignias</Typography>
                      <Button
                        variant="contained"
                        startIcon={<AddCircle />}
                        onClick={() => setEditBadge({
                          id: 0,
                          name: '',
                          description: '',
                          event_type_id: eventTypes[0]?.id || 0,
                          required_points: 0,
                          user_type: 'both'
                        })}
                        disabled={eventTypes.length === 0}
                      >
                        Nueva Insignia
                      </Button>
                    </Box>

                    {eventTypes.map((eventType) => (
                      <Accordion key={eventType.id} sx={{ background: 'transparent', boxShadow: 'none' }}>
                        <AccordionSummary expandIcon={<ExpandMore />}>
                          <Typography>{eventType.name} (ID: {eventType.id})</Typography>
                        </AccordionSummary>
                        <AccordionDetails>
                          <Table>
                            <TableHead>
                              <TableRow>
                                <TableCell>Nombre</TableCell>
                                <TableCell>Puntos Requeridos</TableCell>
                                <TableCell>Tipo Usuario</TableCell>
                                <TableCell>Acciones</TableCell>
                              </TableRow>
                            </TableHead>
                            <TableBody>
                              {(groupedBadges[eventType.id] || []).map((badge) => (
                                <TableRow key={badge.id}>
                                  <TableCell>{badge.name}</TableCell>
                                  <TableCell>{badge.required_points}</TableCell>
                                  <TableCell>{badge.user_type}</TableCell>
                                  <TableCell>
                                    <IconButton onClick={() => setEditBadge(badge)} color="primary">
                                      <Edit />
                                    </IconButton>
                                    <IconButton onClick={() => handleDeleteBadge(badge.id)} color="error">
                                      <Delete />
                                    </IconButton>
                                  </TableCell>
                                </TableRow>
                              ))}
                            </TableBody>
                          </Table>
                        </AccordionDetails>
                      </Accordion>
                    ))}
                  </ConfigGlassCard>
                </CardContent>
              </ConfigGlassCard>

              {/* Event Type Dialog */}
              <Dialog open={!!editEventType} onClose={() => setEditEventType(null)}>
                <DialogTitle>{editEventType?.id ? 'Editar Tipo de Evento' : 'Nuevo Tipo de Evento'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editEventType?.id ? handleUpdateEventType : handleCreateEventType} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editEventType?.name || ''}
                      onChange={(e) => setEditEventType({ ...editEventType!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editEventType?.description || ''}
                      onChange={(e) => setEditEventType({ ...editEventType!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Puntos por evento"
                      type="number"
                      fullWidth
                      value={editEventType?.points_per_event || 0}
                      onChange={(e) => setEditEventType({ ...editEventType!, points_per_event: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editEventType?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>

              {/* Badge Dialog */}
              <Dialog open={!!editBadge} onClose={() => setEditBadge(null)}>
                <DialogTitle>{editBadge?.id ? 'Editar Insignia' : 'Nueva Insignia'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editBadge?.id ? handleUpdateBadge : handleCreateBadge} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editBadge?.name || ''}
                      onChange={(e) => setEditBadge({ ...editBadge!, name: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Descripción"
                      fullWidth
                      value={editBadge?.description || ''}
                      onChange={(e) => setEditBadge({ ...editBadge!, description: e.target.value })}
                      margin="normal"
                    />
                    <TextField
                      label="Puntos Requeridos"
                      type="number"
                      fullWidth
                      value={editBadge?.required_points || 0}
                      onChange={(e) => setEditBadge({ ...editBadge!, required_points: parseInt(e.target.value) || 0 })}
                      margin="normal"
                    />
                    <TextField
                      label="Tipo de Evento"
                      select
                      fullWidth
                      value={editBadge?.event_type_id || 0}
                      onChange={(e) => setEditBadge({ ...editBadge!, event_type_id: parseInt(e.target.value) })}
                      margin="normal"
                      SelectProps={{ native: true }}
                    >
                      {eventTypes.map((et) => (
                        <option key={et.id} value={et.id}>{et.name}</option>
                      ))}
                    </TextField>
                    <TextField
                      label="Tipo de Usuario"
                      select
                      fullWidth
                      value={editBadge?.user_type || 'both'}
                      onChange={(e) => setEditBadge({ ...editBadge!, user_type: e.target.value as any })}
                      margin="normal"
                      SelectProps={{ native: true }}
                    >
                      <option value="anonymous">Anónimo</option>
                      <option value="registered">Registrado</option>
                      <option value="both">Ambos</option>
                    </TextField>
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editBadge?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* Pagos Tab */}
          {activeTab === 4 && (
            <Box sx={{ mb: 4 }}>
              <ConfigGlassCard>
                <CardContent>
                  <Typography variant="h5" sx={{ fontWeight: 'bold', mb: 3 }}>
                    <MonetizationOn sx={{ mr: 1, verticalAlign: 'middle' }} />
                    Gestión de Pagos
                  </Typography>

                  <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                    <Button
                      variant="contained"
                      startIcon={<AddCircle />}
                      onClick={() => setEditPaymentProvider({ id: 0, name: '', active: true })}
                    >
                      Nuevo Proveedor
                    </Button>
                  </Box>

                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>Nombre</TableCell>
                        <TableCell>Estado</TableCell>
                        <TableCell>Acciones</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {paymentProviders.map((provider) => (
                        <TableRow key={provider.id}>
                          <TableCell>{provider.name}</TableCell>
                          <TableCell>
                            <Switch
                              checked={provider.active}
                              onChange={(e) => handleTogglePaymentProvider(provider.id, e.target.checked)}
                              color="primary"
                            />
                          </TableCell>
                          <TableCell>
                            <IconButton onClick={() => setEditPaymentProvider(provider)} color="primary">
                              <Edit />
                            </IconButton>
                            <IconButton onClick={() => handleDeletePaymentProvider(provider.id)} color="error">
                              <Delete />
                            </IconButton>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </CardContent>
              </ConfigGlassCard>

              {/* Payment Provider Dialog */}
              <Dialog open={!!editPaymentProvider} onClose={() => setEditPaymentProvider(null)}>
                <DialogTitle>{editPaymentProvider?.id ? 'Editar Proveedor' : 'Nuevo Proveedor'}</DialogTitle>
                <DialogContent>
                  <Box component="form" onSubmit={editPaymentProvider?.id ? handleUpdatePaymentProvider : handleCreatePaymentProvider} sx={{ mt: 2 }}>
                    <TextField
                      label="Nombre"
                      fullWidth
                      value={editPaymentProvider?.name || ''}
                      onChange={(e) => setEditPaymentProvider({ ...editPaymentProvider!, name: e.target.value })}
                      margin="normal"
                    />
                    <FormControlLabel
                      control={
                        <Switch
                          checked={editPaymentProvider?.active || false}
                          onChange={(e) => setEditPaymentProvider({ ...editPaymentProvider!, active: e.target.checked })}
                          color="primary"
                        />
                      }
                      label="Activo"
                      sx={{ mt: 2 }}
                    />
                    <Button
                      type="submit"
                      variant="contained"
                      color="primary"
                      fullWidth
                      sx={{ mt: 2 }}
                    >
                      {editPaymentProvider?.id ? 'Actualizar' : 'Crear'}
                    </Button>
                  </Box>
                </DialogContent>
              </Dialog>
            </Box>
          )}

          {/* Configuraciones Tab */}
          {activeTab === 5 && (
            <Box sx={{ mb: 4 }}>
              <Box sx={{ display: 'flex', justifyContent: 'flex-end', mb: 2 }}>
                <Button
                  variant="outlined"
                  onClick={toggleAllSettings}
                  startIcon={<ExpandMore />}
                  sx={{ borderRadius: '12px' }}
                >
                  {allSettingsExpanded ? 'Contraer Todo' : 'Expandir Todo'}
                </Button>
              </Box>

              {Object.entries(settingsByTag).map(([tag, settings]) => (
                <ConfigGlassCard key={tag} sx={{ mb: 2 }}>
                  <Accordion
                    sx={{ background: 'transparent', boxShadow: 'none' }}
                    expanded={expandedSettings[tag] || false}
                    onChange={() => setExpandedSettings(prev => ({ ...prev, [tag]: !prev[tag] }))}
                  >
                    <AccordionSummary expandIcon={<ExpandMore />}>
                      <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                        <Avatar sx={{ bgcolor: theme.palette.primary.main, width: 32, height: 32 }}>
                          <Settings sx={{ fontSize: 16 }} />
                        </Avatar>
                        <Typography variant="h6">{tag}</Typography>
                        <Chip label={`${settings.length} configs`} size="small" color="primary" variant="outlined" />
                      </Box>
                    </AccordionSummary>
                    <AccordionDetails>
                      <Grid container spacing={2}>
                        {settings.map((setting) => (
                          <Grid item xs={12} md={6} key={setting.key}>
                            <TextField
                              label={setting.key}
                              defaultValue={setting.value}
                              onBlur={(e) => handleSaveSetting(setting.key, e.target.value)}
                              fullWidth
                              variant="outlined"
                              size="small"
                              helperText={setting.description}
                              InputProps={{ sx: { borderRadius: '12px' } }}
                            />
                          </Grid>
                        ))}
                      </Grid>
                    </AccordionDetails>
                  </Accordion>
                </ConfigGlassCard>
              ))}
            </Box>
          )}
        </motion.div>
      </Box>

      {/* Notificaciones */}
      <AnimatePresence>
        {error && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setError(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="error"
                onClose={() => setError(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {error}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
        {success && (
          <Snackbar
            open
            autoHideDuration={3000}
            onClose={() => setSuccess(null)}
            anchorOrigin={{ vertical: 'bottom', horizontal: 'right' }}
          >
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 20 }}
            >
              <Alert
                severity="success"
                onClose={() => setSuccess(null)}
                sx={{ boxShadow: theme.shadows[6], borderRadius: '12px' }}
              >
                {success}
              </Alert>
            </motion.div>
          </Snackbar>
        )}
      </AnimatePresence>
    </Box>
  );
}

// Función auxiliar para descripciones de características
const getFeatureDescription = (key: string) => {
  const descriptions: Record<string, string> = {
    enable_registration: 'Permite a nuevos usuarios registrarse en la plataforma. Si se desactiva, solo los administradores podrán crear cuentas.',
    enable_social_login: 'Permite el inicio de sesión con proveedores sociales como Google, Facebook, etc. Requiere configuración previa de las APIs.',
    disable_anonymous_users: 'Impide el acceso a usuarios no registrados. Todos los visitantes deberán iniciar sesión para usar la plataforma.',
    disable_credits: 'Deshabilita el sistema de créditos en la plataforma. Los usuarios no podrán comprar ni gastar créditos.',
    enable_payment_methods: 'Habilita diferentes métodos de pago como tarjetas, PayPal, etc. Requiere configuración previa de cada proveedor.',
    enable_points: 'Activa el sistema de puntos por actividades. Los usuarios ganarán puntos por completar acciones en la plataforma.',
    enable_badges: 'Permite la obtención de insignias al alcanzar ciertos logros. Configura los requisitos en la pestaña de Gamificación.'
  };
  return descriptions[key] || 'Funcionalidad del sistema';
};

te paso la pagina de transacciones como referencia para la futura pagina de cupones:

// frontend/src/app/user/transactions/page.tsx
// frontend/src/app/user/transactions/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/lib/auth/context";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { motion, AnimatePresence } from "framer-motion";
import {
  Box,
  Typography,
  Avatar,
  Chip,
  Divider,
  useTheme,
  styled,
  Tabs,
  Tab
} from "@mui/material";
import {
  History,
  ArrowUpward,
  ArrowDownward,
  Paid,
  CreditCard,
  AccountBalance
} from "@mui/icons-material";

interface CreditTransaction {
  id: number;
  amount: number;
  transaction_type: string;
  payment_amount?: number;
  payment_method?: string;
  payment_status: string;
  timestamp: string;
}

const TransactionCard = styled(Box)(({ theme }) => ({
  background: 'rgba(255, 255, 255, 0.12)',
  backdropFilter: 'blur(16px)',
  borderRadius: '24px',
  padding: theme.spacing(3),
  boxShadow: '0 8px 32px 0 rgba(31, 38, 135, 0.37)',
  border: '1px solid rgba(255, 255, 255, 0.18)',
  transition: 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
  '&:hover': {
    transform: 'translateY(-8px)',
    boxShadow: '0 12px 40px 0 rgba(31, 38, 135, 0.5)',
    background: 'rgba(255, 255, 255, 0.18)'
  }
}));

const StyledTabs = styled(Tabs)(({ theme }) => ({
  '& .MuiTabs-indicator': {
    backgroundColor: theme.palette.secondary.light,
    height: 4,
    borderRadius: '2px'
  },
  '& .MuiTab-root': {
    color: theme.palette.common.white,
    opacity: 0.7,
    fontSize: '0.875rem',
    fontWeight: 500,
    textTransform: 'capitalize',
    padding: '12px 16px',
    minHeight: 'auto',
    '&.Mui-selected': {
      color: theme.palette.common.white,
      opacity: 1,
      fontWeight: 600
    },
    '&:hover': {
      opacity: 1
    }
  }
}));

const StatusChip = styled(Chip)(({ theme }) => ({
  borderRadius: '8px',
  fontWeight: 600,
  fontSize: '0.75rem',
  padding: '2px 8px',
  height: 'auto'
}));

export default function TransactionsPage() {
  const { user } = useAuth();
  const router = useRouter();
  const theme = useTheme();
  const [transactions, setTransactions] = useState<CreditTransaction[]>([]);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<string>('all');
  const [enableCredits, setEnableCredits] = useState<boolean | null>(null);

  useEffect(() => {
    const checkSettingsAndFetchTransactions = async () => {
      try {
        const { data: settingsData } = await fetchAPI("/v1/settings/disable_credits");
        const isEnabled = settingsData !== "true" && settingsData !== true;
        setEnableCredits(isEnabled);

        if (!isEnabled) {
          return;
        }

        const { data } = await fetchAPI<CreditTransaction[]>("/v1/payments/transactions");
        setTransactions(data || []);
      } catch (err) {
        setError(err instanceof Error ? err.message : "Error al cargar transacciones");
      }
    };
    checkSettingsAndFetchTransactions();
  }, [router]);

  const filtered = transactions.filter(t => {
    if (activeTab === 'all') return true;
    if (activeTab === 'in') return t.amount > 0;
    if (activeTab === 'out') return t.amount < 0;
    return true;
  });

  const getPaymentMethodIcon = (method?: string) => {
    switch (method?.toLowerCase()) {
      case 'card':
        return <CreditCard fontSize="small" />;
      case 'bank':
        return <AccountBalance fontSize="small" />;
      default:
        return <Paid fontSize="small" />;
    }
  };

  if (enableCredits === null) return null;

  if (!enableCredits) {
    return (
      <Box sx={{
        minHeight: "100vh",
        background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        p: 4
      }}>
        <Typography variant="h6" color="textSecondary">
          Esta funcionalidad no está habilitada en este momento.
        </Typography>
      </Box>
    );
  }

  return (
    <Box sx={{
      minHeight: "100vh",
      background: 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)',
      p: { xs: 2, md: 4 },
      color: 'white'
    }}>
      <Box sx={{ 
        maxWidth: "1200px", 
        mx: "auto",
        position: 'relative'
      }}>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
        >
          <Typography
            variant="h3"
            sx={{
              mb: 4,
              fontWeight: "bold",
              background: `linear-gradient(45deg, ${theme.palette.primary.light} 30%, ${theme.palette.secondary.light} 90%)`,
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              display: 'inline-block',
              letterSpacing: '-0.5px'
            }}
          >
            Historial de Transacciones
          </Typography>
        </motion.div>

        <StyledTabs
          value={activeTab}
          onChange={(e, newValue) => setActiveTab(newValue)}
          textColor="secondary"
          indicatorColor="secondary"
          variant="scrollable"
          scrollButtons="auto"
          sx={{ 
            mb: 4,
            background: 'rgba(0, 0, 0, 0.2)',
            borderRadius: '12px',
            padding: '4px',
            maxWidth: 'fit-content'
          }}
        >
          <Tab label="Todas" value="all" />
          <Tab label="Entradas" value="in" icon={<ArrowDownward fontSize="small" />} iconPosition="start" />
          <Tab label="Salidas" value="out" icon={<ArrowUpward fontSize="small" />} iconPosition="start" />
        </StyledTabs>

        {filtered.length === 0 ? (
          <Box sx={{
            textAlign: 'center',
            py: 6,
            background: 'rgba(255, 255, 255, 0.08)',
            borderRadius: '24px',
            backdropFilter: 'blur(12px)',
            border: '1px solid rgba(255, 255, 255, 0.1)'
          }}>
            <History sx={{ 
              fontSize: 48, 
              color: 'text.secondary', 
              mb: 2,
              opacity: 0.5
            }} />
            <Typography variant="h6" color="text.secondary">
              No hay transacciones registradas
            </Typography>
            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
              {user ? 'Todas tus transacciones aparecerán aquí' : 'Las transacciones de créditos aparecerán aquí'}
            </Typography>
          </Box>
        ) : (
          <AnimatePresence>
            <Box
              sx={{
                display: 'grid',
                gridTemplateColumns: { xs: '1fr', sm: 'repeat(2, 1fr)', lg: 'repeat(3, 1fr)' },
                gap: 3
              }}
            >
              {filtered.map((t) => (
                <motion.div
                  key={t.id}
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  whileHover={{ scale: 1.02 }}
                >
                  <TransactionCard>
                    <Box sx={{ 
                      display: 'flex', 
                      alignItems: 'center', 
                      gap: 2, 
                      mb: 2 
                    }}>
                      <Avatar
                        sx={{
                          bgcolor: t.amount > 0 ? 'success.dark' : 'error.dark',
                          color: 'white',
                          width: 48,
                          height: 48
                        }}
                      >
                        {t.amount > 0 ? <ArrowDownward /> : <ArrowUpward />}
                      </Avatar>
                      <Box sx={{ overflow: 'hidden' }}>
                        <Typography 
                          variant="h6" 
                          fontWeight="bold"
                          noWrap
                        >
                          {t.transaction_type}
                        </Typography>
                        <Box sx={{ 
                          display: 'flex', 
                          alignItems: 'center', 
                          gap: 1,
                          mt: 0.5
                        }}>
                          <Typography 
                            variant="body2" 
                            color="text.secondary"
                            fontSize="0.75rem"
                          >
                            {new Date(t.timestamp).toLocaleString()}
                          </Typography>
                          <StatusChip 
                            label={t.payment_status} 
                            size="small"
                            color={
                              t.payment_status === 'completed' ? 'success' : 
                              t.payment_status === 'pending' ? 'warning' : 'error'
                            }
                          />
                        </Box>
                      </Box>
                    </Box>
                    <Divider sx={{ 
                      mb: 2, 
                      borderColor: 'rgba(255,255,255,0.1)' 
                    }} />
                    <Typography
                      variant="h5"
                      color={t.amount > 0 ? "success.light" : "error.light"}
                      fontWeight="bold"
                      sx={{ mb: 1 }}
                    >
                      {t.amount > 0 ? '+' : ''}{t.amount} créditos
                    </Typography>
                    {user && t.payment_amount && (
                      <Box sx={{
                        display: 'flex',
                        alignItems: 'center',
                        gap: 1,
                        mt: 2
                      }}>
                        <Box sx={{
                          display: 'flex',
                          alignItems: 'center',
                          gap: 0.5,
                          color: 'text.secondary'
                        }}>
                          {getPaymentMethodIcon(t.payment_method)}
                          <Typography variant="body2">
                            ${t.payment_amount.toFixed(2)}
                          </Typography>
                        </Box>
                        {t.payment_method && (
                          <Typography 
                            variant="caption" 
                            color="text.secondary"
                            sx={{ ml: 0.5 }}
                          >
                            • {t.payment_method}
                          </Typography>
                        )}
                      </Box>
                    )}
                  </TransactionCard>
                </motion.div>
              ))}
            </Box>
          </AnimatePresence>
        )}
      </Box>
    </Box>
  );
}

TEndras que generar Para el frontend:

- añadir a la botonera de navbar un icono mas para los cupones que notificará de los cupones para el usuario activo en ese momento
- una pagina en /users/coupon/ que se accederá pinchando desde el icono de cupones de la botonera de navbar que nos llevará a una pagina donde se mostrará
todo el historial de cupones del usuario y donde podrá canejar los cupones activos
- actualizaremos el dashboard de usuario añadiendo una pestaña mas a la barra de opciones: después de la pestaña TRANSACCIONES, pondemos la pestaña "CUPONES"
donde el usuario podra ver si historial de cupones y canjearlos.
- actualizaremos el dashboard de administrador añadiendo: en la pestaña de funcionalidades añadiremos la nueva tarjeta para activar o desactivar la 
funcionalidad de los cupones.
- actualizaremos el dashboard de administrador añadiendo una nueva pestaña al menu: CUPONES, en esa pestaña el administrador podrá: añadir nuevos cupones,
gestionar, modificar y borrar los existentes, asi como visualizarlos.
- crear los tipados, funciones, interfaces, handles, constantes, y todo lo que necesites



Debo recordarte cosas importantes:

- recuerda que estamos utilizando localStorage para almacenar el contexto del usuario (independientemente de que se registrado o guest)
- no modifiques de ninguna de las maneras las logicas ya existentes, tu codigo no debe interferir en lo que ya esta funcionando
- entiende la logica actual, estructura, organización y guia de estilo de programación para continuarla 
- Aborda m solicitud de manera estructurada y detallada, respetando la lógica actual de la aplicación y siguiendo mis instrucciones al pie de la letra. 3
- Dado que hay varios puntos a tratar, separara la respuesta en partes claras para que sea más fácil de seguir. Genera los códigos completos solicitados.
- Indicame si necesitas más archivos para ciertas implementaciones y te los proporcionaré, recuerda que tienes el arbol de archivos completo de la app.
- implementa las mejoras solicitadas de manera clara y estructurada

Por ultimo te paso algunos archivos de configuración para que tengas presente lo que tenemos a disposición en produccion:

// frontend/src/components/ui/index.tsx
import { ReactNode } from "react";
import { motion } from "framer-motion";

export const LoadingSpinner = () => (
  <motion.div
    animate={{ rotate: 360 }}
    transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
    className="h-8 w-8 border-4 border-purple-500 border-t-transparent rounded-full"
  />
);

export const GlassCard = ({ children, className }: { children: ReactNode; className?: string }) => (
  <motion.div
    className={`bg-white/5 backdrop-blur-lg rounded-xl border border-white/10 ${className}`}
    whileHover={{ scale: 1.02 }}
  >
    {children}
  </motion.div>
);

export const GradientText = ({ children, className }: { children: ReactNode; className?: string }) => (
  <span className={`bg-gradient-to-r from-purple-400 to-pink-500 bg-clip-text text-transparent ${className}`}>
    {children}
  </span>
);

export const BadgeIcon = ({ type, className }: { type: string; className?: string }) => {
  const icons: Record<string, string> = {
    'api_usage': '💻',
    'survey_completed': '📝',
    'registration_completed': '🎯',
    'all_subscriptions': '📬',
    'default': '🏆'
  };
  
  return <div className={`${className} flex items-center justify-center text-4xl`}>{icons[type] || icons.default}</div>;
};

export const TimelineIcon = ({ type, className }: { type: string; className?: string }) => {
  const icons: Record<string, string> = {
    'api_usage': '⬆️',
    'survey_completed': '✅',
    'registration_completed': '📋',
    'all_subscriptions': '📩',
    'default': '✨'
  };
  
  return <span className={`${className} text-2xl`}>{icons[type] || icons.default}</span>;
};

export const EmptyState = ({ icon, title, description }: { icon: string; title: string; description: string }) => (
  <div className="text-center py-12">
    <div className="text-6xl mb-4">{icon}</div>
    <h3 className="text-xl font-semibold text-white mb-2">{title}</h3>
    <p className="text-gray-400 max-w-md mx-auto">{description}</p>
  </div>
);

// components/ui/index.tsx
export const RankingMedal = ({ position }: { position: number }) => {
  const colors = {
    1: "from-yellow-400 to-yellow-600",
    2: "from-gray-400 to-gray-600",
    3: "from-amber-600 to-amber-800",
    default: "from-purple-500 to-pink-500"
  };

  return (
    <div className={`w-12 h-12 rounded-full flex items-center justify-center 
      bg-gradient-to-r ${colors[position as keyof typeof colors] || colors.default}`}>
      <span className="font-bold text-white">{position}</span>
    </div>
  );
};

export const InteractiveDemo = ({ children }: { children: React.ReactNode }) => (
  <motion.div
    className="relative overflow-hidden rounded-xl"
    whileHover={{ scale: 1.02 }}
  >
    <div className="absolute inset-0 bg-gradient-to-r from-purple-500/20 to-pink-500/20" />
    <div className="relative backdrop-blur-sm p-8">
      {children}
    </div>
  </motion.div>
);

asi como archivos importantes

// src/lib/api.ts
import axios, { AxiosRequestConfig, AxiosResponse, AxiosError, AxiosInstance } from "axios";
import { HTTPValidationError, FetchResponse, RegisterRequest, TokenResponse, UpdateProfileRequest, User, ValidationError } from "./types";

// Extender AxiosRequestConfig para incluir _retry
interface CustomAxiosRequestConfig extends AxiosRequestConfig {
  _retry?: boolean;
}

// Crear una instancia personalizada de Axios
const api: AxiosInstance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL,
});

// Variables para manejar el estado de refresco
let isRefreshing = false;
let failedQueue: Array<{ resolve: (token: string) => void; reject: (error: any) => void }> = [];

const processQueue = (error: any, token: string | null = null) => {
  failedQueue.forEach(prom => {
    if (error) {
      prom.reject(error);
    } else {
      prom.resolve(token!);
    }
  });
  failedQueue = [];
};

// Agregar el interceptor de solicitudes
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("accessToken");
  const sessionId = localStorage.getItem("session_id");
  if (token) {
    config.headers["Authorization"] = `Bearer ${token}`;
  } else if (sessionId) {
    config.headers["X-Session-ID"] = sessionId;
  }
  return config;
});

const logRequest = (method: string, url: string, status: number, data?: unknown) => {
  console.log(`[${method}] ${url} - Status: ${status}`, data ?? "");
};

const fetchAPI = async <T>(
  endpoint: string,
  options: CustomAxiosRequestConfig = {},
  contentType: string = "application/json"
): Promise<FetchResponse<T>> => {
  console.log(`Iniciando fetchAPI para ${endpoint}`);

  const config: CustomAxiosRequestConfig = {
    ...options,
    url: endpoint, // baseURL ya está configurado en la instancia
    headers: {
      "Content-Type": contentType,
      ...options.headers,
    },
    data: options.data,
  };

  // Convertir datos a formato x-www-form-urlencoded si es necesario
  if (contentType === "application/x-www-form-urlencoded" && config.data) {
    const formData = new URLSearchParams();
    Object.entries(config.data).forEach(([key, value]) => {
      if (value !== undefined) formData.append(key, String(value));
    });
    config.data = formData;
  }

  const normalizeResponse = (
    response: AxiosResponse<T> | undefined,
    error: unknown
  ): FetchResponse<T> => {
    if (response && response.status >= 200 && response.status < 300) {
      return { data: response.data, error: null };
    }

    if (axios.isAxiosError(error)) {
      const errorData = error.response?.data;
      if (errorData && errorData.detail) {
        if (typeof errorData.detail === "string") {
          return { data: null, error: errorData.detail };
        } else if (Array.isArray(errorData.detail)) {
          const messages = errorData.detail
            .map((err: ValidationError) => err.msg)
            .join(", ");
          return { data: null, error: messages };
        }
      }
    }

    return { data: null, error: "Error desconocido" };
  };

  try {
    const response: AxiosResponse<T> = await api(config); // Usar la instancia 'api'
    logRequest(config.method || "GET", config.url!, response.status, response.data);

    if (response.data && (response.data as any).session_id) {
      localStorage.setItem("session_id", (response.data as any).session_id);
    }

    return normalizeResponse(response, null);
  } catch (err: unknown) {
    const axiosError = err as AxiosError;
    logRequest(
      config.method || "GET",
      config.url!,
      axiosError.response?.status || 500,
      axiosError.response?.data
    );

    if (axiosError.response?.status === 401 && !config._retry) {
      const originalRequest: CustomAxiosRequestConfig = config;
      originalRequest._retry = true;

      const accessToken = localStorage.getItem("accessToken");
      const refreshToken = localStorage.getItem("refreshToken");

      if (accessToken && refreshToken) {
        if (isRefreshing) {
          return new Promise((resolve, reject) => {
            failedQueue.push({
              resolve: (token) => {
                originalRequest.headers.Authorization = `Bearer ${token}`;
                api(originalRequest)
                  .then(response => resolve(normalizeResponse(response, null)))
                  .catch(error => reject(normalizeResponse(undefined, error)));
              },
              reject: (error) => reject(normalizeResponse(undefined, error)),
            });
          });
        }

        isRefreshing = true;

        try {
          console.log("Intentando refrescar token de acceso");
          const refreshResponse = await api.post<TokenResponse>(
            "/v1/auth/refresh",
            { refresh_token: refreshToken },
            {
              headers: {
                "Content-Type": "application/json",
                "Authorization": `Bearer ${accessToken}`,
              },
            }
          );

          localStorage.setItem("accessToken", refreshResponse.data.access_token);
          localStorage.setItem("refreshToken", refreshResponse.data.refresh_token);

          originalRequest.headers.Authorization = `Bearer ${refreshResponse.data.access_token}`;
          processQueue(null, refreshResponse.data.access_token);

          const retryResponse = await api(originalRequest);
          return normalizeResponse(retryResponse, null);
        } catch (refreshError) {
          console.error("Error al refrescar token:", refreshError);
          localStorage.removeItem("accessToken");
          localStorage.removeItem("refreshToken");
          localStorage.removeItem("session_id");
          processQueue(refreshError, null);
          window.location.href = "/user/auth/#login";
          return normalizeResponse(undefined, {
            message: "Sesión expirada, por favor inicia sesión nuevamente",
          });
        } finally {
          isRefreshing = false;
        }
      } else {
        return normalizeResponse(undefined, { message: "No autorizado" });
      }
    }

    return normalizeResponse(undefined, err);
  }
};

// Funciones específicas de la API
export const getAllUsers = async (
  page: number = 1,
  limit: number = 10
): Promise<FetchResponse<{
  data: User[],
  total_items: number,
  total_pages: number,
  current_page: number
}>> => {
  return fetchAPI(`/v1/users/admin/users?page=${page}&limit=${limit}`, {
    method: "GET"
  });
};

export const getUserById = async (
  userId: number
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "GET"
  });
};

export const updateUser = async (
  userId: number,
  data: UpdateProfileRequest
): Promise<FetchResponse<User>> => {
  return fetchAPI<User>(`/v1/users/${userId}`, {
    method: "PUT",
    data
  });
};

export const deleteUser = async (
  userId: number
): Promise<FetchResponse<void>> => {
  return fetchAPI<void>(`/v1/users/${userId}`, {
    method: "DELETE"
  });
};

export const createUser = async (
  data: RegisterRequest
): Promise<FetchResponse<TokenResponse>> => {
  return fetchAPI<TokenResponse>("/v1/auth/register", {
    method: "POST",
    data
  });
};

export default fetchAPI;

Recuerda ampliar la pagina de ejmeplos de la api con las nuevas funciones para probar los cupones

// frontend/src/app/ejemplos/page.tsx
"use client";

import { useState, useEffect } from "react";
import {
  Box,
  Typography,
  Button,
  TextField,
  Checkbox,
  FormControlLabel,
  Card,
  CardContent,
  Snackbar,
  Alert,
} from "@mui/material";
import { motion } from "framer-motion";
import fetchAPI from "@/lib/api";
import { useAuth } from "@/lib/auth/context";
import { UserGamificationResponse, Badge, InfoResponse } from "@/lib/types";

export default function Ejemplos() {
  const { setGamification } = useAuth();
  const [snackMessage, setSnackMessage] = useState<string | null>(null);
  const [registroFields, setRegistroFields] = useState({ name: "", email: "", phone: "" });
  const [newsletterSubs, setNewsletterSubs] = useState({ tech: false, marketing: false, design: false });
  const [encuestaAnswers, setEncuestaAnswers] = useState<number[]>([]);
  const [checkinDone, setCheckinDone] = useState(false);
  const [icpFields, setIcpFields] = useState({ company: "", role: "", industry: "" });
  const [tutorialLessons, setTutorialLessons] = useState([false, false, false]);
  const [formFields, setFormFields] = useState({ name: "", email: "", phone: "" });
  const [subscriptions, setSubscriptions] = useState({ list1: false, list2: false, list3: false });
  const [surveyAnswers, setSurveyAnswers] = useState<number[]>([]);

  const updateGamification = async () => {
    const { data } = await fetchAPI<InfoResponse>("/info");
    if (data?.gamification) {
      const totalPoints = data.gamification.reduce((sum, g) => sum + g.points, 0);
      const badges = data.gamification.map((g) => g.badge).filter((b) => b !== null) as Badge[];
      setGamification({ points: totalPoints, badges });
    }
  };

  useEffect(() => {
    updateGamification();
  }, []);

  const handleRegistroChange = async (field: keyof typeof registroFields, value: string) => {
    setRegistroFields((prev) => ({ ...prev, [field]: value }));
    if (value) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 1 } });
      updateGamification();
      setSnackMessage("¡Ganaste 1 punto por completar un campo!");
    }
    if (registroFields.name && registroFields.email && registroFields.phone) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 2 } });
      updateGamification();
      setSnackMessage("¡Completaste el registro y ganaste 10 puntos!");
    }
  };

  const handleNewsletterChange = async (newsletter: keyof typeof newsletterSubs) => {
    setNewsletterSubs((prev) => ({ ...prev, [newsletter]: !prev[newsletter] }));
    if (!newsletterSubs[newsletter]) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 3 } });
      updateGamification();
      setSnackMessage("¡Ganaste 2 puntos por suscribirte a una newsletter!");
    }
    if (newsletterSubs.tech && newsletterSubs.marketing && newsletterSubs.design) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 4 } });
      updateGamification();
      setSnackMessage("¡Te suscribiste a todas las newsletters y ganaste 15 puntos!");
    }
  };

  const handleEncuestaAnswer = async (answer: number) => {
    setEncuestaAnswers((prev) => [...prev, answer]);
    await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 5 } });
    updateGamification();
    setSnackMessage("¡Ganaste 1 punto por responder una pregunta!");
  };

  const handleEncuestaComplete = async () => {
    if (encuestaAnswers.length === 3) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 6 } });
      updateGamification();
      setSnackMessage("¡Completaste la encuesta y ganaste 10 puntos!");
    }
  };

  const handleCheckin = async () => {
    setCheckinDone(true);
    await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 7 } });
    updateGamification();
    setSnackMessage("¡Ganaste 5 puntos por hacer check-in!");
  };

  const handleIcpChange = async (field: keyof typeof icpFields, value: string) => {
    setIcpFields((prev) => ({ ...prev, [field]: value }));
    if (value) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 8 } });
      updateGamification();
      setSnackMessage("¡Ganaste 1 punto por completar un campo del ICP!");
    }
    if (icpFields.company && icpFields.role && icpFields.industry) {
      await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 9 } });
      updateGamification();
      setSnackMessage("¡Completaste tu ICP y ganaste 10 puntos!");
    }
  };

  const handleFormChange = async (field: keyof typeof formFields, value: string) => {
    setFormFields((prev) => ({ ...prev, [field]: value }));
    if (value) {
      await fetchAPI("/v1/gamification/events", {
        method: "POST",
        data: { event_type_id: 3 },
      });
      updateGamification();
    }
    if (formFields.name && formFields.email && formFields.phone) {
      await fetchAPI("/v1/gamification/events", {
        method: "POST",
        data: { event_type_id: 4 },
      });
      updateGamification();
    }
  };

  const handleSubscriptionChange = async (list: keyof typeof subscriptions) => {
    setSubscriptions((prev) => ({ ...prev, [list]: !prev[list] }));
    if (!subscriptions[list]) {
      await fetchAPI("/v1/gamification/events", {
        method: "POST",
        data: { event_type_id: 5 },
      });
      updateGamification();
    }
    if (subscriptions.list1 && subscriptions.list2 && subscriptions.list3) {
      await fetchAPI("/v1/gamification/events", {
        method: "POST",
        data: { event_type_id: 6 },
      });
      updateGamification();
    }
  };

  const handleSurveyAnswer = async (answer: number) => {
    setSurveyAnswers((prev) => ({ ...prev, answer }));
    await fetchAPI("/v1/gamification/events", {
      method: "POST",
      data: { event_type_id: 1 },
    });
    updateGamification();
  };

  const handleSurveyComplete = async () => {
    if (surveyAnswers.length === 3) {
      await fetchAPI("/v1/gamification/events", {
        method: "POST",
        data: { event_type_id: 2 },
      });
      updateGamification();
    }
  };

  const handleLessonComplete = async (index: number) => {
    setTutorialLessons((prev) => {
      const newLessons = [...prev];
      newLessons[index] = true;
      return newLessons;
    });
    await fetchAPI("/v1/gamification/events", { method: "POST", data: { event_type_id: 10 } });
    updateGamification();
    setSnackMessage("¡Ganaste 3 puntos por completar una lección!");
  };

  return (
    <Box sx={{ p: { xs: 2, sm: 4 }, bgcolor: "#f5f7fa", minHeight: "100vh" }}>
      {/* Hero Section */}
      <motion.div initial={{ opacity: 0, y: -20 }} animate={{ opacity: 1, y: 0 }} transition={{ duration: 0.5 }}>
        <Typography variant="h3" align="center" gutterBottom sx={{ fontWeight: "bold", color: "#1976d2" }}>
          ¡Transforma tu Negocio con Gamificación!
        </Typography>
        <Typography variant="h6" align="center" color="textSecondary" sx={{ mb: 4, maxWidth: "800px", mx: "auto" }}>
          Aumenta el engagement, dispara tus conversiones y fideliza a tus clientes con nuestra API SaaS de gamificación y scoring. ¡Prueba cómo funciona y descubre el poder de las recompensas hoy mismo!
        </Typography>
        <Box sx={{ display: "flex", justifyContent: "center", mb: 6 }}>
          <Button
            variant="contained"
            color="primary"
            size="large"
            sx={{ borderRadius: 2, px: 4, py: 1.5 }}
            onClick={() => document.getElementById("registro")?.scrollIntoView({ behavior: "smooth" })}
          >
            ¡Prueba Gratis Ahora!
          </Button>
        </Box>
      </motion.div>

      {/* Main Content */}
      <Box sx={{ maxWidth: "800px", mx: "auto", display: "flex", flexDirection: "column", gap: 4 }}>
        <Card sx={{ boxShadow: 3, borderRadius: 2 }} id="registro">
          <CardContent>
            <Typography variant="h6" color="primary">
              Regístrate y Gana Recompensas Instantáneas
            </Typography>
            <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
              Completa tus datos y empieza a acumular puntos que potencian tu experiencia. ¡Tu primer paso hacia un engagement imparable!
            </Typography>
            <Box component="form" sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
              <TextField
                label="Nombre"
                value={registroFields.name}
                onChange={(e) => handleRegistroChange("name", e.target.value)}
                variant="outlined"
              />
              <TextField
                label="Email"
                value={registroFields.email}
                onChange={(e) => handleRegistroChange("email", e.target.value)}
                variant="outlined"
              />
              <TextField
                label="Teléfono"
                value={registroFields.phone}
                onChange={(e) => handleRegistroChange("phone", e.target.value)}
                variant="outlined"
              />
            </Box>
          </CardContent>
        </Card>

        <Card sx={{ boxShadow: 3, borderRadius: 2 }}>
          <CardContent>
            <Typography variant="h6" color="primary">
              Suscríbete y Desbloquea Estrategias Ganadoras
            </Typography>
            <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
              Únete a nuestras newsletters y recibe contenido exclusivo para maximizar tus conversiones mientras ganas puntos.
            </Typography>
            <Box sx={{ display: "flex", flexDirection: "column", gap: 1 }}>
              <FormControlLabel
                control={<Checkbox checked={newsletterSubs.tech} onChange={() => handleNewsletterChange("tech")} />}
                label="Tecnología"
              />
              <FormControlLabel
                control={<Checkbox checked={newsletterSubs.marketing} onChange={() => handleNewsletterChange("marketing")} />}
                label="Marketing"
              />
              <FormControlLabel
                control={<Checkbox checked={newsletterSubs.design} onChange={() => handleNewsletterChange("design")} />}
                label="Diseño"
              />
            </Box>
          </CardContent>
        </Card>

        <Card sx={{ boxShadow: 3, borderRadius: 2 }}>
          <CardContent>
            <Typography variant="h6" color="primary">
              Comparte tu Opinión y Sube de Nivel
            </Typography>
            <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
              Responde preguntas y acumula puntos que destacan tu perfil en nuestra plataforma. ¡Tu feedback cuenta!
            </Typography>
            <Box sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
              <Button variant="outlined" onClick={() => handleEncuestaAnswer(1)}>
                Pregunta 1
              </Button>
              <Button variant="outlined" onClick={() => handleEncuestaAnswer(2)}>
                Pregunta 2
              </Button>
              <Button variant="outlined" onClick={() => handleEncuestaAnswer(3)}>
                Pregunta 3
              </Button>
              <Button
                variant="contained"
                onClick={handleEncuestaComplete}
                disabled={encuestaAnswers.length !== 3}
              >
                Completar Encuesta
              </Button>
            </Box>
          </CardContent>
        </Card>

        <Card sx={{ boxShadow: 3, borderRadius: 2 }}>
          <CardContent>
            <Typography variant="h6" color="primary">
              Haz Check-in y Destaca
            </Typography>
            <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
              Registra tu actividad y gana puntos para posicionarte como líder en tu industria.
            </Typography>
            <Button variant="contained" onClick={handleCheckin} disabled={checkinDone}>
              {checkinDone ? "Check-in Realizado" : "Hacer Check-in"}
            </Button>
          </CardContent>
        </Card>

        <Card sx={{ boxShadow: 3, borderRadius: 2 }}>
          <CardContent>
            <Typography variant="h6" color="primary">
              Define tu Perfil y Maximiza Resultados
            </Typography>
            <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
              Completa tu ICP y desbloquea puntos para personalizar tu experiencia y crecer con nuestra API.
            </Typography>
            <Box component="form" sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
              <TextField
                label="Empresa"
                value={icpFields.company}
                onChange={(e) => handleIcpChange("company", e.target.value)}
                variant="outlined"
              />
              <TextField
                label="Rol"
                value={icpFields.role}
                onChange={(e) => handleIcpChange("role", e.target.value)}
                variant="outlined"
              />
              <TextField
                label="Industria"
                value={icpFields.industry}
                onChange={(e) => handleIcpChange("industry", e.target.value)}
                variant="outlined"
              />
            </Box>
          </CardContent>
        </Card>

        <Card sx={{ boxShadow: 3, borderRadius: 2 }}>
          <CardContent>
            <Typography variant="h6" color="primary">
              Aprende, Gana y Lidera
            </Typography>
            <Typography variant="body2" color="textSecondary" sx={{ mb: 2 }}>
              Completa lecciones rápidas, domina nuestra plataforma y acumula puntos para destacar.
            </Typography>
            <Box sx={{ display: "flex", flexDirection: "column", gap: 2 }}>
              {tutorialLessons.map((completed, index) => (
                <Button
                  key={index}
                  variant="outlined"
                  onClick={() => handleLessonComplete(index)}
                  disabled={completed}
                >
                  {completed ? `Lección ${index + 1} Completada` : `Completar Lección ${index + 1}`}
                </Button>
              ))}
            </Box>
          </CardContent>
        </Card>
      </Box>

      {/* CTA Final */}
      <Box sx={{ mt: 6, textAlign: "center" }}>
        <Typography variant="h5" sx={{ mb: 2, fontWeight: "bold", color: "#1976d2" }}>
          ¿Listo para revolucionar tu engagement?
        </Typography>
        <Typography variant="body1" color="textSecondary" sx={{ mb: 3, maxWidth: "600px", mx: "auto" }}>
          Únete a cientos de negocios que ya están aumentando sus conversiones con nuestra solución de gamificación. ¡Empieza gratis hoy!
        </Typography>
        <Button
          variant="contained"
          color="secondary"
          size="large"
          sx={{ borderRadius: 2, px: 4, py: 1.5 }}
          onClick={() => window.location.href = "/signup"} // Ajusta la URL según tu flujo
        >
          Comienza Gratis
        </Button>
      </Box>

      <Snackbar open={!!snackMessage} autoHideDuration={3000} onClose={() => setSnackMessage(null)}>
        <Alert severity="success" onClose={() => setSnackMessage(null)}>
          {snackMessage}
        </Alert>
      </Snackbar>
    </Box>
  );
}

Ya esta. EN principio no hecho nada en falta para esta primera actuación.

Si necesitas más ayuda o necesitas código adicional que ver, no dudes en decírmelo. A ver como te desenvuelves con mi software.

Se que es muchiiiisima información, por favor leela toda con detenimiento. Si es mucho separa tu respuesta en partes. Solicitame los archivos que necesites ver. 


Respeta la logica actual para no romper ningun servicio activo. 
Es importante esta parte que salga bien, tomate tu tiempo.
Pideme los archivos que necesites ver para una mejor implantación.
Si te parece mejor por motivos de capacidad generame la respuesta en varias partes, lo dejo a tu elección.

Explica cada paso para que yo aprenda a implantar mis propios modulos.

Recuerda generar codigo completo.


Ya puedes proceder paso a paso con tu respuesta.
