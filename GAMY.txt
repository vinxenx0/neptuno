Excelente , pero te has dejado muchas cosas por el camino que estan provocando algunos bugs:

- 1- Con los nuevos cambios no se actualizan el numero de insignias ni el numero de puntos, ademas el json con la info del usuario devuelve gamification vacio, por ejemplo: 

Información obtenida: {"user_id":"a50a0b78-e23b-4ab8-a14f-3d01096a492c","email":"anonymous@example.com","username":"Guest_k19uy","user_type":"anonymous","subscription":"basic","credits":100,"rol":"anonymous","session_id":"a50a0b78-e23b-4ab8-a14f-3d01096a492c","gamification":[]}

- 2 - Tu solución para refrescar los badges no funciona y no me gusta, debe ser en tiempo real al igual que sucede con los creditos

Console Error

Error: setGamification is not a function

src/components/web/Navbar.tsx (127:11) @ Navbar.useEffect.interval

  125 |           }
  126 |
> 127 |           setGamification({ points: totalPoints, badges });
      |           ^
  128 |         }
  129 |       } catch (err) {
  130 |         console.error("Error al actualizar datos:", err);

Call Stack 1
Navbar.useEffect.interval
src/components/web/Navbar.tsx (127:11)

Implanta una solución para que se actualicen los puntos e insignias conforme se van consiguiendo al igual que sucede con los creitos

-3 - No has creado los nuevos tipados de datos que has utilizado en tu codigo en context.tsx

import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

aqui tienes los tipados actuales relacionados con los tipados:


// respuesta /info
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string; // Solo para anónimos
 }

 export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[]; // Ahora es una lista de badges


- 4- La solución al navbar devuelve muchos errores de propiedades que no existen en el archivo

./src/components/web/Navbar.tsx:76:52
Type error: Property 'setGamification' does not exist on type 'AuthContextType'.

  74 | export default function Navbar() {
  75 |   const theme = useTheme();
> 76 |   const { user, credits, gamification, setCredits, setGamification, logout } = useAuth();
     |                                                                                                              ^


UserInfo tampoco me lo reconoce en esta linea :         const { data: infoData } = await fetchAPI<UserInfo>("/info");

UserGamificationResponse tampoco me lo reconoce en el contexto del archivo:         const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");

Aqui tienes un resumen de todas las definiciones que dan error en tu codigo junto con el modulo o archivo donde aparece

[{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/lib/auth/context.tsx",
	"owner": "typescript",
	"code": "2305",
	"severity": 8,
	"message": "Module '\"../types\"' has no exported member 'UserGamificationResponse'.",
	"source": "ts",
	"startLineNumber": 9,
	"startColumn": 62,
	"endLineNumber": 9,
	"endColumn": 86
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/lib/auth/context.tsx",
	"owner": "typescript",
	"code": "2305",
	"severity": 8,
	"message": "Module '\"../types\"' has no exported member 'GamificationEventResponse'.",
	"source": "ts",
	"startLineNumber": 9,
	"startColumn": 35,
	"endLineNumber": 9,
	"endColumn": 60
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/lib/auth/context.tsx",
	"owner": "typescript",
	"code": "2305",
	"severity": 8,
	"message": "Module '\"../types\"' has no exported member 'GamificationEventCreate'.",
	"source": "ts",
	"startLineNumber": 9,
	"startColumn": 10,
	"endLineNumber": 9,
	"endColumn": 33
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2304",
	"severity": 8,
	"message": "Cannot find name 'Badge'.",
	"source": "ts",
	"startLineNumber": 114,
	"startColumn": 88,
	"endLineNumber": 114,
	"endColumn": 93
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2304",
	"severity": 8,
	"message": "Cannot find name 'UserGamificationResponse'.",
	"source": "ts",
	"startLineNumber": 111,
	"startColumn": 59,
	"endLineNumber": 111,
	"endColumn": 83
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2304",
	"severity": 8,
	"message": "Cannot find name 'UserInfo'.",
	"source": "ts",
	"startLineNumber": 106,
	"startColumn": 51,
	"endLineNumber": 106,
	"endColumn": 59
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2339",
	"severity": 8,
	"message": "Property 'setGamification' does not exist on type 'AuthContextType'.",
	"source": "ts",
	"startLineNumber": 76,
	"startColumn": 52,
	"endLineNumber": 76,
	"endColumn": 67
}]

-5- Vamos a crear una pagina que se llame "Rankings",vamos a crear una nueva pagina en /src/app/rankings donde aparezca el listado de usuarios (registrados u anonimos) con los datos de puntos conseguidos, insignias obtenidas, nombre de usuario, y que se pueda ordenar tanto por puntos conseguidos como por insignias conseguidas.


-6-  - Por ultimo vamos a crear una pagina con ejemplos muy afinados y exclusivos e ilustrativos de nuestra nueva función de puntos y badges. En esta nueva pagina que se llamará "Ejemplos" habrán los siguientes componentes:

- Una encuesta con varias opciones (cada pregunta que responda el usuario será 1 punto), si responde toda la encuesta le daremos un badge

- Un formulario de registro con varios campos (cada campo rellenado será un punto) si responde todos los campos obtendrá insignia

- Un formulario donde el usuario podrá subscribirse a varias listas de correo ficticias (por cada lista que se apunte será un punto) si se apunta a todas será un badge.


Crea los modelos de datos, esquemas pydantic, interfaces, servicios, middleware etc para que todo encaje a la perfeción con el codigo actua y mantener separación de responsabilidades (modelos, servicios y rutas en archivos independientes). Piensa en nuestra aplicación y recuerdala todo lo posible para realizar una implantación lo mas profesional posible y que se adapte con la menor fricción posible a lo que ya hay hecho.Crea los modelos de datos, esquemas pydantic, interfaces, servicios, middleware etc para que todo encaje a la perfeción con el codigo actua y mantener separación de responsabilidades (modelos, servicios y rutas en archivos independientes).

Recuerda que gestionamos usuarios anonimos almacenando en localstorage y usuarios registrados, ambos tienen su persistencia en la db.


Recuerda que hemos implantado en el paso anterior un modelado más complejo para badges y eventos que no depende de enums hardcodeados, sino que use la base de datos para almacenar esta información

Te paso archivos que puede ser de tu interes que reviseses para aplicar los cambios solicitadores

// src/lib/auth/context.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge  } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // Añadimos gamificación al contexto
  setCredits: (credits: number) => void; // Añadido
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(100); // Valor por defecto para anónimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificación
  const [loading, setLoading] = useState(true);
  const router = useRouter();


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<UserInfo>("/info");
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
            localStorage.setItem("anonUsername", data.username!);
          } else {
            setUser(null);
            setCredits(0);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          }
  
          // Procesar datos de gamificación
          const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
          if (gamificationData && Array.isArray(gamificationData)) {
            const totalPoints = gamificationData.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationData.map(g => g.badge).filter(b => b !== null) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        localStorage.removeItem("session_id");
        localStorage.removeItem("anonUsername");
      } finally {
        setLoading(false);
      }
    };
  
    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesión");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesión
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesión:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesión
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operación
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibió la información del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contraseña");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits,gamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// src/components/web/Navbar.tsx
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import fetchAPI from "@/lib/api";
import { 
  Button, 
  Avatar, 
  Chip, 
  IconButton, 
  Menu, 
  MenuItem, 
  Divider, 
  useTheme,
  styled,
  Box,
  Typography,
  Snackbar,
  Alert
} from "@mui/material";
import {
  MonetizationOn,
  Settings,
  ListAlt,
  People,
  Dashboard,
  Login,
  PersonAdd,
  Person,
  ArrowDropDown,
  Home,
  Star,
  EmojiEvents
} from "@mui/icons-material";

const GlassNavbar = styled('nav')(({ theme }) => ({
  background: 'rgba(255, 255, 255, 0.1)',
  backdropFilter: 'blur(10px)',
  borderBottom: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1, 2),
  position: 'sticky',
  top: 0,
  zIndex: 1000,
}));

const NavContainer = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  maxWidth: '1200px',
  margin: '0 auto',
}));

const CreditsChip = styled(Chip)(({ theme }) => ({
  background: 'rgba(255, 165, 0, 0.2)', // Fondo naranja claro
  color: '#FFA500', // Texto naranja
  borderColor: '#FFA500',
}));

const PointsChip = styled(Chip)(({ theme }) => ({
  background: 'rgba(255, 215, 0, 0.2)', // Fondo dorado claro
  color: '#FFD700', // Texto dorado
  borderColor: '#FFD700',
}));

const BadgesChip = styled(Chip)(({ theme }) => ({
  background: 'rgba(0, 128, 0, 0.2)', // Fondo verde claro
  color: '#008000', // Texto verde
  borderColor: '#008000',
}));

export default function Navbar() {
  const theme = useTheme();
  const { user, credits, gamification, setCredits, setGamification, logout } = useAuth();
  const [settingsAnchorEl, setSettingsAnchorEl] = useState<null | HTMLElement>(null);
  const [disableCredits, setDisableCredits] = useState(false);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const [anonUsername, setAnonUsername] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [newBadge, setNewBadge] = useState<string | null>(null);

  useEffect(() => {
    const storedAnonUsername = localStorage.getItem("anonUsername");
    setAnonUsername(storedAnonUsername);
  }, []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const disableCreditsRes = await fetchAPI("/v1/settings/disable_credits");
        const enableRegistrationRes = await fetchAPI("/v1/settings/enable_registration");
        setDisableCredits(disableCreditsRes.data === "true" || disableCreditsRes.data === true);
        setEnableRegistration(enableRegistrationRes.data === "true" || enableRegistrationRes.data === true);
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
      }
    };
    fetchSettings();
  }, []);

  useEffect(() => {
    const interval = setInterval(async () => {
      try {
        const { data: infoData } = await fetchAPI<UserInfo>("/info");
        if (infoData) {
          setCredits(infoData.credits);
        }

        const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
        if (gamificationData && Array.isArray(gamificationData)) {
          const totalPoints = gamificationData.reduce((sum, g) => sum + g.points, 0);
          const badges = gamificationData.map(g => g.badge).filter(b => b !== null) as Badge[];
          
          // Detectar nuevos badges
          const previousBadges = JSON.parse(localStorage.getItem("badges") || "[]");
          const currentBadgeIds = badges.map(b => b.id);
          const newBadges = currentBadgeIds.filter(id => !previousBadges.includes(id));
          if (newBadges.length > 0) {
            const badge = badges.find(b => b.id === newBadges[0]);
            setNewBadge(badge?.name || "Nuevo badge");
            setSnackbarOpen(true);
            localStorage.setItem("badges", JSON.stringify(currentBadgeIds));
          }

          setGamification({ points: totalPoints, badges });
        }
      } catch (err) {
        console.error("Error al actualizar datos:", err);
      }
    }, 30000); // Cada 30 segundos

    return () => clearInterval(interval);
  }, [setCredits, setGamification]);

  const handleSettingsMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchorEl(event.currentTarget);
  };

  const handleSettingsMenuClose = () => {
    setSettingsAnchorEl(null);
  };

  return (
    <GlassNavbar>
      <NavContainer>
        <Link href="/" passHref>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, cursor: 'pointer' }}>
            <Home color="primary" />
            <Typography 
              variant="h6" 
              component="span" 
              sx={{ 
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent'
              }}
            >
              Neptuno
            </Typography>
          </Box>
        </Link>

        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          {!disableCredits && credits > 0 && (
            <CreditsChip
              icon={<MonetizationOn />}
              label={credits}
              variant="outlined"
            />
          )}

          {gamification && (
            <>
              <PointsChip
                icon={<Star />}
                label={gamification.points}
                variant="outlined"
              />
              <BadgesChip
                icon={<EmojiEvents />}
                label={gamification.badges.length}
                variant="outlined"
              />
            </>
          )}

          {user?.rol === "admin" && (
            <>
              <IconButton
                onClick={handleSettingsMenuOpen}
                sx={{ color: 'inherit', '&:hover': { backgroundColor: 'rgba(255, 255, 255, 0.1)' } }}
              >
                <Settings />
              </IconButton>
              <Menu
                anchorEl={settingsAnchorEl}
                open={Boolean(settingsAnchorEl)}
                onClose={handleSettingsMenuClose}
                PaperProps={{
                  sx: {
                    background: 'rgba(255, 255, 255, 0.9)',
                    backdropFilter: 'blur(10px)',
                    borderRadius: '12px',
                    mt: 1,
                    minWidth: '200px'
                  }
                }}
              >
                <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/dashboard">
                  <Dashboard sx={{ mr: 1 }} /> Dashboard
                </MenuItem>
                <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/registry">
                  <ListAlt sx={{ mr: 1 }} /> Registros
                </MenuItem>
                <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/users">
                  <People sx={{ mr: 1 }} /> Usuarios
                </MenuItem>
              </Menu>
            </>
          )}

          {user ? (
            <Button
              component={Link}
              href="/user/dashboard"
              startIcon={<Person />}
              endIcon={<ArrowDropDown />}
              sx={{ color: 'inherit', textTransform: 'none', fontWeight: 'medium' }}
            >
              {user.username}
            </Button>
          ) : anonUsername ? (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Chip
                avatar={<Avatar sx={{ width: 24, height: 24 }}><Person sx={{ fontSize: 14 }} /></Avatar>}
                label={anonUsername}
                variant="outlined"
              />
              <Button
                component={Link}
                href="/user/auth/#login"
                variant="contained"
                color="secondary"
                startIcon={<Login />}
                sx={{ borderRadius: '12px' }}
              >
                ¡Empezar!
              </Button>
            </Box>
          ) : (
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button component={Link} href="/user/auth/#login" startIcon={<Login />} sx={{ borderRadius: '12px' }}>
                Iniciar Sesión
              </Button>
              {enableRegistration && (
                <Button
                  component={Link}
                  href="/user/auth/#register"
                  variant="contained"
                  color="primary"
                  startIcon={<PersonAdd />}
                  sx={{ borderRadius: '12px' }}
                >
                  Registrarse
                </Button>
              )}
            </Box>
          )}
        </Box>
      </NavContainer>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={() => setSnackbarOpen(false)}
      >
        <Alert onClose={() => setSnackbarOpen(false)} severity="success" sx={{ width: '100%' }}>
          ¡Felicidades! Has obtenido el badge: {newBadge}
        </Alert>
      </Snackbar>
    </GlassNavbar>
  );
}

# backend/services/gamification_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from models.gamification import GamificationEvent, UserGamification, EventType, Badge
from schemas.gamification import GamificationEventCreate, EventTypeCreate, BadgeCreate
from dependencies.auth import UserContext

from typing import List, Optional
from sqlalchemy.orm import Session
from models.gamification import GamificationEvent, UserGamification, EventType, Badge
from schemas.gamification import GamificationEventCreate
from dependencies.auth import UserContext

def register_event(db: Session, event: GamificationEventCreate, user: UserContext) -> GamificationEvent:
    """Registra un evento de gamificación y actualiza los puntos del usuario."""
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None

    db_event = GamificationEvent(
        event_type_id=event.event_type_id,
        user_id=user_id,
        session_id=session_id
    )
    db.add(db_event)
    db.commit()
    db.refresh(db_event)
    update_user_gamification(db, user, event.event_type_id)
    return db_event

def get_user_gamification(db: Session, user: UserContext) -> List[UserGamification]:
    """Obtiene todos los registros de gamificación del usuario."""
    if user.user_type == "registered":
        return db.query(UserGamification).filter(UserGamification.user_id == int(user.user_id)).all()
    return db.query(UserGamification).filter(UserGamification.session_id == user.session_id).all()

def get_user_events(db: Session, user: UserContext) -> List[GamificationEvent]:
    """Obtiene todos los eventos de gamificación del usuario."""
    if user.user_type == "registered":
        return db.query(GamificationEvent).filter(GamificationEvent.user_id == int(user.user_id)).all()
    return db.query(GamificationEvent).filter(GamificationEvent.session_id == user.session_id).all()

def get_event_details(db: Session, event_id: int, user: UserContext) -> Optional[GamificationEvent]:
    """Obtiene los detalles de un evento específico si pertenece al usuario."""
    event = db.query(GamificationEvent).filter(GamificationEvent.id == event_id).first()
    if not event:
        return None
    if (user.user_type == "registered" and event.user_id == int(user.user_id)) or \
       (user.user_type == "anonymous" and event.session_id == user.session_id):
        return event
    return None

def get_badges_for_event(db: Session, event_type_id: int) -> List[Badge]:
    """Obtiene todos los badges asociados a un tipo de evento."""
    return db.query(Badge).filter(Badge.event_type_id == event_type_id).all()

def get_user_progress_for_event(db: Session, user: UserContext, event_type_id: int) -> Optional[UserGamification]:
    """Obtiene el progreso del usuario para un tipo de evento específico."""
    if user.user_type == "registered":
        return db.query(UserGamification).filter(
            UserGamification.user_id == int(user.user_id),
            UserGamification.event_type_id == event_type_id
        ).first()
    return db.query(UserGamification).filter(
        UserGamification.session_id == user.session_id,
        UserGamification.event_type_id == event_type_id
    ).first()

def update_user_gamification(db: Session, user: UserContext, event_type_id: int) -> UserGamification:
    """Actualiza los puntos y badges del usuario para un tipo de evento."""
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None

    gamification = get_user_progress_for_event(db, user, event_type_id)
    if not gamification:
        gamification = UserGamification(
            user_id=user_id,
            session_id=session_id,
            event_type_id=event_type_id,
            points=0
        )
        db.add(gamification)

    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise ValueError("Event type not found")

    events_count = db.query(GamificationEvent).filter(
        GamificationEvent.event_type_id == event_type_id,
        (GamificationEvent.user_id == user_id) if user_id else (GamificationEvent.session_id == session_id)
    ).count()

    gamification.points = events_count * event_type.points_per_event

    badge = db.query(Badge).filter(
        Badge.event_type_id == event_type_id,
        Badge.user_type.in_([user.user_type, "both"]),
        Badge.required_points <= gamification.points
    ).order_by(Badge.required_points.desc()).first()

    gamification.badge_id = badge.id if badge else None
    db.commit()
    db.refresh(gamification)
    return gamification

def create_event_type(db: Session, event_type: EventTypeCreate):
    db_event_type = EventType(**event_type.dict())
    db.add(db_event_type)
    db.commit()
    db.refresh(db_event_type)
    return db_event_type

def create_badge(db: Session, badge: BadgeCreate):
    db_badge = Badge(**badge.dict())
    db.add(db_badge)
    db.commit()
    db.refresh(db_badge)
    return db_badge

def calculate_points(api_usages: int) -> int:
    """Calcula los puntos según el número de usos de la API."""
    if api_usages >= 30:
        return 1000
    elif api_usages >= 20:
        return 500
    elif api_usages >= 10:
        return 100
    elif api_usages >= 1:
        return 5
    return 0


# backend/schemas/gamification.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List

class EventTypeBase(BaseModel):
    name: str
    description: Optional[str] = None
    points_per_event: int = 0

class EventTypeCreate(EventTypeBase):
    pass

class EventTypeResponse(EventTypeBase):
    id: int

    class Config:
        from_attributes = True

class BadgeBase(BaseModel):
    name: str
    description: Optional[str] = None
    event_type_id: int
    required_points: int
    user_type: str = "both"

class BadgeCreate(BadgeBase):
    pass

class BadgeResponse(BadgeBase):
    id: int

    class Config:
        from_attributes = True

class GamificationEventBase(BaseModel):
    event_type_id: int

class GamificationEventCreate(GamificationEventBase):
    pass

class GamificationEventResponse(GamificationEventBase):
    id: int
    user_id: Optional[int]
    session_id: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

class UserGamificationBase(BaseModel):
    points: int
    badge_id: Optional[int]

class UserGamificationResponse(UserGamificationBase):
    event_type_id: int
    user_id: Optional[int]
    session_id: Optional[str]
    event_type: EventTypeResponse
    badge: Optional[BadgeResponse]

    class Config:
        from_attributes = True

# backend/models/guests.py (antes era sessions.py)
# Módulo del modelo de sesión para usuarios anonimos que no estan identificados.
from sqlalchemy import Column, String, Integer, DateTime, Float
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime

class GuestsSession(Base):
    __tablename__ = "sesiones_anonimas"
    
    id = Column(String(36), primary_key=True, index=True)  
    username = Column(String(50), unique=True, nullable=False)  
    credits = Column(Integer, default=100)  
    create_at = Column(DateTime, default=datetime.utcnow)  
    ultima_actividad = Column(DateTime, nullable=True)  
    last_ip = Column(String(45), nullable=True)  

    # 📌 Información Inferida
    #probable_pais = Column(String(100), nullable=True)  
    #probable_industria = Column(String(100), nullable=True)  
    #probable_num_empleados = Column(Integer, nullable=True)  
    #probable_ingresos_anuales = Column(Float, nullable=True)  
    #probable_tecnologias_usadas = Column(String(255), nullable=True)  
    #engagement_anonimo = Column(Float, nullable=True)  # % de uso en la sesión  

    # Relación con gamificación
    gamification_events = relationship("GamificationEvent", back_populates="session")
    gamification = relationship("UserGamification", back_populates="session")

# backend/models/gamification.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime
from models.user import User
from models.guests import GuestsSession

class EventType(Base):
    __tablename__ = "event_types"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "api_usage"
    description = Column(String(255), nullable=True)
    points_per_event = Column(Integer, default=0)  # Puntos por ocurrencia del evento

    badges = relationship("Badge", back_populates="event_type")
    gamification_events = relationship("GamificationEvent", back_populates="event_type")
    user_gamification = relationship("UserGamification", back_populates="event_type")

class Badge(Base):
    __tablename__ = "badges"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "Novato", "Becario"
    description = Column(String(255), nullable=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    required_points = Column(Integer, nullable=False)  # Puntos necesarios para el badge
    user_type = Column(String(20), default="both")  # "anonymous", "registered", "both"

    event_type = relationship("EventType", back_populates="badges")
    user_gamification = relationship("UserGamification", back_populates="badge")

class GamificationEvent(Base):
    __tablename__ = "gamification_events"
    
    id = Column(Integer, primary_key=True, index=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36), ForeignKey("sesiones_anonimas.id"), nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    event_type = relationship("EventType", back_populates="gamification_events")
    user = relationship("User", back_populates="gamification_events")
    session = relationship("GuestsSession", back_populates="gamification_events")

class UserGamification(Base):
    __tablename__ = "user_gamification"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36), ForeignKey("sesiones_anonimas.id"), nullable=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    points = Column(Integer, default=0)
    badge_id = Column(Integer, ForeignKey("badges.id"), nullable=True)
    
    event_type = relationship("EventType", back_populates="user_gamification")
    badge = relationship("Badge", back_populates="user_gamification")
    user = relationship("User", back_populates="gamification")
    session = relationship("GuestsSession", back_populates="gamification")



#backend/main.py

@app.get("/info")
async def get_info(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_anonymous = get_setting(db, "disable_anonymous_users")
    base_info = {
        "user_id": user.user_id,
        "email": user.email,
        "username": user.username,
        "user_type": user.user_type,
        "subscription": user.subscription,
        "credits": user.credits,
        "rol": user.rol,
        "session_id": user.session_id if user.user_type == "anonymous" else None
    }

    gamification = get_user_gamification(db, user)
    gamification_data = [
        UserGamificationResponse.from_orm(g) for g in gamification
    ]

    return {**base_info, "gamification": gamification_data}

Tomate tu tiempo,  Y recuerda que cualquier archivo que eches en falta te lo puedo facilitar

 gracias.


Se que es muchiiiisima información, por favor leela toda con detenimiento. Si es mucho separa tu respuesta en partes. Solicitame los archivos que necesites ver. Respeta la logica actual para no romper ningun servicio activo. Es importante esta parte de la gamificación, tomate tu tiempo.






