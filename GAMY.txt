Excelente , pero te has dejado muchas cosas por el camino que estan provocando algunos bugs:

- 1- Con los nuevos cambios no se actualizan el numero de insignias ni el numero de puntos, ademas el json con la info del usuario devuelve gamification vacio, por ejemplo: 

Informaci贸n obtenida: {"user_id":"a50a0b78-e23b-4ab8-a14f-3d01096a492c","email":"anonymous@example.com","username":"Guest_k19uy","user_type":"anonymous","subscription":"basic","credits":100,"rol":"anonymous","session_id":"a50a0b78-e23b-4ab8-a14f-3d01096a492c","gamification":[]}

- 2 - Tu soluci贸n para refrescar los badges no funciona y no me gusta, debe ser en tiempo real al igual que sucede con los creditos

Console Error

Error: setGamification is not a function

src/components/web/Navbar.tsx (127:11) @ Navbar.useEffect.interval

  125 |           }
  126 |
> 127 |           setGamification({ points: totalPoints, badges });
      |           ^
  128 |         }
  129 |       } catch (err) {
  130 |         console.error("Error al actualizar datos:", err);

Call Stack 1
Navbar.useEffect.interval
src/components/web/Navbar.tsx (127:11)

Implanta una soluci贸n para que se actualicen los puntos e insignias conforme se van consiguiendo al igual que sucede con los creitos

-3 - No has creado los nuevos tipados de datos que has utilizado en tu codigo en context.tsx

import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

aqui tienes los tipados actuales relacionados con los tipados:


// respuesta /info
export interface UserInfo {
  user_id: string | null;
  email: string | null;
  username: string | null;
  user_type: string;
  subscription: string | null;
  credits: number;
  rol: string | null;
  session_id?: string; // Solo para an贸nimos
 }

 export interface EventType {
  id: number;
  name: string;
  description?: string;
  points_per_event: number;
}

export interface Badge {
  id: number;
  name: string;
  description?: string;
  event_type_id: number;
  required_points: number;
  user_type: string; // "anonymous", "registered", "both"
}

export interface Gamification {
  points: number;
  badges: Badge[]; // Ahora es una lista de badges


- 4- La soluci贸n al navbar devuelve muchos errores de propiedades que no existen en el archivo

./src/components/web/Navbar.tsx:76:52
Type error: Property 'setGamification' does not exist on type 'AuthContextType'.

  74 | export default function Navbar() {
  75 |   const theme = useTheme();
> 76 |   const { user, credits, gamification, setCredits, setGamification, logout } = useAuth();
     |                                                                                                              ^


UserInfo tampoco me lo reconoce en esta linea :         const { data: infoData } = await fetchAPI<UserInfo>("/info");

UserGamificationResponse tampoco me lo reconoce en el contexto del archivo:         const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");

Aqui tienes un resumen de todas las definiciones que dan error en tu codigo junto con el modulo o archivo donde aparece

[{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/lib/auth/context.tsx",
	"owner": "typescript",
	"code": "2305",
	"severity": 8,
	"message": "Module '\"../types\"' has no exported member 'UserGamificationResponse'.",
	"source": "ts",
	"startLineNumber": 9,
	"startColumn": 62,
	"endLineNumber": 9,
	"endColumn": 86
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/lib/auth/context.tsx",
	"owner": "typescript",
	"code": "2305",
	"severity": 8,
	"message": "Module '\"../types\"' has no exported member 'GamificationEventResponse'.",
	"source": "ts",
	"startLineNumber": 9,
	"startColumn": 35,
	"endLineNumber": 9,
	"endColumn": 60
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/lib/auth/context.tsx",
	"owner": "typescript",
	"code": "2305",
	"severity": 8,
	"message": "Module '\"../types\"' has no exported member 'GamificationEventCreate'.",
	"source": "ts",
	"startLineNumber": 9,
	"startColumn": 10,
	"endLineNumber": 9,
	"endColumn": 33
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2304",
	"severity": 8,
	"message": "Cannot find name 'Badge'.",
	"source": "ts",
	"startLineNumber": 114,
	"startColumn": 88,
	"endLineNumber": 114,
	"endColumn": 93
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2304",
	"severity": 8,
	"message": "Cannot find name 'UserGamificationResponse'.",
	"source": "ts",
	"startLineNumber": 111,
	"startColumn": 59,
	"endLineNumber": 111,
	"endColumn": 83
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2304",
	"severity": 8,
	"message": "Cannot find name 'UserInfo'.",
	"source": "ts",
	"startLineNumber": 106,
	"startColumn": 51,
	"endLineNumber": 106,
	"endColumn": 59
},{
	"resource": "/home/vinxenxo/netptuno/neptuno/frontend/src/components/web/Navbar.tsx",
	"owner": "typescript",
	"code": "2339",
	"severity": 8,
	"message": "Property 'setGamification' does not exist on type 'AuthContextType'.",
	"source": "ts",
	"startLineNumber": 76,
	"startColumn": 52,
	"endLineNumber": 76,
	"endColumn": 67
}]

-5- Vamos a crear una pagina que se llame "Rankings",vamos a crear una nueva pagina en /src/app/rankings donde aparezca el listado de usuarios (registrados u anonimos) con los datos de puntos conseguidos, insignias obtenidas, nombre de usuario, y que se pueda ordenar tanto por puntos conseguidos como por insignias conseguidas.


-6-  - Por ultimo vamos a crear una pagina con ejemplos muy afinados y exclusivos e ilustrativos de nuestra nueva funci贸n de puntos y badges. En esta nueva pagina que se llamar谩 "Ejemplos" habr谩n los siguientes componentes:

- Una encuesta con varias opciones (cada pregunta que responda el usuario ser谩 1 punto), si responde toda la encuesta le daremos un badge

- Un formulario de registro con varios campos (cada campo rellenado ser谩 un punto) si responde todos los campos obtendr谩 insignia

- Un formulario donde el usuario podr谩 subscribirse a varias listas de correo ficticias (por cada lista que se apunte ser谩 un punto) si se apunta a todas ser谩 un badge.


Crea los modelos de datos, esquemas pydantic, interfaces, servicios, middleware etc para que todo encaje a la perfeci贸n con el codigo actua y mantener separaci贸n de responsabilidades (modelos, servicios y rutas en archivos independientes). Piensa en nuestra aplicaci贸n y recuerdala todo lo posible para realizar una implantaci贸n lo mas profesional posible y que se adapte con la menor fricci贸n posible a lo que ya hay hecho.Crea los modelos de datos, esquemas pydantic, interfaces, servicios, middleware etc para que todo encaje a la perfeci贸n con el codigo actua y mantener separaci贸n de responsabilidades (modelos, servicios y rutas en archivos independientes).

Recuerda que gestionamos usuarios anonimos almacenando en localstorage y usuarios registrados, ambos tienen su persistencia en la db.


Recuerda que hemos implantado en el paso anterior un modelado m谩s complejo para badges y eventos que no depende de enums hardcodeados, sino que use la base de datos para almacenar esta informaci贸n

Te paso archivos que puede ser de tu interes que reviseses para aplicar los cambios solicitadores

// src/lib/auth/context.tsx
"use client";

import { createContext, useContext, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import fetchAPI from "@/lib/api";
import { User, TokenResponse, RegisterRequest, UserInfo, Gamification, Badge  } from "../types";
import { motion } from "framer-motion";
import { GamificationEventCreate, GamificationEventResponse, UserGamificationResponse } from "../types";

interface AuthContextType {
  user: User | null;
  credits: number;
  gamification: Gamification | null; // A帽adimos gamificaci贸n al contexto
  setCredits: (credits: number) => void; // A帽adido
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  register: (data: RegisterRequest) => Promise<void>;
  loginWithGoogle: () => void;
  refreshToken: () => Promise<string | null>;
  updateProfile: (data: Partial<User>) => Promise<void>;
  deleteProfile: () => Promise<void>;
  resetPassword: (email: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [credits, setCredits] = useState<number>(100); // Valor por defecto para an贸nimos
  const [gamification, setGamification] = useState<Gamification | null>(null); // Estado para gamificaci贸n
  const [loading, setLoading] = useState(true);
  const router = useRouter();


  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data } = await fetchAPI<UserInfo>("/info");
        if (data) {
          if (data.user_type === "registered") {
            setUser({
              id: parseInt(data.user_id!),
              email: data.email!,
              username: data.username!,
              rol: data.rol!,
              activo: true,
              subscription: data.subscription!,
              credits: data.credits,
              create_at: "",
              last_ip: "",
              last_login: "",
              user_type: data.user_type,
            });
            setCredits(data.credits);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          } else if (data.user_type === "anonymous") {
            setUser(null);
            setCredits(data.credits);
            localStorage.setItem("session_id", data.session_id!);
            localStorage.setItem("anonUsername", data.username!);
          } else {
            setUser(null);
            setCredits(0);
            localStorage.removeItem("session_id");
            localStorage.removeItem("anonUsername");
          }
  
          // Procesar datos de gamificaci贸n
          const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
          if (gamificationData && Array.isArray(gamificationData)) {
            const totalPoints = gamificationData.reduce((sum, g) => sum + g.points, 0);
            const badges = gamificationData.map(g => g.badge).filter(b => b !== null) as Badge[];
            setGamification({ points: totalPoints, badges });
          } else {
            setGamification({ points: 0, badges: [] });
          }
        }
      } catch (err) {
        console.error("Error en checkAuth:", err);
        setUser(null);
        setCredits(0);
        setGamification({ points: 0, badges: [] });
        localStorage.removeItem("session_id");
        localStorage.removeItem("anonUsername");
      } finally {
        setLoading(false);
      }
    };
  
    checkAuth();
  }, []);

  const login = async (email: string, password: string) => {
    const { data, error } = await fetchAPI<TokenResponse>(
      "/v1/auth/token",
      {
        method: "POST",
        data: { username: email, password, grant_type: "password" },
      },
      "application/x-www-form-urlencoded"
    );
    if (error) throw new Error(typeof error === "string" ? error : "Error al iniciar sesi贸n");
    localStorage.setItem("accessToken", data!.access_token);
    localStorage.setItem("refreshToken", data!.refresh_token);
    localStorage.removeItem("session_id");  // Limpiar session_id al iniciar sesi贸n
    const userResponse = await fetchAPI<User>("/v1/users/me");
    if (userResponse.data) {
      setUser(userResponse.data);
      setCredits(userResponse.data.credits);
      router.push("/user/dashboard");
    }
  };

  const logout = async () => {
    try {
      await fetchAPI("/v1/auth/logout", { method: "POST" });
    } catch (err) {
      console.error("Error al cerrar sesi贸n:", err);
    }
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    localStorage.removeItem("session_id");  // Limpiar session_id al cerrar sesi贸n
    setUser(null);
    // const anonCredits = localStorage.getItem("anonCredits");
    // setCredits(anonCredits ? parseInt(anonCredits) : 100);
    router.push("/");
  };

  const register = async (data: RegisterRequest) => {
    const { error } = await fetchAPI("/v1/auth/register", {
      method: "POST",
      data,
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al registrarse");
    await login(data.email, data.password);
  };

  const loginWithGoogle = () => {
    window.location.href = `${process.env.NEXT_PUBLIC_API_URL}/v1/auth/login/google`;
  };

  const refreshToken = async (): Promise<string | null> => {
    const refresh = localStorage.getItem("refreshToken");
    if (!refresh) {
      await logout();
      return null;
    }

    try {
      const { data, error } = await fetchAPI<TokenResponse>("/v1/auth/refresh", {
        method: "POST",
        data: { refresh_token: refresh },
        ...(true && { _retry: true }) // Evitar bucle infinito
      });

      if (error || !data) {
        throw new Error(typeof error === "string" ? error : JSON.stringify(error) || "Refresh failed");
      }

      // Actualizar localStorage ANTES de cualquier otra operaci贸n
      localStorage.setItem("accessToken", data.access_token);
      localStorage.setItem("refreshToken", data.refresh_token);

      // Actualizar estado del usuario
      const userResponse = await fetchAPI<User>("/v1/users/me");
      if (userResponse.data) {
        setUser(userResponse.data);
        setCredits(userResponse.data.credits);
      }

      return data.access_token;
    } catch (err) {
      console.error("Refresh error:", err);
      await logout();
      return null;
    }
  };

  const updateProfile = async (data: Partial<User>) => {
    try {
      const response = await fetchAPI<User>("/v1/users/me", {
        method: "PUT",
        data,
      });
      if (response.error) throw new Error(typeof response.error === "string" ? response.error : JSON.stringify(response.error));
      if (response.data) {
        setUser(response.data);
        setCredits(response.data.credits);
      } else {
        throw new Error("No se recibi贸 la informaci贸n del usuario actualizado");
      }
    } catch (err) {
      console.error("Error al actualizar el perfil:", err);
      throw err;
    }
  };

  const deleteProfile = async () => {
    const { error } = await fetchAPI("/v1/users/me", { method: "DELETE" });
    if (error) throw new Error(typeof error === "string" ? error : "Error al eliminar perfil");
    logout();
  };

  const resetPassword = async (email: string) => {
    const { error } = await fetchAPI("/v1/auth/password-reset", {
      method: "POST",
      data: { email },
    });
    if (error) throw new Error(typeof error === "string" ? error : "Error al restablecer contrase帽a");
  };

  if (loading) {
    return (
      <motion.div
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        className="fixed inset-0 flex items-center justify-center bg-[var(--background)] z-50"
      >
        <div className="text-[var(--foreground)] text-xl font-semibold">
          Cargando Neptuno...
        </div>
      </motion.div>
    );
  }

  return (
    <AuthContext.Provider
      value={{ user, credits,gamification, setCredits, login, logout, register, loginWithGoogle, refreshToken, updateProfile, deleteProfile, resetPassword }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) throw new Error("useAuth must be used within AuthProvider");
  return context;
};

// src/components/web/Navbar.tsx
"use client";

import { useState, useEffect } from "react";
import { useAuth } from "@/lib/auth/context";
import Link from "next/link";
import fetchAPI from "@/lib/api";
import { 
  Button, 
  Avatar, 
  Chip, 
  IconButton, 
  Menu, 
  MenuItem, 
  Divider, 
  useTheme,
  styled,
  Box,
  Typography,
  Snackbar,
  Alert
} from "@mui/material";
import {
  MonetizationOn,
  Settings,
  ListAlt,
  People,
  Dashboard,
  Login,
  PersonAdd,
  Person,
  ArrowDropDown,
  Home,
  Star,
  EmojiEvents
} from "@mui/icons-material";

const GlassNavbar = styled('nav')(({ theme }) => ({
  background: 'rgba(255, 255, 255, 0.1)',
  backdropFilter: 'blur(10px)',
  borderBottom: `1px solid ${theme.palette.divider}`,
  padding: theme.spacing(1, 2),
  position: 'sticky',
  top: 0,
  zIndex: 1000,
}));

const NavContainer = styled(Box)(({ theme }) => ({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center',
  maxWidth: '1200px',
  margin: '0 auto',
}));

const CreditsChip = styled(Chip)(({ theme }) => ({
  background: 'rgba(255, 165, 0, 0.2)', // Fondo naranja claro
  color: '#FFA500', // Texto naranja
  borderColor: '#FFA500',
}));

const PointsChip = styled(Chip)(({ theme }) => ({
  background: 'rgba(255, 215, 0, 0.2)', // Fondo dorado claro
  color: '#FFD700', // Texto dorado
  borderColor: '#FFD700',
}));

const BadgesChip = styled(Chip)(({ theme }) => ({
  background: 'rgba(0, 128, 0, 0.2)', // Fondo verde claro
  color: '#008000', // Texto verde
  borderColor: '#008000',
}));

export default function Navbar() {
  const theme = useTheme();
  const { user, credits, gamification, setCredits, setGamification, logout } = useAuth();
  const [settingsAnchorEl, setSettingsAnchorEl] = useState<null | HTMLElement>(null);
  const [disableCredits, setDisableCredits] = useState(false);
  const [enableRegistration, setEnableRegistration] = useState(true);
  const [anonUsername, setAnonUsername] = useState<string | null>(null);
  const [snackbarOpen, setSnackbarOpen] = useState(false);
  const [newBadge, setNewBadge] = useState<string | null>(null);

  useEffect(() => {
    const storedAnonUsername = localStorage.getItem("anonUsername");
    setAnonUsername(storedAnonUsername);
  }, []);

  useEffect(() => {
    const fetchSettings = async () => {
      try {
        const disableCreditsRes = await fetchAPI("/v1/settings/disable_credits");
        const enableRegistrationRes = await fetchAPI("/v1/settings/enable_registration");
        setDisableCredits(disableCreditsRes.data === "true" || disableCreditsRes.data === true);
        setEnableRegistration(enableRegistrationRes.data === "true" || enableRegistrationRes.data === true);
      } catch (err) {
        console.error("Error al obtener configuraciones:", err);
      }
    };
    fetchSettings();
  }, []);

  useEffect(() => {
    const interval = setInterval(async () => {
      try {
        const { data: infoData } = await fetchAPI<UserInfo>("/info");
        if (infoData) {
          setCredits(infoData.credits);
        }

        const { data: gamificationData } = await fetchAPI<UserGamificationResponse[]>("/v1/gamification/me");
        if (gamificationData && Array.isArray(gamificationData)) {
          const totalPoints = gamificationData.reduce((sum, g) => sum + g.points, 0);
          const badges = gamificationData.map(g => g.badge).filter(b => b !== null) as Badge[];
          
          // Detectar nuevos badges
          const previousBadges = JSON.parse(localStorage.getItem("badges") || "[]");
          const currentBadgeIds = badges.map(b => b.id);
          const newBadges = currentBadgeIds.filter(id => !previousBadges.includes(id));
          if (newBadges.length > 0) {
            const badge = badges.find(b => b.id === newBadges[0]);
            setNewBadge(badge?.name || "Nuevo badge");
            setSnackbarOpen(true);
            localStorage.setItem("badges", JSON.stringify(currentBadgeIds));
          }

          setGamification({ points: totalPoints, badges });
        }
      } catch (err) {
        console.error("Error al actualizar datos:", err);
      }
    }, 30000); // Cada 30 segundos

    return () => clearInterval(interval);
  }, [setCredits, setGamification]);

  const handleSettingsMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    setSettingsAnchorEl(event.currentTarget);
  };

  const handleSettingsMenuClose = () => {
    setSettingsAnchorEl(null);
  };

  return (
    <GlassNavbar>
      <NavContainer>
        <Link href="/" passHref>
          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, cursor: 'pointer' }}>
            <Home color="primary" />
            <Typography 
              variant="h6" 
              component="span" 
              sx={{ 
                fontWeight: 'bold',
                background: `linear-gradient(45deg, ${theme.palette.primary.main} 30%, ${theme.palette.secondary.main} 90%)`,
                WebkitBackgroundClip: 'text',
                WebkitTextFillColor: 'transparent'
              }}
            >
              Neptuno
            </Typography>
          </Box>
        </Link>

        <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
          {!disableCredits && credits > 0 && (
            <CreditsChip
              icon={<MonetizationOn />}
              label={credits}
              variant="outlined"
            />
          )}

          {gamification && (
            <>
              <PointsChip
                icon={<Star />}
                label={gamification.points}
                variant="outlined"
              />
              <BadgesChip
                icon={<EmojiEvents />}
                label={gamification.badges.length}
                variant="outlined"
              />
            </>
          )}

          {user?.rol === "admin" && (
            <>
              <IconButton
                onClick={handleSettingsMenuOpen}
                sx={{ color: 'inherit', '&:hover': { backgroundColor: 'rgba(255, 255, 255, 0.1)' } }}
              >
                <Settings />
              </IconButton>
              <Menu
                anchorEl={settingsAnchorEl}
                open={Boolean(settingsAnchorEl)}
                onClose={handleSettingsMenuClose}
                PaperProps={{
                  sx: {
                    background: 'rgba(255, 255, 255, 0.9)',
                    backdropFilter: 'blur(10px)',
                    borderRadius: '12px',
                    mt: 1,
                    minWidth: '200px'
                  }
                }}
              >
                <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/dashboard">
                  <Dashboard sx={{ mr: 1 }} /> Dashboard
                </MenuItem>
                <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/registry">
                  <ListAlt sx={{ mr: 1 }} /> Registros
                </MenuItem>
                <MenuItem onClick={handleSettingsMenuClose} component={Link} href="/admin/users">
                  <People sx={{ mr: 1 }} /> Usuarios
                </MenuItem>
              </Menu>
            </>
          )}

          {user ? (
            <Button
              component={Link}
              href="/user/dashboard"
              startIcon={<Person />}
              endIcon={<ArrowDropDown />}
              sx={{ color: 'inherit', textTransform: 'none', fontWeight: 'medium' }}
            >
              {user.username}
            </Button>
          ) : anonUsername ? (
            <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
              <Chip
                avatar={<Avatar sx={{ width: 24, height: 24 }}><Person sx={{ fontSize: 14 }} /></Avatar>}
                label={anonUsername}
                variant="outlined"
              />
              <Button
                component={Link}
                href="/user/auth/#login"
                variant="contained"
                color="secondary"
                startIcon={<Login />}
                sx={{ borderRadius: '12px' }}
              >
                隆Empezar!
              </Button>
            </Box>
          ) : (
            <Box sx={{ display: 'flex', gap: 1 }}>
              <Button component={Link} href="/user/auth/#login" startIcon={<Login />} sx={{ borderRadius: '12px' }}>
                Iniciar Sesi贸n
              </Button>
              {enableRegistration && (
                <Button
                  component={Link}
                  href="/user/auth/#register"
                  variant="contained"
                  color="primary"
                  startIcon={<PersonAdd />}
                  sx={{ borderRadius: '12px' }}
                >
                  Registrarse
                </Button>
              )}
            </Box>
          )}
        </Box>
      </NavContainer>

      <Snackbar
        open={snackbarOpen}
        autoHideDuration={6000}
        onClose={() => setSnackbarOpen(false)}
      >
        <Alert onClose={() => setSnackbarOpen(false)} severity="success" sx={{ width: '100%' }}>
          隆Felicidades! Has obtenido el badge: {newBadge}
        </Alert>
      </Snackbar>
    </GlassNavbar>
  );
}

# backend/services/gamification_service.py
from typing import List, Optional
from sqlalchemy.orm import Session
from models.gamification import GamificationEvent, UserGamification, EventType, Badge
from schemas.gamification import GamificationEventCreate, EventTypeCreate, BadgeCreate
from dependencies.auth import UserContext

from typing import List, Optional
from sqlalchemy.orm import Session
from models.gamification import GamificationEvent, UserGamification, EventType, Badge
from schemas.gamification import GamificationEventCreate
from dependencies.auth import UserContext

def register_event(db: Session, event: GamificationEventCreate, user: UserContext) -> GamificationEvent:
    """Registra un evento de gamificaci贸n y actualiza los puntos del usuario."""
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None

    db_event = GamificationEvent(
        event_type_id=event.event_type_id,
        user_id=user_id,
        session_id=session_id
    )
    db.add(db_event)
    db.commit()
    db.refresh(db_event)
    update_user_gamification(db, user, event.event_type_id)
    return db_event

def get_user_gamification(db: Session, user: UserContext) -> List[UserGamification]:
    """Obtiene todos los registros de gamificaci贸n del usuario."""
    if user.user_type == "registered":
        return db.query(UserGamification).filter(UserGamification.user_id == int(user.user_id)).all()
    return db.query(UserGamification).filter(UserGamification.session_id == user.session_id).all()

def get_user_events(db: Session, user: UserContext) -> List[GamificationEvent]:
    """Obtiene todos los eventos de gamificaci贸n del usuario."""
    if user.user_type == "registered":
        return db.query(GamificationEvent).filter(GamificationEvent.user_id == int(user.user_id)).all()
    return db.query(GamificationEvent).filter(GamificationEvent.session_id == user.session_id).all()

def get_event_details(db: Session, event_id: int, user: UserContext) -> Optional[GamificationEvent]:
    """Obtiene los detalles de un evento espec铆fico si pertenece al usuario."""
    event = db.query(GamificationEvent).filter(GamificationEvent.id == event_id).first()
    if not event:
        return None
    if (user.user_type == "registered" and event.user_id == int(user.user_id)) or \
       (user.user_type == "anonymous" and event.session_id == user.session_id):
        return event
    return None

def get_badges_for_event(db: Session, event_type_id: int) -> List[Badge]:
    """Obtiene todos los badges asociados a un tipo de evento."""
    return db.query(Badge).filter(Badge.event_type_id == event_type_id).all()

def get_user_progress_for_event(db: Session, user: UserContext, event_type_id: int) -> Optional[UserGamification]:
    """Obtiene el progreso del usuario para un tipo de evento espec铆fico."""
    if user.user_type == "registered":
        return db.query(UserGamification).filter(
            UserGamification.user_id == int(user.user_id),
            UserGamification.event_type_id == event_type_id
        ).first()
    return db.query(UserGamification).filter(
        UserGamification.session_id == user.session_id,
        UserGamification.event_type_id == event_type_id
    ).first()

def update_user_gamification(db: Session, user: UserContext, event_type_id: int) -> UserGamification:
    """Actualiza los puntos y badges del usuario para un tipo de evento."""
    user_id = int(user.user_id) if user.user_type == "registered" else None
    session_id = user.session_id if user.user_type == "anonymous" else None

    gamification = get_user_progress_for_event(db, user, event_type_id)
    if not gamification:
        gamification = UserGamification(
            user_id=user_id,
            session_id=session_id,
            event_type_id=event_type_id,
            points=0
        )
        db.add(gamification)

    event_type = db.query(EventType).filter(EventType.id == event_type_id).first()
    if not event_type:
        raise ValueError("Event type not found")

    events_count = db.query(GamificationEvent).filter(
        GamificationEvent.event_type_id == event_type_id,
        (GamificationEvent.user_id == user_id) if user_id else (GamificationEvent.session_id == session_id)
    ).count()

    gamification.points = events_count * event_type.points_per_event

    badge = db.query(Badge).filter(
        Badge.event_type_id == event_type_id,
        Badge.user_type.in_([user.user_type, "both"]),
        Badge.required_points <= gamification.points
    ).order_by(Badge.required_points.desc()).first()

    gamification.badge_id = badge.id if badge else None
    db.commit()
    db.refresh(gamification)
    return gamification

def create_event_type(db: Session, event_type: EventTypeCreate):
    db_event_type = EventType(**event_type.dict())
    db.add(db_event_type)
    db.commit()
    db.refresh(db_event_type)
    return db_event_type

def create_badge(db: Session, badge: BadgeCreate):
    db_badge = Badge(**badge.dict())
    db.add(db_badge)
    db.commit()
    db.refresh(db_badge)
    return db_badge

def calculate_points(api_usages: int) -> int:
    """Calcula los puntos seg煤n el n煤mero de usos de la API."""
    if api_usages >= 30:
        return 1000
    elif api_usages >= 20:
        return 500
    elif api_usages >= 10:
        return 100
    elif api_usages >= 1:
        return 5
    return 0


# backend/schemas/gamification.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional, List

class EventTypeBase(BaseModel):
    name: str
    description: Optional[str] = None
    points_per_event: int = 0

class EventTypeCreate(EventTypeBase):
    pass

class EventTypeResponse(EventTypeBase):
    id: int

    class Config:
        from_attributes = True

class BadgeBase(BaseModel):
    name: str
    description: Optional[str] = None
    event_type_id: int
    required_points: int
    user_type: str = "both"

class BadgeCreate(BadgeBase):
    pass

class BadgeResponse(BadgeBase):
    id: int

    class Config:
        from_attributes = True

class GamificationEventBase(BaseModel):
    event_type_id: int

class GamificationEventCreate(GamificationEventBase):
    pass

class GamificationEventResponse(GamificationEventBase):
    id: int
    user_id: Optional[int]
    session_id: Optional[str]
    timestamp: datetime

    class Config:
        from_attributes = True

class UserGamificationBase(BaseModel):
    points: int
    badge_id: Optional[int]

class UserGamificationResponse(UserGamificationBase):
    event_type_id: int
    user_id: Optional[int]
    session_id: Optional[str]
    event_type: EventTypeResponse
    badge: Optional[BadgeResponse]

    class Config:
        from_attributes = True

# backend/models/guests.py (antes era sessions.py)
# M贸dulo del modelo de sesi贸n para usuarios anonimos que no estan identificados.
from sqlalchemy import Column, String, Integer, DateTime, Float
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime

class GuestsSession(Base):
    __tablename__ = "sesiones_anonimas"
    
    id = Column(String(36), primary_key=True, index=True)  
    username = Column(String(50), unique=True, nullable=False)  
    credits = Column(Integer, default=100)  
    create_at = Column(DateTime, default=datetime.utcnow)  
    ultima_actividad = Column(DateTime, nullable=True)  
    last_ip = Column(String(45), nullable=True)  

    #  Informaci贸n Inferida
    #probable_pais = Column(String(100), nullable=True)  
    #probable_industria = Column(String(100), nullable=True)  
    #probable_num_empleados = Column(Integer, nullable=True)  
    #probable_ingresos_anuales = Column(Float, nullable=True)  
    #probable_tecnologias_usadas = Column(String(255), nullable=True)  
    #engagement_anonimo = Column(Float, nullable=True)  # % de uso en la sesi贸n  

    # Relaci贸n con gamificaci贸n
    gamification_events = relationship("GamificationEvent", back_populates="session")
    gamification = relationship("UserGamification", back_populates="session")

# backend/models/gamification.py
from sqlalchemy import Column, Integer, String, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from core.database import Base
from datetime import datetime
from models.user import User
from models.guests import GuestsSession

class EventType(Base):
    __tablename__ = "event_types"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "api_usage"
    description = Column(String(255), nullable=True)
    points_per_event = Column(Integer, default=0)  # Puntos por ocurrencia del evento

    badges = relationship("Badge", back_populates="event_type")
    gamification_events = relationship("GamificationEvent", back_populates="event_type")
    user_gamification = relationship("UserGamification", back_populates="event_type")

class Badge(Base):
    __tablename__ = "badges"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String(50), unique=True, nullable=False)  # Ej: "Novato", "Becario"
    description = Column(String(255), nullable=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    required_points = Column(Integer, nullable=False)  # Puntos necesarios para el badge
    user_type = Column(String(20), default="both")  # "anonymous", "registered", "both"

    event_type = relationship("EventType", back_populates="badges")
    user_gamification = relationship("UserGamification", back_populates="badge")

class GamificationEvent(Base):
    __tablename__ = "gamification_events"
    
    id = Column(Integer, primary_key=True, index=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36), ForeignKey("sesiones_anonimas.id"), nullable=True)
    timestamp = Column(DateTime, default=datetime.utcnow)
    
    event_type = relationship("EventType", back_populates="gamification_events")
    user = relationship("User", back_populates="gamification_events")
    session = relationship("GuestsSession", back_populates="gamification_events")

class UserGamification(Base):
    __tablename__ = "user_gamification"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("usuarios.id"), nullable=True)
    session_id = Column(String(36), ForeignKey("sesiones_anonimas.id"), nullable=True)
    event_type_id = Column(Integer, ForeignKey("event_types.id"), nullable=False)
    points = Column(Integer, default=0)
    badge_id = Column(Integer, ForeignKey("badges.id"), nullable=True)
    
    event_type = relationship("EventType", back_populates="user_gamification")
    badge = relationship("Badge", back_populates="user_gamification")
    user = relationship("User", back_populates="gamification")
    session = relationship("GuestsSession", back_populates="gamification")



#backend/main.py

@app.get("/info")
async def get_info(user: UserContext = Depends(get_user_context), db: Session = Depends(get_db)):
    disable_anonymous = get_setting(db, "disable_anonymous_users")
    base_info = {
        "user_id": user.user_id,
        "email": user.email,
        "username": user.username,
        "user_type": user.user_type,
        "subscription": user.subscription,
        "credits": user.credits,
        "rol": user.rol,
        "session_id": user.session_id if user.user_type == "anonymous" else None
    }

    gamification = get_user_gamification(db, user)
    gamification_data = [
        UserGamificationResponse.from_orm(g) for g in gamification
    ]

    return {**base_info, "gamification": gamification_data}

Tomate tu tiempo,  Y recuerda que cualquier archivo que eches en falta te lo puedo facilitar

 gracias.


Se que es muchiiiisima informaci贸n, por favor leela toda con detenimiento. Si es mucho separa tu respuesta en partes. Solicitame los archivos que necesites ver. Respeta la logica actual para no romper ningun servicio activo. Es importante esta parte de la gamificaci贸n, tomate tu tiempo.






